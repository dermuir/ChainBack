(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Debugger", [], factory);
	else if(typeof exports === 'object')
		exports["Debugger"] = factory();
	else
		root["Debugger"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 37);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

exports.isDeliberatelySkippedNodeType = isDeliberatelySkippedNodeType;
exports.isSkippedNodeType = isSkippedNodeType;
exports.prefixName = prefixName;
exports.extractPrimarySource = extractPrimarySource;
exports.keccak256 = keccak256;
exports.stableKeccak256 = stableKeccak256;
exports.makeAssignment = makeAssignment;
exports.isCallMnemonic = isCallMnemonic;
exports.isShortCallMnemonic = isShortCallMnemonic;
exports.isDelegateCallMnemonicBroad = isDelegateCallMnemonicBroad;
exports.isDelegateCallMnemonicStrict = isDelegateCallMnemonicStrict;
exports.isStaticCallMnemonic = isStaticCallMnemonic;
exports.isCreateMnemonic = isCreateMnemonic;
exports.isNormalHaltingMnemonic = isNormalHaltingMnemonic;

var _truffleDecodeUtils = __webpack_require__(4);

var utils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const stringify = __webpack_require__(47);

/** AST node types that are skipped by stepNext() to filter out some noise */
function isDeliberatelySkippedNodeType(node) {
  const skippedTypes = ["ContractDefinition", "VariableDeclaration"];
  return skippedTypes.includes(node.nodeType);
}

//HACK
//these aren't the only types of skipped nodes, but determining all skipped
//nodes would be too difficult
function isSkippedNodeType(node) {
  const otherSkippedTypes = ["VariableDeclarationStatement", "Mapping"];
  return isDeliberatelySkippedNodeType(node) || otherSkippedTypes.includes(node.nodeType) || node.nodeType.includes("TypeName") || //HACK
  //skip string literals too -- we'll handle that manually
  node.typeDescriptions !== undefined && //seems this sometimes happens?
  utils.Definition.typeClass(node) === "stringliteral";
}

function prefixName(prefix, fn) {
  Object.defineProperty(fn, "name", {
    value: `${prefix}.${fn.name}`,
    configurable: true
  });

  return fn;
}

/*
 * extract the primary source from a source map
 * (i.e., the source for the first instruction, found
 * between the second and third colons)
 * (this is something of a HACK)
 */
function extractPrimarySource(sourceMap) {
  return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);
}

/**
 * @return 0x-prefix string of keccak256 hash
 */
function keccak256(...args) {
  return utils.Conversion.toHexString(utils.EVM.keccak256(...args));
}

/**
 * Given an object, return a stable hash by first running it through a stable
 * stringify operation before hashing
 */
function stableKeccak256(obj) {
  return keccak256({ type: "string", value: stringify(obj) });
}

/*
 * used by data; takes an id object and a ref (pointer) and returns a full
 * corresponding assignment object
 */
function makeAssignment(idObj, ref) {
  let id = stableKeccak256(idObj);
  return (0, _extends3.default)({}, idObj, { id, ref });
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a calling
 * instruction (does NOT include creation instructions)
 */
function isCallMnemonic(op) {
  const calls = ["CALL", "DELEGATECALL", "STATICCALL", "CALLCODE"];
  return calls.includes(op);
}

/*
 * returns true for mnemonics for calls that take only 6 args instead of 7
 */
function isShortCallMnemonic(op) {
  const shortCalls = ["DELEGATECALL", "STATICCALL"];
  return shortCalls.includes(op);
}

/*
 * returns true for mnemonics for calls that delegate storage
 */
function isDelegateCallMnemonicBroad(op) {
  const delegateCalls = ["DELEGATECALL", "CALLCODE"];
  return delegateCalls.includes(op);
}

/*
 * returns true for mnemonics for calls that delegate everything
 */
function isDelegateCallMnemonicStrict(op) {
  const delegateCalls = ["DELEGATECALL"];
  return delegateCalls.includes(op);
}

/*
 * returns true for mnemonics for static calls
 */
function isStaticCallMnemonic(op) {
  const delegateCalls = ["STATICCALL"];
  return delegateCalls.includes(op);
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a creation
 * instruction
 */
function isCreateMnemonic(op) {
  const creates = ["CREATE", "CREATE2"];
  return creates.includes(op);
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a normal
 * halting instruction
 */
function isNormalHaltingMnemonic(op) {
  const halts = ["STOP", "RETURN", "SELFDESTRUCT", "SUICIDE"];
  //the mnemonic SUICIDE is no longer used, but just in case, I'm including it
  return halts.includes(op);
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("reselect-tree");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("truffle-decode-utils");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("redux-saga/effects");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _bn = __webpack_require__(15);

var _bn2 = _interopRequireDefault(_bn);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _helpers = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:selectors"); // eslint-disable-line no-unused-vars

/**
 * create EVM-level selectors for a given trace step selector
 * may specify additional selectors to include
 */
function createStepSelectors(step, state = null) {
  let base = {
    /**
     * .trace
     *
     * trace step info related to operation
     */
    trace: (0, _reselectTree.createLeaf)([step], step => {
      if (!step) {
        return null;
      }
      let { gasCost, op, pc } = step;
      return { gasCost, op, pc };
    }),

    /**
     * .programCounter
     */
    programCounter: (0, _reselectTree.createLeaf)(["./trace"], step => step ? step.pc : null),

    /**
     * .isJump
     */
    isJump: (0, _reselectTree.createLeaf)(["./trace"], step => step.op != "JUMPDEST" && step.op.indexOf("JUMP") == 0),

    /**
     * .isCall
     *
     * whether the opcode will switch to another calling context
     */
    isCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCallMnemonic)(step.op)),

    /**
     * .isShortCall
     *
     * for calls that only take 6 arguments instead of 7
     */
    isShortCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isShortCallMnemonic)(step.op)),

    /**
     * .isDelegateCallBroad
     *
     * for calls that delegate storage
     */
    isDelegateCallBroad: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isDelegateCallMnemonicBroad)(step.op)),

    /**
     * .isDelegateCallStrict
     *
     * for calls that additionally delegate sender and value
     */
    isDelegateCallStrict: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isDelegateCallMnemonicStrict)(step.op)),

    /**
     * .isStaticCall
     */
    isStaticCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isStaticCallMnemonic)(step.op)),

    /**
     * .isCreate
     */
    isCreate: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCreateMnemonic)(step.op)),

    /**
     * .isHalting
     *
     * whether the instruction halts or returns from a calling context
     * NOTE: this covers only ordinary halts, not exceptional halts;
     * but it doesn't check the return status, so any normal halting
     * instruction will qualify here
     */
    isHalting: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isNormalHaltingMnemonic)(step.op)),

    /*
     * .isStore
     */
    isStore: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "SSTORE"),

    /*
     * .isLoad
     */
    isLoad: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "SLOAD"),

    /*
     * .touchesStorage
     *
     * whether the instruction involves storage
     */
    touchesStorage: (0, _reselectTree.createLeaf)(["./isStore", "isLoad"], (stores, loads) => stores || loads)
  };

  if (state) {
    const isRelative = path => typeof path == "string" && (path.startsWith("./") || path.startsWith("../"));

    if (isRelative(state)) {
      state = `../${state}`;
    }

    (0, _assign2.default)(base, {
      /**
       * .callAddress
       *
       * address transferred to by call operation
       */
      callAddress: (0, _reselectTree.createLeaf)(["./isCall", state], (isCall, { stack }) => {
        if (!isCall) {
          return null;
        }

        let address = stack[stack.length - 2];
        return DecodeUtils.Conversion.toAddress(address);
      }),

      /**
       * .createBinary
       *
       * binary code to execute via create operation
       */
      createBinary: (0, _reselectTree.createLeaf)(["./isCreate", state], (isCreate, { stack, memory }) => {
        if (!isCreate) {
          return null;
        }

        // Get the code that's going to be created from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 2], 16) * 2;
        const length = parseInt(stack[stack.length - 3], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callData
       *
       * data passed to EVM call
       */
      callData: (0, _reselectTree.createLeaf)(["./isCall", "./isShortCall", state], (isCall, short, { stack, memory }) => {
        if (!isCall) {
          return null;
        }

        //if it's 6-argument call, the data start and offset will be one spot
        //higher in the stack than they would be for a 7-argument call, so
        //let's introduce an offset to handle this
        let argOffset = short ? 1 : 0;

        // Get the data from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 4 + argOffset], 16) * 2;
        const length = parseInt(stack[stack.length - 5 + argOffset], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callValue
       *
       * value for the call (not create); returns null for DELEGATECALL
       */
      callValue: (0, _reselectTree.createLeaf)(["./isCall", "./isDelegateCallStrict", "./isStaticCall", state], (calls, delegates, isStatic, { stack }) => {
        if (!calls || delegates) {
          return null;
        }

        if (isStatic) {
          return new _bn2.default(0);
        }

        //otherwise, for CALL and CALLCODE, it's the 3rd argument
        let value = stack[stack.length - 3];
        return DecodeUtils.Conversion.toBN(value);
      }),

      /**
       * .createValue
       *
       * value for the create
       */
      createValue: (0, _reselectTree.createLeaf)(["./isCreate", state], (isCreate, { stack }) => {
        if (!isCreate) {
          return null;
        }

        //creates have the value as the first argument
        let value = stack[stack.length - 1];
        return DecodeUtils.Conversion.toBN(value);
      }),

      /**
       * .storageAffected
       *
       * storage slot being stored to or loaded from
       * we do NOT prepend "0x"
       */
      storageAffected: (0, _reselectTree.createLeaf)(["./touchesStorage", state], (touchesStorage, { stack }) => {
        if (!touchesStorage) {
          return null;
        }

        return stack[stack.length - 1];
      }),

      /*
       * .returnValue
       *
       * for a RETURN instruction, the value returned
       * we DO prepend "0x"
       * (will also return "0x" for STOP or SELFDESTRUCT but
       * null otherwise)
       */
      returnValue: (0, _reselectTree.createLeaf)(["./trace", "./isHalting", state], (step, isHalting, { stack, memory }) => {
        if (!isHalting) {
          return null;
        }
        if (step.op !== "RETURN") {
          //STOP and SELFDESTRUCT return empty value
          return "0x";
        }
        // Get the data from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 1], 16) * 2;
        const length = parseInt(stack[stack.length - 2], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      })
    });
  }

  return base;
}

const evm = (0, _reselectTree.createSelectorTree)({
  /**
   * evm.state
   */
  state: state => state.evm,

  /**
   * evm.info
   */
  info: {
    /**
     * evm.info.contexts
     */
    contexts: (0, _reselectTree.createLeaf)(["/state"], state => state.info.contexts.byContext),

    /**
     * evm.info.binaries
     */
    binaries: {
      /**
       * evm.info.binaries.search
       *
       * returns function (binary) => context (returns the *ID* of the context)
       * (returns null on no match)
       */
      search: (0, _reselectTree.createLeaf)(["/info/contexts"], contexts => binary => DecodeUtils.Contexts.findDebuggerContext(contexts, binary))
    }
  },

  /**
   * evm.transaction
   */
  transaction: {
    /*
     * evm.transaction.globals
     */
    globals: {
      /*
       * evm.transaction.globals.tx
       */
      tx: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction.globals.tx),
      /*
       * evm.transaction.globals.block
       */
      block: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction.globals.block)
    },

    /*
     * evm.transaction.status
     */
    status: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction.status),

    /*
     * evm.transaction.initialCall
     */
    initialCall: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction.initialCall)
  },

  /**
   * evm.current
   */
  current: {
    /**
     * evm.current.callstack
     */
    callstack: state => state.evm.proc.callstack,

    /**
     * evm.current.call
     */
    call: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.length ? stack[stack.length - 1] : {}),

    /**
     * evm.current.context
     */
    context: (0, _reselectTree.createLeaf)(["./call", "./codex/instances", "/info/binaries/search", "/info/contexts"], ({ address, binary }, instances, search, contexts) => {
      let contextId;
      if (address) {
        //if we're in a call to a deployed contract, we must have recorded
        //the context in the codex, so we don't need to do any further
        //searching
        ({ context: contextId, binary } = instances[address]);
      } else if (binary) {
        //otherwise, if we're in a constructor, we'll need to actually do a
        //search
        contextId = search(binary);
      } else {
        //exceptional case: no transaction is loaded
        return null;
      }

      if (contextId != undefined) {
        //if we found the context, use it
        let context = contexts[contextId];
        return (0, _extends3.default)({}, context, {
          binary
        });
      } else {
        //otherwise we'll construct something default
        return {
          binary,
          isConstructor: address === undefined
          //WARNING: we've mutated binary here, so
          //instead we go by whether address is undefined
        };
      }
    }),

    /**
     * evm.current.state
     *
     * evm state info: as of last operation, before op defined in step
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.step], step => step[param])
    }))),

    /**
     * evm.current.step
     */
    step: (0, _extends3.default)({}, createStepSelectors(_selectors2.default.step, "./state"), {

      //the following step selectors only exist for current, not next or any
      //other step

      /*
       * evm.current.step.createdAddress
       *
       * address created by the current create step
       */
      createdAddress: (0, _reselectTree.createLeaf)(["./isCreate", "/nextOfSameDepth/state/stack"], (isCreate, stack) => {
        if (!isCreate) {
          return null;
        }
        let address = stack[stack.length - 1];
        return DecodeUtils.Conversion.toAddress(address);
      }),

      /**
       * evm.current.step.callsPrecompileOrExternal
       *
       * are we calling a precompiled contract or an externally-owned account,
       * rather than a contract account that isn't precompiled?
       */
      callsPrecompileOrExternal: (0, _reselectTree.createLeaf)(["./isCall", "/current/state/depth", "/next/state/depth"], (calls, currentDepth, nextDepth) => calls && currentDepth === nextDepth),

      /**
       * evm.current.step.isContextChange
       * groups together calls, creates, halts, and exceptional halts
       */
      isContextChange: (0, _reselectTree.createLeaf)(["/current/state/depth", "/next/state/depth"], (currentDepth, nextDepth) => currentDepth !== nextDepth),

      /**
       * evm.current.step.isExceptionalHalting
       */
      isExceptionalHalting: (0, _reselectTree.createLeaf)(["./isHalting", "/current/state/depth", "/next/state/depth", "./returnStatus"], (halting, currentDepth, nextDepth, status) => halting ? !status //if deliberately halting, check the return status
      : nextDepth < currentDepth //if not on a deliberate halt, any halt
      //is an exceptional halt
      ),

      /**
       * evm.current.step.returnStatus
       * checks the return status of the *current* halting instruction (for
       * normal halts only)
       * (returns a boolean -- true for success, false for failure)
       */
      returnStatus: (0, _reselectTree.createLeaf)(["./isHalting", "/next/state", _selectors2.default.stepsRemaining, "/transaction/status"], (isHalting, { stack }, remaining, finalStatus) => {
        if (!isHalting) {
          return null; //not clear this'll do much good since this may get
          //read as false, but, oh well, may as well
        }
        if (remaining <= 1) {
          return finalStatus;
        } else {
          const ZERO_WORD = "00".repeat(DecodeUtils.EVM.WORD_SIZE);
          return stack[stack.length - 1] !== ZERO_WORD;
        }
      })
    }),

    /**
     * evm.current.codex (namespace)
     */
    codex: {
      /**
       * evm.current.codex (selector)
       * the whole codex! not that that's very much at the moment
       */
      _: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.codex),

      /**
       * evm.current.codex.storage
       * the current storage, as fetched from the codex... unless we're in a
       * failed creation call, then we just fall back on the state (which will
       * work, since nothing else can interfere with the storage of a failed
       * creation call!)
       */
      storage: (0, _reselectTree.createLeaf)(["./_", "../state/storage", "../call"], (codex, rawStorage, { storageAddress }) => storageAddress === DecodeUtils.EVM.ZERO_ADDRESS ? rawStorage //HACK -- if zero address ignore the codex
      : codex[codex.length - 1].accounts[storageAddress].storage),

      /*
       * evm.current.codex.instances
       */
      instances: (0, _reselectTree.createLeaf)(["./_"], codex => (0, _assign2.default)({}, ...(0, _entries2.default)(codex[codex.length - 1].accounts).map(([address, { code, context }]) => ({
        [address]: { address, binary: code, context }
      }))))
    }
  },

  /**
   * evm.next
   */
  next: {
    /**
     * evm.next.state
     *
     * evm state as a result of next step operation
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.next], step => step[param])
    }))),

    /*
     * evm.next.step
     */
    step: createStepSelectors(_selectors2.default.next, "./state")
  },

  /**
   * evm.nextOfSameDepth
   */
  nextOfSameDepth: {
    /**
     * evm.nextOfSameDepth.state
     *
     * evm state at the next step of same depth
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.nextOfSameDepth], step => step[param])
    })))
  }
});

exports.default = evm;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reselectTree = __webpack_require__(3);

const PAST_END_OF_TRACE = {
  depth: -1, //this is the part that matters!
  //the rest of this is just to look like a trace step
  error: "",
  gas: 0,
  memory: [],
  stack: [],
  storage: {},
  gasCost: 0,
  op: "STOP",
  pc: -1 //this is not at all valid but that's fine
};

let trace = (0, _reselectTree.createSelectorTree)({
  /**
   * trace.index
   *
   * current step index
   */
  index: state => state.trace.proc.index,

  /*
   * trace.loaded
   * is a trace loaded?
   */
  loaded: (0, _reselectTree.createLeaf)(["/steps"], steps => steps !== null),

  /**
   * trace.finished
   * is the trace finished?
   */
  finished: state => state.trace.proc.finished,

  /**
   * trace.finishedOrUnloaded
   *
   * is the trace finished, including if it's unloaded?
   */
  finishedOrUnloaded: (0, _reselectTree.createLeaf)(["/finished", "/loaded"], (finished, loaded) => finished || !loaded),

  /**
   * trace.steps
   *
   * all trace steps
   */
  steps: state => state.trace.transaction.steps,

  /**
   * trace.stepsRemaining
   *
   * number of steps remaining in trace
   */
  stepsRemaining: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps.length - index),

  /**
   * trace.step
   *
   * current trace step
   */
  step: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps ? steps[index] : null //null if no tx loaded
  ),

  /**
   * trace.next
   *
   * next trace step
   * HACK: if at the end,
   * we will return a spoofed "past end" step
   */
  next: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => index < steps.length - 1 ? steps[index + 1] : PAST_END_OF_TRACE),

  /*
   * trace.nextOfSameDepth
   * next trace step that's at the same depth as this one
   * NOTE: if there is none, will return undefined
   * (should not be used in such cases)
   */
  nextOfSameDepth: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => {
    let depth = steps[index].depth;
    return steps.slice(index + 1).find(step => step.depth === depth);
  })
});

exports.default = trace;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _solidityUtils = __webpack_require__(51);

var _solidityUtils2 = _interopRequireDefault(_solidityUtils);

var _codeUtils = __webpack_require__(52);

var _codeUtils2 = _interopRequireDefault(_codeUtils);

var _map = __webpack_require__(25);

var _jsonPointer = __webpack_require__(22);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(10);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:selectors");

function getSourceRange(instruction = {}) {
  return {
    start: instruction.start || 0,
    length: instruction.length || 0,
    lines: instruction.range || {
      start: {
        line: 0,
        column: 0
      },
      end: {
        line: 0,
        column: 0
      }
    }
  };
}

//function to create selectors that need both a current and next version
function createMultistepSelectors(stepSelector) {
  return {
    /**
     * .instruction
     */
    instruction: (0, _reselectTree.createLeaf)(["/current/instructionAtProgramCounter", stepSelector.programCounter],
    //HACK: we use solidity.current.instructionAtProgramCounter
    //even if we're looking at solidity.next.
    //This is harmless... so long as the current instruction isn't a context
    //change.  So, don't use solidity.next when it is.

    (map, pc) => map[pc] || {}),

    /**
     * .source
     */
    source: (0, _reselectTree.createLeaf)(["/info/sources", "./instruction"], (sources, { file: id }) => sources[id] || {}),

    /**
     * .sourceRange
     */
    sourceRange: (0, _reselectTree.createLeaf)(["./instruction"], getSourceRange),

    /**
     * .pointer
     */
    pointer: (0, _reselectTree.createLeaf)(["./source", "./sourceRange"], ({ ast }, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * .node
     */
    node: (0, _reselectTree.createLeaf)(["./source", "./pointer"], ({ ast }, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, ""))
  };
}

let solidity = (0, _reselectTree.createSelectorTree)({
  /**
   * solidity.state
   */
  state: state => state.solidity,

  /**
   * solidity.info
   */
  info: {
    /**
     * solidity.info.sources
     */
    sources: (0, _reselectTree.createLeaf)(["/state"], state => state.info.sources.byId)
  },

  /**
   * solidity.current
   */
  current: (0, _extends3.default)({
    /**
     * solidity.current.sourceMap
     */
    sourceMap: (0, _reselectTree.createLeaf)([_selectors2.default.current.context], context => context ? context.sourceMap : null //null when no tx loaded
    ),

    /**
     * solidity.current.functionDepthStack
     */
    functionDepthStack: state => state.solidity.proc.functionDepthStack,

    /**
     * solidity.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)(["./functionDepthStack"], stack => stack[stack.length - 1]),

    /**
     * solidity.current.instructions
     */
    instructions: (0, _reselectTree.createLeaf)(["/info/sources", _selectors2.default.current.context, "./sourceMap"], (sources, context, sourceMap) => {
      if (!context) {
        return [];
      }
      let binary = context.binary;
      if (!binary) {
        return [];
      }

      let numInstructions;
      if (sourceMap) {
        numInstructions = sourceMap.split(";").length;
      } else {
        //HACK
        numInstructions = (binary.length - 2) / 2;
        //this is actually an overestimate, but that's OK
      }

      //because we might be dealing with a constructor with arguments, we do
      //*not* remove metadata manually
      let instructions = _codeUtils2.default.parseCode(binary, numInstructions);

      if (!sourceMap) {
        // HACK
        // Let's create a source map to use since none exists. This source
        // map maps just as many ranges as there are instructions (or
        // possibly more), and marks them all as being Solidity-internal and
        // not jumps.
        sourceMap = binary !== "0x" ? "0:0:-1:-".concat(";".repeat(instructions.length - 1)) : "";
      }

      var lineAndColumnMappings = (0, _assign2.default)({}, ...(0, _entries2.default)(sources).map(([id, { source }]) => ({
        [id]: _solidityUtils2.default.getCharacterOffsetToLineAndColumnMapping(source || "")
      })));
      var humanReadableSourceMap = _solidityUtils2.default.getHumanReadableSourceMap(sourceMap);

      let primaryFile = humanReadableSourceMap[0].file;
      debug("primaryFile %o", primaryFile);

      return instructions.map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const sourceMap = humanReadableSourceMap[index] || {};

        return {
          instruction: (0, _extends3.default)({}, instruction, { index }),
          sourceMap
        };
      }).map(({ instruction, sourceMap }) => {
        // add source map information to instruction, or defaults
        //

        const {
          jump,
          start = 0,
          length = 0,
          file = primaryFile
        } = sourceMap;
        const lineAndColumnMapping = lineAndColumnMappings[file] || {};
        const range = {
          start: lineAndColumnMapping[start] || {
            line: null,
            column: null
          },
          end: lineAndColumnMapping[start + length] || {
            line: null,
            column: null
          }
        };

        if (range.start.line === null) {
          debug("sourceMap %o", sourceMap);
        }

        return (0, _extends3.default)({}, instruction, {

          jump,
          start,
          length,
          file,
          range
        });
      });
    }),

    /**
     * solidity.current.instructionAtProgramCounter
     */
    instructionAtProgramCounter: (0, _reselectTree.createLeaf)(["./instructions"], instructions => (0, _assign2.default)({}, ...instructions.map(instruction => ({
      [instruction.pc]: instruction
    }))))

  }, createMultistepSelectors(_selectors2.default.current.step), {

    /**
     * solidity.current.isSourceRangeFinal
     */
    isSourceRangeFinal: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter, _selectors2.default.next.step.programCounter], (map, current, next) => {
      if (!map[next]) {
        return true;
      }

      current = map[current];
      next = map[next];

      return current.start != next.start || current.length != next.length || current.file != next.file;
    }),

    /*
     * solidity.current.functionsByProgramCounter
     */
    functionsByProgramCounter: (0, _reselectTree.createLeaf)(["./instructions", "/info/sources"], (instructions, sources) => (0, _assign2.default)({}, ...instructions.filter(instruction => instruction.name === "JUMPDEST").filter(instruction => instruction.file !== -1)
    //note that the designated invalid function *does* have an associated
    //file, so it *is* safe to just filter out the ones that don't
    .map(instruction => {
      debug("instruction %O", instruction);
      let source = instruction.file;
      debug("source %O", sources[source]);
      let ast = sources[source].ast;
      let range = getSourceRange(instruction);
      let pointer = (0, _map.findRange)(ast, range.start, range.length);
      let node = pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, "");
      if (!node || node.nodeType !== "FunctionDefinition") {
        //filter out JUMPDESTs that aren't function definitions...
        //except for the designated invalid function
        let nextInstruction = instructions[instruction.index + 1] || {};
        if (nextInstruction.name === "INVALID") {
          //designated invalid, include it
          return {
            [instruction.pc]: {
              isDesignatedInvalid: true
            }
          };
        } else {
          //not designated invalid, filter it out
          return {};
        }
      }
      //otherwise, we're good to go, so let's find the contract node and
      //put it all together
      //to get the contract node, we go up twice from the function node;
      //the path from one to the other should have a very specific form,
      //so this is easy
      let contractPointer = pointer.replace(/\/nodes\/\d+$/, "");
      let contractNode = _jsonPointer2.default.get(ast, contractPointer);
      return {
        [instruction.pc]: {
          source,
          pointer,
          node,
          name: node.name,
          id: node.id,
          contractPointer,
          contractNode,
          contractName: contractNode.name,
          contractId: contractNode.id,
          contractKind: contractNode.contractKind,
          isDesignatedInvalid: false
        }
      };
    }))),

    /**
     * solidity.current.isMultiline
     */
    isMultiline: (0, _reselectTree.createLeaf)(["./sourceRange"], ({ lines }) => lines.start.line != lines.end.line),

    /**
     * solidity.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], isJump => isJump),

    /**
     * solidity.current.jumpDirection
     */
    jumpDirection: (0, _reselectTree.createLeaf)(["./instruction"], (i = {}) => i.jump || "-"),

    /**
     * solidity.current.willCall
     */
    willCall: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCall], x => x),

    /**
     * solidity.current.willCreate
     */
    willCreate: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCreate], x => x),

    /**
     * solidity.current.callsPrecompileOrExternal
     */
    callsPrecompileOrExternal: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.callsPrecompileOrExternal], x => x),

    /**
     * solidity.current.willReturn
     */
    willReturn: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isHalting], isHalting => isHalting),

    /**
     * solidity.current.willFail
     */
    willFail: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isExceptionalHalting], x => x),

    /*
     * solidity.current.nextMapped
     * returns the next trace step after this one which is sourcemapped
     * HACK: this assumes we're not about to change context! don't use this if
     * we are!
     * ALSO, this may return undefined, so be prepared for that
     */
    nextMapped: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors4.default.steps, _selectors4.default.index], (map, steps, index) => steps.slice(index + 1).find(({ pc }) => map[pc] && map[pc].file !== -1))
  }),

  /**
   * solidity.next
   * HACK WARNING: do not use these selectors when the current instruction is a
   * context change! (evm call or evm return)
   */
  next: createMultistepSelectors(_selectors2.default.next.step)
});

exports.default = solidity;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSteps = saveSteps;
exports.next = next;
exports.tick = tick;
exports.tock = tock;
exports.endTrace = endTrace;
exports.reset = reset;
exports.unloadTransaction = unloadTransaction;
exports.backtick = backtick;
const SAVE_STEPS = exports.SAVE_STEPS = "SAVE_STEPS";
function saveSteps(steps) {
  return {
    type: SAVE_STEPS,
    steps
  };
}

const NEXT = exports.NEXT = "NEXT";
function next() {
  return { type: NEXT };
}

const TICK = exports.TICK = "TICK";
function tick() {
  return { type: TICK };
}

const TOCK = exports.TOCK = "TOCK";
function tock() {
  return { type: TOCK };
}

const END_OF_TRACE = exports.END_OF_TRACE = "EOT";
function endTrace() {
  return { type: END_OF_TRACE };
}

const RESET = exports.RESET = "TRACE_RESET";
function reset() {
  return { type: RESET };
}

const UNLOAD_TRANSACTION = exports.UNLOAD_TRANSACTION = "TRACE_UNLOAD_TRANSACTION";
function unloadTransaction() {
  return { type: UNLOAD_TRANSACTION };
}

const BACKTICK = exports.BACKTICK = "BACKTICK";
function backtick() {
  return { type: BACKTICK };
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(28);

var _set2 = _interopRequireDefault(_set);

exports.advance = advance;
exports.signalTickSagaCompletion = signalTickSagaCompletion;
exports.processTrace = processTrace;
exports.reset = reset;
exports.unload = unload;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _actions = __webpack_require__(12);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:trace:sagas");

function* advance() {
  yield (0, _effects.put)(actions.next());

  debug("TOCK to take");
  yield (0, _effects.take)([actions.TOCK, actions.END_OF_TRACE]);
  debug("TOCK taken");
}

const SUBMODULE_COUNT = 3; //data, evm, solidity

function* next() {
  let remaining = yield (0, _effects.select)(_selectors2.default.stepsRemaining);
  debug("remaining: %o", remaining);
  let steps = yield (0, _effects.select)(_selectors2.default.steps);
  debug("total steps: %o", steps.length);
  let waitingForSubmodules = 0;

  if (remaining > 0) {
    debug("putting TICK");
    // updates state for current step
    waitingForSubmodules = SUBMODULE_COUNT;
    yield (0, _effects.put)(actions.tick());
    debug("put TICK");

    //wait for all backticks before continuing
    while (waitingForSubmodules > 0) {
      yield (0, _effects.take)(actions.BACKTICK);
      debug("got BACKTICK");
      waitingForSubmodules--;
    }

    remaining--; // local update, just for convenience
  }

  if (remaining) {
    debug("putting TOCK");
    // updates step to next step in trace
    yield (0, _effects.put)(actions.tock());
    debug("put TOCK");
  } else {
    debug("putting END_OF_TRACE");
    yield (0, _effects.put)(actions.endTrace());
    debug("put END_OF_TRACE");
  }
}

function* signalTickSagaCompletion() {
  yield (0, _effects.put)(actions.backtick());
}

function* processTrace(steps) {
  yield (0, _effects.put)(actions.saveSteps(steps));

  let addresses = [...new _set2.default(steps.map(({ op, stack }) => (0, _helpers.isCallMnemonic)(op) ? //if it's a call, just fetch the address off the stack
  DecodeUtils.Conversion.toAddress(stack[stack.length - 2]) : //if it's not a call, just return undefined (we've gone back to
  //skipping creates)
  undefined)
  //filter out zero addresses from failed creates (as well as undefineds)
  .filter(address => address !== undefined && address !== DecodeUtils.EVM.ZERO_ADDRESS))];

  return addresses;
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* unload() {
  yield (0, _effects.put)(actions.unloadTransaction());
}

function* saga() {
  yield (0, _effects.takeEvery)(actions.NEXT, next);
}

exports.default = (0, _helpers.prefixName)("trace", saga);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;
exports.loadTransaction = loadTransaction;
exports.interrupt = interrupt;
exports.unloadTransaction = unloadTransaction;
exports.ready = ready;
exports.wait = wait;
exports.error = error;
exports.clearError = clearError;
exports.recordContracts = recordContracts;
exports.saveTransaction = saveTransaction;
exports.saveReceipt = saveReceipt;
exports.saveBlock = saveBlock;
const START = exports.START = "SESSION_START";
function start(provider, txHash) {
  return {
    type: START,
    provider,
    txHash //OPTIONAL
  };
}

const LOAD_TRANSACTION = exports.LOAD_TRANSACTION = "LOAD_TRANSACTION";
function loadTransaction(txHash) {
  return {
    type: LOAD_TRANSACTION,
    txHash
  };
}

const INTERRUPT = exports.INTERRUPT = "SESSION_INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const UNLOAD_TRANSACTION = exports.UNLOAD_TRANSACTION = "UNLOAD_TRANSACTION";
function unloadTransaction() {
  return {
    type: UNLOAD_TRANSACTION
  };
}

const READY = exports.READY = "SESSION_READY";
function ready() {
  return {
    type: READY
  };
}

const WAIT = exports.WAIT = "SESSION_WAIT";
function wait() {
  return {
    type: WAIT
  };
}

const ERROR = exports.ERROR = "SESSION_ERROR";
function error(error) {
  return {
    type: ERROR,
    error
  };
}

const CLEAR_ERROR = exports.CLEAR_ERROR = "CLEAR_ERROR";
function clearError() {
  return {
    type: CLEAR_ERROR
  };
}

const RECORD_CONTRACTS = exports.RECORD_CONTRACTS = "RECORD_CONTRACTS";
function recordContracts(contexts, sources) {
  return {
    type: RECORD_CONTRACTS,
    contexts,
    sources
  };
}

const SAVE_TRANSACTION = exports.SAVE_TRANSACTION = "SAVE_TRANSACTION";
function saveTransaction(transaction) {
  return {
    type: SAVE_TRANSACTION,
    transaction
  };
}

const SAVE_RECEIPT = exports.SAVE_RECEIPT = "SAVE_RECEIPT";
function saveReceipt(receipt) {
  return {
    type: SAVE_RECEIPT,
    receipt
  };
}

const SAVE_BLOCK = exports.SAVE_BLOCK = "SAVE_BLOCK";
function saveBlock(block) {
  return {
    type: SAVE_BLOCK,
    block
  };
}

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("bn.js");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

exports.scope = scope;
exports.declare = declare;
exports.defineType = defineType;
exports.decode = decode;
exports.reset = reset;
exports.recordAllocations = recordAllocations;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(12);

var _actions2 = __webpack_require__(27);

var actions = _interopRequireWildcard(_actions2);

var _sagas = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(23);

var evm = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(30);

var web3 = _interopRequireWildcard(_sagas3);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _lodash = __webpack_require__(58);

var _lodash2 = _interopRequireDefault(_lodash);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _truffleDecoder = __webpack_require__(32);

var _bn = __webpack_require__(15);

var _bn2 = _interopRequireDefault(_bn);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:sagas");

function* scope(nodeId, pointer, parentId, sourceId) {
  yield (0, _effects.put)(actions.scope(nodeId, pointer, parentId, sourceId));
}

function* declare(node) {
  yield (0, _effects.put)(actions.declare(node));
}

function* defineType(node) {
  yield (0, _effects.put)(actions.defineType(node));
}

function* tickSaga() {
  debug("got TICK");

  yield* variablesAndMappingsSaga();
  debug("about to SUBTOCK");
  yield* trace.signalTickSagaCompletion();
}

function* decode(definition, ref) {
  let referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  let state = yield (0, _effects.select)(_selectors2.default.current.state);
  let mappingKeys = yield (0, _effects.select)(_selectors2.default.views.mappingKeys);
  let allocations = yield (0, _effects.select)(_selectors2.default.info.allocations);
  let instances = yield (0, _effects.select)(_selectors2.default.views.instances);
  let contexts = yield (0, _effects.select)(_selectors2.default.views.contexts);
  let currentContext = yield (0, _effects.select)(_selectors2.default.current.context);
  let internalFunctionsTable = yield (0, _effects.select)(_selectors2.default.current.functionsByProgramCounter);
  let blockNumber = yield (0, _effects.select)(_selectors2.default.views.blockNumber);

  let ZERO_WORD = new Uint8Array(DecodeUtils.EVM.WORD_SIZE);
  ZERO_WORD.fill(0);
  let NO_CODE = new Uint8Array(); //empty array

  let decoder = (0, _truffleDecoder.forEvmState)(definition, ref, {
    referenceDeclarations,
    state,
    mappingKeys,
    storageAllocations: allocations.storage,
    memoryAllocations: allocations.memory,
    calldataAllocations: allocations.calldata,
    contexts,
    currentContext,
    internalFunctionsTable
  });

  let result = decoder.next();
  while (!result.done) {
    let request = result.value;
    let response;
    switch (request.type) {
      case "storage":
        //the debugger supplies all storage it knows at the beginning.
        //any storage it does not know is presumed to be zero.
        response = ZERO_WORD;
        break;
      case "code":
        let address = request.address;
        if (address in instances) {
          response = instances[address];
        } else if (address === DecodeUtils.EVM.ZERO_ADDRESS) {
          //HACK: to avoid displaying the zero address to the user as an
          //affected address just because they decoded a contract or external
          //function variable that hadn't been initialized yet, we give the
          //zero address's codelessness its own private cache :P
          response = NO_CODE;
        } else {
          //I don't want to write a new web3 saga, so let's just use
          //obtainBinaries with a one-element array
          debug("fetching binary");
          let binary = (yield* web3.obtainBinaries([address], blockNumber))[0];
          debug("adding instance");
          yield* evm.addInstance(address, binary);
          response = DecodeUtils.Conversion.toBytes(binary);
        }
        break;
      default:
        debug("unrecognized request type!");
    }
    result = decoder.next(response);
  }
  //at this point, result.value holds the final value
  //note: we're still using the old decoder output format, so we need to clean
  //containers before returning something the debugger can use
  return DecodeUtils.Conversion.cleanContainers(result.value);
}

function* variablesAndMappingsSaga() {
  let node = yield (0, _effects.select)(_selectors2.default.current.node);
  let scopes = yield (0, _effects.select)(_selectors2.default.views.scopes.inlined);
  let referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  let allocations = yield (0, _effects.select)(_selectors2.default.info.allocations.storage);
  let currentAssignments = yield (0, _effects.select)(_selectors2.default.proc.assignments);
  let mappedPaths = yield (0, _effects.select)(_selectors2.default.proc.mappedPaths);
  let currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  let address = yield (0, _effects.select)(_selectors2.default.current.address);
  //storage address, not code address

  let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack); //note the use of next!
  //in this saga we are interested in the *results* of the current instruction
  //note that the decoder is still based on data.current.state; that's fine
  //though.  There's already a delay between when we record things off the
  //stack and when we decode them, after all.  Basically, nothing serious
  //should happen after an index node but before the index access node that
  //would cause storage, memory, or calldata to change, meaning that even if
  //the literal we recorded was a pointer, it will still be valid at the time
  //we use it.  (The other literals we make use of, for the base expressions,
  //are not decoded, so no potential mismatch there would be relevant anyway.)

  let alternateStack = yield (0, _effects.select)(_selectors2.default.nextMapped.state.stack);
  //HACK: unfortunately, in some cases, data.next.state.stack gets the wrong
  //results due to unmapped instructions intervening.  So, we get the stack at
  //the next *mapped* stack instead.  This is something of a hack and won't
  //work if we're about to change context, but it should work in the cases that
  //need it.

  if (!stack) {
    return;
  }

  let top = stack.length - 1;
  var assignment, assignments, preambleAssignments, baseExpression, slot, path;

  if (!node) {
    return;
  }

  // stack is only ready for interpretation after the last step of each
  // source range
  //
  // the data module always looks at the result of a particular opcode
  // (i.e., the following trace step's stack/memory/storage), so this
  // asserts that the _current_ operation is the final one before
  // proceeding
  if (!(yield (0, _effects.select)(_selectors2.default.views.atLastInstructionForSourceRange))) {
    return;
  }

  //HACK: modifier preamble
  //modifier definitions are typically skipped (this includes constructor
  //definitions when called as a base constructor); as such I've added this
  //"modifier preamble" to catch them
  if (yield (0, _effects.select)(_selectors2.default.current.aboutToModify)) {
    let modifier = yield (0, _effects.select)(_selectors2.default.current.modifierBeingInvoked);
    //may be either a modifier or base constructor
    let currentIndex = yield (0, _effects.select)(_selectors2.default.current.modifierArgumentIndex);
    debug("currentIndex %d", currentIndex);
    let parameters = modifier.parameters.parameters;
    //now: look at the parameters *after* the current index.  we'll need to
    //adjust for those.
    let parametersLeft = parameters.slice(currentIndex + 1);
    let adjustment = (0, _lodash2.default)(parametersLeft.map(DecodeUtils.Definition.stackSize));
    debug("adjustment %d", adjustment);
    preambleAssignments = assignParameters(parameters, top + adjustment, currentDepth);
  } else {
    preambleAssignments = {};
  }

  switch (node.nodeType) {
    case "FunctionDefinition":
    case "ModifierDefinition":
      //NOTE: this will *not* catch most modifier definitions!
      //the rest hopefully will be caught by the modifier preamble
      //(in fact they won't all be, but...)

      //HACK: filter out some garbage
      //this filters out the case where we're really in an invocation of a
      //modifier or base constructor, but have temporarily hit the definition
      //node for some reason.  However this obviously can have a false positive
      //in the case where a function has the same modifier twice.
      let nextModifier = yield (0, _effects.select)(_selectors2.default.next.modifierBeingInvoked);
      if (nextModifier && nextModifier.id === node.id) {
        break;
      }

      let parameters = node.parameters.parameters;
      //note that we do *not* include return parameters, since those are
      //handled by the VariableDeclaration case (no, I don't know why it
      //works out that way)

      //we can skip preambleAssignments here, that isn't used in this case
      assignments = assignParameters(parameters, top, currentDepth);

      debug("Function definition case");
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "ContractDefinition":
      let allocation = allocations[node.id];

      debug("Contract definition case");
      debug("allocations %O", allocations);
      debug("allocation %O", allocation);
      assignments = {};
      for (let id in allocation.members) {
        id = Number(id); //not sure why we're getting them as strings, but...
        let idObj = { astId: id, address };
        let fullId = (0, _helpers.stableKeccak256)(idObj);
        //we don't use makeAssignment here as we had to compute the ID anyway
        assignment = (0, _extends3.default)({}, idObj, {
          id: fullId,
          ref: (0, _extends3.default)({}, (currentAssignments.byId[fullId] || {}).ref || {}, allocation.members[id].pointer)
        });
        assignments[fullId] = assignment;
      }
      debug("assignments %O", assignments);

      //this case doesn't need preambleAssignments either
      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "FunctionTypeName":
      //HACK
      //for some reasons, for declarations of local variables of function type,
      //we land on the FunctionTypeName instead of the VariableDeclaration,
      //so we replace the node with its parent (the VariableDeclaration)
      node = scopes[scopes[node.id].parentId].definition;
      //let's do a quick check that it *is* a VariableDeclaration before
      //continuing
      if (node.nodeType !== "VariableDeclaration") {
        break;
      }
    //otherwise, deliberately fall through to the VariableDeclaration case
    //NOTE: DELIBERATE FALL-THROUGH
    case "VariableDeclaration":
      let varId = node.id;
      debug("Variable declaration case");
      debug("currentDepth %d varId %d", currentDepth, varId);

      //NOTE: We're going to make the assignment conditional here; here's why.
      //There's a bug where calling the autogenerated accessor for a public
      //contract variable causes the debugger to see two additional
      //declarations for that variable... which this code reads as local
      //variable declarations.  Rather than prevent this at the source, we're
      //just going to check for it here, by not adding a local variable if said
      //variable is already a contract variable.

      if (currentAssignments.byAstId[varId] !== undefined && currentAssignments.byAstId[varId].some(id => currentAssignments.byId[id].address !== undefined)) {
        debug("already a contract variable!");
        break;
      }

      //otherwise, go ahead and make the assignment
      assignment = (0, _helpers.makeAssignment)({ astId: varId, stackframe: currentDepth }, {
        stack: {
          from: top - DecodeUtils.Definition.stackSize(node) + 1,
          to: top
        }
      });
      assignments = { [assignment.id]: assignment };
      //this case doesn't need preambleAssignments either
      debug("assignments: %O", assignments);
      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "IndexAccess":
      // to track `mapping` types known indices
      // (and also *some* known indices for arrays)

      //HACK: we use the alternate stack in this case

      debug("Index access case");

      //we're going to start by doing the same thing as in the default case
      //(see below) -- getting things ready for an assignment.  Then we're
      //going to forget this for a bit while we handle the rest...
      assignments = (0, _extends3.default)({}, preambleAssignments, literalAssignments(node, alternateStack, currentDepth));

      //we'll need this
      baseExpression = node.baseExpression;

      //but first, a diversion -- is this something that could not *possibly*
      //lead to a mapping?  i.e., either a bytes, or an array of non-reference
      //types, or a non-storage array?
      //if so, we'll just do the assign and quit out early
      //(note: we write it this way because mappings aren't caught by
      //isReference)
      if (DecodeUtils.Definition.typeClass(baseExpression) === "bytes" || DecodeUtils.Definition.typeClass(baseExpression) === "array" && (DecodeUtils.Definition.isReference(node) ? DecodeUtils.Definition.referenceType(baseExpression) !== "storage" : !DecodeUtils.Definition.isMapping(node))) {
        debug("Index case bailed out early");
        debug("typeClass %s", DecodeUtils.Definition.typeClass(baseExpression));
        debug("referenceType %s", DecodeUtils.Definition.referenceType(baseExpression));
        debug("isReference(node) %o", DecodeUtils.Definition.isReference(node));
        yield (0, _effects.put)(actions.assign(assignments));
        break;
      }

      let keyDefinition = DecodeUtils.Definition.keyDefinition(baseExpression, scopes);
      //if we're dealing with an array, this will just spoof up a uint definition
      //:)

      //now... the decoding! (this is messy)
      let indexValue = yield* decodeMappingKeySaga(node.indexExpression, keyDefinition);

      debug("index value %O", indexValue);
      debug("keyDefinition %o", keyDefinition);

      //whew! But we're not done yet -- we need to turn this decoded key into
      //an actual path (assuming we *did* decode it)
      //OK, not an actual path -- we're just going to use a simple offset for
      //the path.  But that's OK, because the mappedPaths reducer will turn
      //it into an actual path.
      if (indexValue != null) {
        path = fetchBasePath(baseExpression, mappedPaths, currentAssignments, currentDepth);

        let slot = { path };

        //we need to do things differently depending on whether we're dealing
        //with an array or mapping
        switch (DecodeUtils.Definition.typeClass(baseExpression)) {
          case "array":
            slot.hashPath = DecodeUtils.Definition.isDynamicArray(baseExpression);
            slot.offset = indexValue.muln((0, _truffleDecoder.storageSize)(node, referenceDeclarations, allocations).words);
            break;
          case "mapping":
            slot.key = indexValue;
            slot.keyEncoding = DecodeUtils.Definition.keyEncoding(keyDefinition);
            slot.offset = new _bn2.default(0);
            break;
          default:
            debug("unrecognized index access!");
        }
        debug("slot %O", slot);

        //now, map it! (and do the assign as well)
        yield (0, _effects.put)(actions.mapPathAndAssign(address, slot, assignments, DecodeUtils.Definition.typeIdentifier(node), DecodeUtils.Definition.typeIdentifier(baseExpression)));
      } else {
        //if we failed to decode, just do the assign from above
        debug("failed to decode, just assigning");
        yield (0, _effects.put)(actions.assign(assignments));
      }

      break;

    case "MemberAccess":
      //HACK: we use the alternate stack in this case

      //we're going to start by doing the same thing as in the default case
      //(see below) -- getting things ready for an assignment.  Then we're
      //going to forget this for a bit while we handle the rest...
      assignments = (0, _extends3.default)({}, preambleAssignments, literalAssignments(node, alternateStack, currentDepth));

      debug("Member access case");

      //MemberAccess uses expression, not baseExpression
      baseExpression = node.expression;

      //if this isn't a storage struct, or the element isn't of reference type,
      //we'll just do the assignment and quit out (again, note that mappings
      //aren't caught by isReference)
      if (DecodeUtils.Definition.typeClass(baseExpression) !== "struct" || (DecodeUtils.Definition.isReference(node) ? DecodeUtils.Definition.referenceType(baseExpression) !== "storage" : !DecodeUtils.Definition.isMapping(node))) {
        debug("Member case bailed out early");
        yield (0, _effects.put)(actions.assign(assignments));
        break;
      }

      //but if it is a storage struct, we have to map the path as well
      path = fetchBasePath(baseExpression, mappedPaths, currentAssignments, currentDepth);

      slot = { path };

      let structId = DecodeUtils.Definition.typeId(baseExpression);
      let memberAllocation = allocations[structId].members[node.referencedDeclaration];

      slot.offset = memberAllocation.pointer.storage.from.slot.offset.clone();

      debug("slot %o", slot);
      yield (0, _effects.put)(actions.mapPathAndAssign(address, slot, assignments, DecodeUtils.Definition.typeIdentifier(node), DecodeUtils.Definition.typeIdentifier(baseExpression)));

    default:
      if (node.typeDescriptions == undefined) {
        break;
      }

      debug("decoding expression value %O", node.typeDescriptions);
      debug("default case");
      debug("currentDepth %d node.id %d", currentDepth, node.id);

      assignments = (0, _extends3.default)({}, preambleAssignments, literalAssignments(node, stack, currentDepth));
      yield (0, _effects.put)(actions.assign(assignments));
      break;
  }
}

function* decodeMappingKeySaga(indexDefinition, keyDefinition) {
  let scopes = yield (0, _effects.select)(_selectors2.default.views.scopes.inlined);
  let currentAssignments = yield (0, _effects.select)(_selectors2.default.proc.assignments);
  let currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);

  //why the loop? see the end of the block it heads for an explanatory
  //comment
  while (true) {
    let indexId = indexDefinition.id;
    //indices need to be identified by stackframe
    let indexIdObj = { astId: indexId, stackframe: currentDepth };
    let fullIndexId = (0, _helpers.stableKeccak256)(indexIdObj);

    const indexReference = (currentAssignments.byId[fullIndexId] || {}).ref;

    if (DecodeUtils.Definition.isSimpleConstant(indexDefinition)) {
      //while the main case is the next one, where we look for a prior
      //assignment, we need this case (and need it first) for two reasons:
      //1. some constant expressions (specifically, string and hex literals)
      //aren't sourcemapped to and so won't have a prior assignment
      //2. if the key type is bytesN but the expression is constant, the
      //value will go on the stack *left*-padded instead of right-padded,
      //so looking for a prior assignment will read the wrong value.
      //so instead it's preferable to use the constant directly.
      debug("about to decode simple literal");
      return yield* decode(keyDefinition, {
        definition: indexDefinition
      });
    } else if (indexReference) {
      //if a prior assignment is found
      let splicedDefinition;
      //in general, we want to decode using the key definition, not the index
      //definition. however, the key definition may have the wrong location
      //on it.  so, when applicable, we splice the index definition location
      //onto the key definition location.
      if (DecodeUtils.Definition.isReference(indexDefinition)) {
        splicedDefinition = DecodeUtils.Definition.spliceLocation(keyDefinition, DecodeUtils.Definition.referenceType(indexDefinition));
        //we could put code here to add on the "_ptr" ending when absent,
        //but we presently ignore that ending, so we'll skip that
      } else {
        splicedDefinition = keyDefinition;
      }
      debug("about to decode");
      return yield* decode(splicedDefinition, indexReference);
    } else if (indexDefinition.referencedDeclaration && scopes[indexDefinition.referencedDeclaration]) {
      //there's one more reason we might have failed to decode it: it might be a
      //constant state variable.  Unfortunately, we don't know how to decode all
      //those at the moment, but we can handle the ones we do know how to decode.
      //In the future hopefully we will decode all of them
      debug("referencedDeclaration %d", indexDefinition.referencedDeclaration);
      let indexConstantDeclaration = scopes[indexDefinition.referencedDeclaration].definition;
      debug("indexConstantDeclaration %O", indexConstantDeclaration);
      if (indexConstantDeclaration.constant) {
        let indexConstantDefinition = indexConstantDeclaration.value;
        //next line filters out constants we don't know how to handle
        if (DecodeUtils.Definition.isSimpleConstant(indexConstantDefinition)) {
          debug("about to decode simple constant");
          return yield* decode(keyDefinition, {
            definition: indexConstantDeclaration.value
          });
        } else {
          return null; //can't decode; see below for more explanation
        }
      } else {
        return null; //can't decode; see below for more explanation
      }
    }
    //there's still one more reason we might have failed to decode it:
    //certain (silent) type conversions aren't sourcemapped either.
    //(thankfully, any type conversion that actually *does* something seems
    //to be sourcemapped.)  So if we've failed to decode it, we try again
    //with the argument of the type conversion, if it is one; we leave
    //indexValue undefined so the loop will continue
    //(note that this case is last for a reason; if this were earlier, it
    //would catch *non*-silent type conversions, which we want to just read
    //off the stack)
    else if (indexDefinition.kind === "typeConversion") {
        indexDefinition = indexDefinition.arguments[0];
      }
      //...also prior to 0.5.0, unary + was legal, which needs to be accounted
      //for for the same reason
      else if (indexDefinition.nodeType === "UnaryOperation" && indexDefinition.operator === "+") {
          indexDefinition = indexDefinition.subExpression;
        }
        //otherwise, we've just totally failed to decode it, so we mark
        //indexValue as null (as distinct from undefined) to indicate this.  In
        //the future, we should be able to decode all mapping keys, but we're
        //not quite there yet, sorry (because we can't yet handle all constant
        //state variables)
        else {
            return null;
          }
    //now, as mentioned, retry in the typeConversion case
    //(or unary + case)
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* recordAllocations() {
  const contracts = yield (0, _effects.select)(_selectors2.default.views.userDefinedTypes.contractDefinitions);
  debug("contracts %O", contracts);
  const referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  debug("referenceDeclarations %O", referenceDeclarations);
  const storageAllocations = (0, _truffleDecoder.getStorageAllocations)(referenceDeclarations, contracts);
  debug("storageAllocations %O", storageAllocations);
  const memoryAllocations = (0, _truffleDecoder.getMemoryAllocations)(referenceDeclarations);
  const calldataAllocations = (0, _truffleDecoder.getCalldataAllocations)(referenceDeclarations);
  yield (0, _effects.put)(actions.allocate(storageAllocations, memoryAllocations, calldataAllocations));
}

function literalAssignments(node, stack, currentDepth) {
  let top = stack.length - 1;

  let literal = (0, _truffleDecoder.readStack)(stack, top - DecodeUtils.Definition.stackSize(node) + 1, top);

  let assignment = (0, _helpers.makeAssignment)({ astId: node.id, stackframe: currentDepth }, { literal });

  return { [assignment.id]: assignment };
}

//takes a parameter list as given in the AST
function assignParameters(parameters, top, functionDepth) {
  let reverseParameters = parameters.slice().reverse();
  //reverse is in-place, so we use slice() to clone first
  debug("reverseParameters %o", parameters);

  let currentPosition = top;
  let assignments = {};

  for (let parameter of reverseParameters) {
    let words = DecodeUtils.Definition.stackSize(parameter);
    let pointer = {
      stack: {
        from: currentPosition - words + 1,
        to: currentPosition
      }
    };
    let assignment = (0, _helpers.makeAssignment)({ astId: parameter.id, stackframe: functionDepth }, pointer);
    assignments[assignment.id] = assignment;
    currentPosition -= words;
  }
  return assignments;
}

function fetchBasePath(baseNode, mappedPaths, currentAssignments, currentDepth) {
  let fullId = (0, _helpers.stableKeccak256)({
    astId: baseNode.id,
    stackframe: currentDepth
  });
  debug("astId: %d", baseNode.id);
  debug("stackframe: %d", currentDepth);
  debug("fullId: %s", fullId);
  debug("currentAssignments: %O", currentAssignments);
  //base expression is an expression, and so has a literal assigned to
  //it
  let offset = DecodeUtils.Conversion.toBN(currentAssignments.byId[fullId].ref.literal);
  return { offset };
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("data", saga);

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.advance = advance;
exports.stepNext = stepNext;
exports.stepOver = stepOver;
exports.stepInto = stepInto;
exports.stepOut = stepOut;
exports.reset = reset;
exports.interrupt = interrupt;
exports.continueUntilBreakpoint = continueUntilBreakpoint;
exports.addBreakpoint = addBreakpoint;
exports.removeBreakpoint = removeBreakpoint;
exports.removeAllBreakpoints = removeAllBreakpoints;
exports.startStepping = startStepping;
exports.doneStepping = doneStepping;
const ADVANCE = exports.ADVANCE = "ADVANCE";
function advance(count) {
  return { type: ADVANCE, count };
}

const STEP_NEXT = exports.STEP_NEXT = "STEP_NEXT";
function stepNext() {
  return { type: STEP_NEXT };
}

const STEP_OVER = exports.STEP_OVER = "STEP_OVER";
function stepOver() {
  return { type: STEP_OVER };
}

const STEP_INTO = exports.STEP_INTO = "STEP_INTO";
function stepInto() {
  return { type: STEP_INTO };
}

const STEP_OUT = exports.STEP_OUT = "STEP_OUT";
function stepOut() {
  return { type: STEP_OUT };
}

const RESET = exports.RESET = "RESET";
function reset() {
  return { type: RESET };
}

const INTERRUPT = exports.INTERRUPT = "CONTROLLER_INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const CONTINUE = exports.CONTINUE = "CONTINUE";
function continueUntilBreakpoint(breakpoints) {
  //"continue" is not a legal name
  return {
    type: CONTINUE,
    breakpoints
  };
}

const ADD_BREAKPOINT = exports.ADD_BREAKPOINT = "ADD_BREAKPOINT";
function addBreakpoint(breakpoint) {
  return {
    type: ADD_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_BREAKPOINT = exports.REMOVE_BREAKPOINT = "REMOVE_BREAKPOINT";
function removeBreakpoint(breakpoint) {
  return {
    type: REMOVE_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_ALL_BREAKPOINTS = exports.REMOVE_ALL_BREAKPOINTS = "REMOVE_ALL_BREAKPOINTS";
function removeAllBreakpoints() {
  return {
    type: REMOVE_ALL_BREAKPOINTS
  };
}

const START_STEPPING = exports.START_STEPPING = "START_STEPPING";
function startStepping() {
  return {
    type: START_STEPPING
  };
}

const DONE_STEPPING = exports.DONE_STEPPING = "DONE_STEPPING";
function doneStepping() {
  return {
    type: DONE_STEPPING
  };
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__(19);

var _values2 = _interopRequireDefault(_values);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _jsonPointer = __webpack_require__(22);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(11);

var _selectors4 = _interopRequireDefault(_selectors3);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:selectors");

/**
 * @private
 */
const identity = x => x;

function findAncestorOfType(node, types, scopes) {
  //note: I'm not including any protection against null in this function.
  //You are advised to include "SourceUnit" as a fallback type.
  while (node && !types.includes(node.nodeType)) {
    node = scopes[scopes[node.id].parentId].definition;
  }
  return node;
}

//given a modifier invocation (or inheritance specifier) node,
//get the node for the actual modifier (or constructor)
function modifierForInvocation(invocation, scopes) {
  let rawId; //raw referencedDeclaration ID extracted from the AST.
  //if it's a modifier this is what we want, but if it's base
  //constructor, we'll get the contract instead, and need to find its
  //constructor.
  switch (invocation.nodeType) {
    case "ModifierInvocation":
      rawId = invocation.modifierName.referencedDeclaration;
      break;
    case "InheritanceSpecifier":
      rawId = invocation.baseName.referencedDeclaration;
      break;
    default:
      debug("bad invocation node");
  }
  let rawNode = scopes[rawId].definition;
  switch (rawNode.nodeType) {
    case "ModifierDefinition":
      return rawNode;
    case "ContractDefinition":
      return rawNode.nodes.find(node => node.nodeType === "FunctionDefinition" && DecodeUtils.Definition.functionKind(node) === "constructor");
    default:
      //we should never hit this case
      return undefined;
  }
}

//see data.views.contexts for an explanation
function debuggerContextToDecoderContext(context) {
  let {
    contractName,
    binary,
    contractId,
    contractKind,
    isConstructor,
    abi
  } = context;
  return {
    contractName,
    binary,
    contractId,
    contractKind,
    isConstructor,
    abi: DecodeUtils.Contexts.abiToFunctionAbiWithSignatures(abi)
  };
}

const data = (0, _reselectTree.createSelectorTree)({
  state: state => state.data,

  /**
   * data.views
   */
  views: {
    /*
     * data.views.atLastInstructionForSourceRange
     */
    atLastInstructionForSourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.isSourceRangeFinal], final => final),

    /**
     * data.views.scopes (namespace)
     */
    scopes: {
      /**
       * data.views.scopes.inlined (namespace)
       */
      inlined: {
        /**
         * data.views.scopes.inlined (selector)
         * see data.info.scopes for how this differs from the raw version
         */
        _: (0, _reselectTree.createLeaf)(["/info/scopes", "./raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(inlined).map(([id, info]) => {
          let newInfo = (0, _extends3.default)({}, info);
          newInfo.variables = scopes[id].variables;
          return { [id]: newInfo };
        }))),

        /**
         * data.views.scopes.inlined.raw
         */
        raw: (0, _reselectTree.createLeaf)(["/info/scopes/raw", _selectors4.default.info.sources], (scopes, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, entry]) => ({
          [id]: (0, _extends3.default)({}, entry, {

            definition: _jsonPointer2.default.get(sources[entry.sourceId].ast, entry.pointer)
          })
        }))))
      }
    },

    /*
     * data.views.userDefinedTypes
     */
    userDefinedTypes: {
      /*
       * data.views.userDefinedTypes.contractDefinitions
       * restrict to contracts only, and get their definitions
       */
      contractDefinitions: (0, _reselectTree.createLeaf)(["/info/userDefinedTypes", "/views/scopes/inlined"], (typeIds, scopes) => typeIds.map(id => scopes[id].definition).filter(node => node.nodeType === "ContractDefinition"))
    },

    /*
     * data.views.referenceDeclarations
     */
    referenceDeclarations: (0, _reselectTree.createLeaf)(["./scopes/inlined", "/info/userDefinedTypes"], (scopes, userDefinedTypes) => (0, _assign2.default)({}, ...userDefinedTypes.map(id => ({ [id]: scopes[id].definition })))),

    /**
     * data.views.mappingKeys
     */
    mappingKeys: (0, _reselectTree.createLeaf)(["/proc/mappedPaths", "/current/address"], (mappedPaths, address) => [].concat(...(0, _values2.default)((mappedPaths.byAddress[address] || { byType: {} }).byType).map(({ bySlotAddress }) => (0, _values2.default)(bySlotAddress))).filter(slot => slot.key !== undefined)),

    /*
     * data.views.blockNumber
     * returns block number as string
     */
    blockNumber: (0, _reselectTree.createLeaf)([_selectors2.default.transaction.globals.block], block => block.number.toString()),

    /*
     * data.views.instances
     * same as evm.current.codex.instances, but we just map address => binary,
     * we don't bother with context, and also the code is a Uint8Array
     */
    instances: (0, _reselectTree.createLeaf)([_selectors2.default.current.codex.instances], instances => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { binary }]) => ({
      [address]: DecodeUtils.Conversion.toBytes(binary)
    })))),

    /*
     * data.views.contexts
     * same as evm.info.contexts, but:
     * 0. we only include non-constructor contexts
     * 1. we now index by contract ID rather than hash
     * 2. we strip out context, sourceMap, primarySource, and compiler
     * 3. we alter abi in several ways:
     * 3a. we strip abi down to just (ordinary) functions
     * 3b. we augment these functions with signatures (here meaning selectors)
     * 3c. abi is now an object, not an array, and indexed by these signatures
     */
    contexts: (0, _reselectTree.createLeaf)([_selectors2.default.info.contexts], contexts => (0, _assign2.default)({}, ...(0, _values2.default)(contexts).filter(context => !context.isConstructor).map(context => ({
      [context.contractId]: debuggerContextToDecoderContext(context)
    }))))
  },

  /**
   * data.info
   */
  info: {
    /**
     * data.info.scopes (namespace)
     */
    scopes: {
      /**
       * data.info.scopes (selector)
       * the raw version is below; this version accounts for inheritance
       * NOTE: doesn't this selector really belong in data.views?  Yes.
       * But, since it's replacing the old data.info.scopes (which is now
       * data.info.scopes.raw), I didn't want to move it.
       */
      _: (0, _reselectTree.createLeaf)(["./raw", "/views/scopes/inlined/raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, scope]) => {
        let definition = inlined[id].definition;
        if (definition.nodeType !== "ContractDefinition") {
          return { [id]: scope };
        }
        //if we've reached this point, we should be dealing with a
        //contract, and specifically a contract -- not an interface or
        //library (those don't get "variables" entries in their scopes)
        debug("contract id %d", id);
        let newScope = (0, _extends3.default)({}, scope);
        //note that Solidity gives us the linearization in order from most
        //derived to most base, but we want most base to most derived;
        //annoyingly, reverse() is in-place, so we clone with slice() first
        let linearizedBaseContractsFromBase = definition.linearizedBaseContracts.slice().reverse();
        //now, we put it all together
        newScope.variables = [].concat(...linearizedBaseContractsFromBase.map(contractId => scopes[contractId].variables || []
        //we need the || [] because contracts with no state variables
        //have variables undefined rather than empty like you'd expect
        )).filter(variable => {
          //...except, HACK, let's filter out those constants we don't know
          //how to read.  they'll just clutter things up.
          debug("variable %O", variable);
          let definition = inlined[variable.id].definition;
          return !definition.constant || DecodeUtils.Definition.isSimpleConstant(definition.value);
        });

        return { [id]: newScope };
      }))),

      /*
       * data.info.scopes.raw
       */
      raw: (0, _reselectTree.createLeaf)(["/state"], state => state.info.scopes.byId)
    },

    /*
     * data.info.allocations
     */
    allocations: {
      /*
       * data.info.allocations.storage
       */
      storage: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.storage),

      /*
       * data.info.allocations.memory
       */
      memory: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.memory),

      /*
       * data.info.allocations.calldata
       */
      calldata: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.calldata)
    },

    /**
     * data.info.userDefinedTypes
     */
    userDefinedTypes: (0, _reselectTree.createLeaf)(["/state"], state => state.info.userDefinedTypes)
  },

  /**
   * data.proc
   */
  proc: {
    /**
     * data.proc.assignments
     */
    assignments: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.assignments
    //note: this no longer fetches just the byId, but rather the whole
    //assignments object
    ),

    /*
     * data.proc.mappedPaths
     */
    mappedPaths: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.mappedPaths),

    /**
     * data.proc.decodingKeys
     *
     * number of keys that are still decoding
     */
    decodingKeys: (0, _reselectTree.createLeaf)(["./mappedPaths"], mappedPaths => mappedPaths.decodingStarted)
  },

  /**
   * data.current
   */
  current: {
    /**
     * data.current.state
     */
    state: {
      /**
       * data.current.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors2.default.current.state.stack], words => (words || []).map(word => DecodeUtils.Conversion.toBytes(word))),

      /**
       * data.current.state.memory
       */
      memory: (0, _reselectTree.createLeaf)([_selectors2.default.current.state.memory], words => DecodeUtils.Conversion.toBytes(words.join(""))),

      /**
       * data.current.state.calldata
       */
      calldata: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], ({ data }) => DecodeUtils.Conversion.toBytes(data)),

      /**
       * data.current.state.storage
       */
      storage: (0, _reselectTree.createLeaf)([_selectors2.default.current.codex.storage], mapping => (0, _assign2.default)({}, ...(0, _entries2.default)(mapping).map(([address, word]) => ({
        [`0x${address}`]: DecodeUtils.Conversion.toBytes(word)
      })))),

      /*
       * data.current.state.specials
       * I've named these after the solidity variables they correspond to,
       * which are *mostly* the same as the corresponding EVM opcodes
       * (FWIW: this = ADDRESS, sender = CALLER, value = CALLVALUE)
       */
      specials: (0, _reselectTree.createLeaf)(["/current/address", _selectors2.default.current.call, _selectors2.default.transaction.globals], (address, { sender, value }, { tx, block }) => (0, _extends3.default)({
        this: DecodeUtils.Conversion.toBytes(address),

        sender: DecodeUtils.Conversion.toBytes(sender),

        value: DecodeUtils.Conversion.toBytes(value)

      }, (0, _assign2.default)({}, ...(0, _entries2.default)(tx).map(([variable, value]) => ({
        [variable]: DecodeUtils.Conversion.toBytes(value)
      }))), (0, _assign2.default)({}, ...(0, _entries2.default)(block).map(([variable, value]) => ({
        [variable]: DecodeUtils.Conversion.toBytes(value)
      })))))
    },

    /**
     * data.current.node
     */
    node: (0, _reselectTree.createLeaf)([_selectors4.default.current.node], identity),

    /**
     * data.current.scope
     * old alias for data.current.node (deprecated)
     */
    scope: (0, _reselectTree.createLeaf)(["./node"], identity),

    /*
     * data.current.contract
     * warning: may return null or similar, even though SourceUnit is included
     * as fallback
     */
    contract: (0, _reselectTree.createLeaf)(["./node", "/views/scopes/inlined"], (node, scopes) => {
      const types = ["ContractDefinition", "SourceUnit"];
      //SourceUnit included as fallback
      return findAncestorOfType(node, types, scopes);
    }),

    /**
     * data.current.functionDepth
     */

    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * data.current.address
     * NOTE: this is the STORAGE address for the current call, not the CODE
     * address
     */

    address: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], call => call.storageAddress),

    /*
     * data.current.functionsByProgramCounter
     */
    functionsByProgramCounter: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionsByProgramCounter], functions => functions),

    /*
     * data.current.context
     */
    context: (0, _reselectTree.createLeaf)([_selectors2.default.current.context], debuggerContextToDecoderContext),

    /*
     * data.current.aboutToModify
     * HACK
     * This selector is used to catch those times when we go straight from a
     * modifier invocation into the modifier itself, skipping over the
     * definition node (this includes base constructor calls).  So it should
     * return true when:
     * 1. we're on the node corresponding to an argument to a modifier
     * invocation or base constructor call, or, if said argument is a type
     * conversion, its argument (or nested argument)
     * 2. the next node is not a FunctionDefinition, ModifierDefinition, or
     * in the same modifier / base constructor invocation
     */
    aboutToModify: (0, _reselectTree.createLeaf)(["./node", "./modifierInvocation", "./modifierArgumentIndex", "/next/node", "/next/modifierInvocation", _selectors2.default.current.step.isContextChange], (node, invocation, index, next, nextInvocation, isContextChange) => {
      //ensure: current instruction is not a context change (because if it is
      //we cannot rely on the data.next selectors, but also if it is we know
      //we're not about to call a modifier or base constructor!)
      //we also want to return false if we can't find things for whatever
      //reason
      if (isContextChange || !node || !next || !invocation || !nextInvocation) {
        return false;
      }

      //ensure: current position is in a ModifierInvocation or
      //InheritanceSpecifier (recall that SourceUnit was included as
      //fallback)
      if (invocation.nodeType === "SourceUnit") {
        return false;
      }

      //ensure: next node is not a function definition or modifier definition
      if (next.nodeType === "FunctionDefinition" || next.nodeType === "ModifierDefinition") {
        return false;
      }

      //ensure: next node is not in the same invocation
      if (nextInvocation.nodeType !== "SourceUnit" && nextInvocation.id === invocation.id) {
        return false;
      }

      //now: are we on the node corresponding to an argument, or, if
      //it's a type conversion, its nested argument?
      if (index === undefined) {
        return false;
      }
      let argument = invocation.arguments[index];
      while (argument.kind === "typeConversion") {
        if (node.id === argument.id) {
          return true;
        }
        argument = argument.arguments[0];
      }
      return node.id === argument.id;
    }),

    /*
     * data.current.modifierInvocation
     */
    modifierInvocation: (0, _reselectTree.createLeaf)(["./node", "/views/scopes/inlined"], (node, scopes) => {
      const types = ["ModifierInvocation", "InheritanceSpecifier", "SourceUnit"];
      //again, SourceUnit included as fallback
      return findAncestorOfType(node, types, scopes);
    }),

    /**
     * data.current.modifierArgumentIndex
     * gets the index of the current modifier argument that you're in
     * (undefined when not in a modifier argument)
     */
    modifierArgumentIndex: (0, _reselectTree.createLeaf)(["/info/scopes", "./node", "./modifierInvocation"], (scopes, node, invocation) => {
      if (invocation.nodeType === "SourceUnit") {
        return undefined;
      }

      let pointer = scopes[node.id].pointer;
      let invocationPointer = scopes[invocation.id].pointer;

      //slice the invocation pointer off the beginning
      let difference = pointer.replace(invocationPointer, "");
      debug("difference %s", difference);
      let rawIndex = difference.match(/^\/arguments\/(\d+)/);
      //note that that \d+ is greedy
      debug("rawIndex %o", rawIndex);
      if (rawIndex === null) {
        return undefined;
      }
      return parseInt(rawIndex[1]);
    }),

    /*
     * data.current.modifierBeingInvoked
     * gets the node corresponding to the modifier or base constructor
     * being invoked
     */
    modifierBeingInvoked: (0, _reselectTree.createLeaf)(["./modifierInvocation", "/views/scopes/inlined"], (invocation, scopes) => {
      if (!invocation || invocation.nodeType === "SourceUnit") {
        return undefined;
      }

      return modifierForInvocation(invocation, scopes);
    }),

    /**
     * data.current.identifiers (namespace)
     */
    identifiers: {
      /**
       * data.current.identifiers (selector)
       *
       * returns identifers and corresponding definition node ID or builtin name
       * (object entries look like [name]: {astId: id} or like [name]: {builtin: name}
       */
      _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/node"], (scopes, scope) => {
        let variables = {};
        if (scope !== undefined) {
          let cur = scope.id;

          do {
            variables = (0, _assign2.default)(variables, ...(scopes[cur].variables || []).filter(v => v.name !== "") //exclude anonymous output params
            .filter(v => variables[v.name] == undefined).map(v => ({ [v.name]: { astId: v.id } })));

            cur = scopes[cur].parentId;
          } while (cur != null);
        }

        let builtins = {
          msg: { builtin: "msg" },
          tx: { builtin: "tx" },
          block: { builtin: "block" },
          this: { builtin: "this" },
          now: { builtin: "now" }
        };

        return (0, _extends3.default)({}, variables, builtins);
      }),

      /**
       * data.current.identifiers.definitions (namespace)
       */
      definitions: {
        /* data.current.identifiers.definitions (selector)
         * definitions for current variables, by identifier
         */
        _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "../_", "./this"], (scopes, identifiers, thisDefinition) => {
          let variables = (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, { astId }]) => {
            if (astId !== undefined) {
              //will be undefined for builtins
              let { definition } = scopes[astId];
              return { [identifier]: definition };
            } else {
              return {}; //skip over builtins; we'll handle those separately
            }
          }));
          let builtins = {
            msg: DecodeUtils.Definition.MSG_DEFINITION,
            tx: DecodeUtils.Definition.TX_DEFINITION,
            block: DecodeUtils.Definition.BLOCK_DEFINITION,
            now: DecodeUtils.Definition.spoofUintDefinition("now")
          };
          //only include this when it has a proper definition
          if (thisDefinition) {
            builtins.this = thisDefinition;
          }
          return (0, _extends3.default)({}, variables, builtins);
        }),

        /*
         * data.current.identifiers.definitions.this
         *
         * returns a spoofed definition for the this variable
         */
        this: (0, _reselectTree.createLeaf)(["/current/contract"], contractNode => contractNode && contractNode.nodeType === "ContractDefinition" ? DecodeUtils.Definition.spoofThisDefinition(contractNode.name, contractNode.id) : null)
      },

      /**
       * data.current.identifiers.refs
       *
       * current variables' value refs
       */
      refs: (0, _reselectTree.createLeaf)(["/proc/assignments", "./_", "/current/functionDepth", //for pruning things too deep on stack
      "/current/address" //for contract variables
      ], (assignments, identifiers, currentDepth, address) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, { astId, builtin }]) => {
        let id;

        //is this an ordinary variable or a builtin?
        if (astId !== undefined) {
          //if not a builtin, first check if it's a contract var
          let matchIds = (assignments.byAstId[astId] || []).filter(idHash => assignments.byId[idHash].address === address);
          if (matchIds.length > 0) {
            id = matchIds[0]; //there should only be one!
          }

          //if not contract, it's local, so find the innermost
          //(but not beyond current depth)
          if (id === undefined) {
            let matchFrames = (assignments.byAstId[astId] || []).map(id => assignments.byId[id].stackframe).filter(stackframe => stackframe !== undefined);

            if (matchFrames.length > 0) {
              //this check isn't *really*
              //necessary, but may as well prevent stupid stuff
              let maxMatch = Math.min(currentDepth, Math.max(...matchFrames));
              id = (0, _helpers.stableKeccak256)({ astId, stackframe: maxMatch });
            }
          }
        } else {
          //otherwise, it's a builtin
          //NOTE: for now we assume there is only one assignment per
          //builtin, but this will change in the future
          id = assignments.byBuiltin[builtin][0];
        }

        //if we still didn't find it, oh well

        let { ref } = assignments.byId[id] || {};
        if (!ref) {
          return undefined;
        }

        return {
          [identifier]: ref
        };
      })))
    }
  },

  /**
   * data.next
   */
  next: {
    /**
     * data.next.state
     * Yes, I'm just repeating the code for data.current.state.stack here;
     * not worth the trouble to factor out
     */
    state: {
      /**
       * data.next.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors2.default.next.state.stack], words => (words || []).map(word => DecodeUtils.Conversion.toBytes(word)))
    },

    //HACK WARNING
    //the following selectors depend on solidity.next
    //do not use them when the current instruction is a context change!

    /**
     * data.next.node
     */
    node: (0, _reselectTree.createLeaf)([_selectors4.default.next.node], identity),

    /**
     * data.next.modifierInvocation
     * Note: yes, I'm just repeating the code from data.current here but with
     * invalid added
     */
    modifierInvocation: (0, _reselectTree.createLeaf)(["./node", "/views/scopes/inlined", _selectors2.default.current.step.isContextChange], (node, scopes, invalid) => {
      //don't attempt this at a context change!
      //(also don't attempt this if we can't find the node for whatever
      //reason)
      if (invalid || !node) {
        return undefined;
      }
      const types = ["ModifierInvocation", "InheritanceSpecifier", "SourceUnit"];
      //again, SourceUnit included as fallback
      return findAncestorOfType(node, types, scopes);
    }),

    /*
     * data.next.modifierBeingInvoked
     */
    modifierBeingInvoked: (0, _reselectTree.createLeaf)(["./modifierInvocation", "/views/scopes/inlined", _selectors2.default.current.step.isContextChange], (invocation, scopes, invalid) => {
      if (invalid || !invocation || invocation.nodeType === "SourceUnit") {
        return undefined;
      }

      return modifierForInvocation(invocation, scopes);
    })
    //END HACK WARNING
  },

  /**
   * data.nextMapped
   */
  nextMapped: {
    /**
     * data.nextMapped.state
     * Yes, I'm just repeating the code for data.current.state.stack here;
     * not worth the trouble to factor out
     * HACK: this assumes we're not about to change context! don't use this if we
     * are!
     */
    state: {
      /**
       * data.nextMapped.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors4.default.current.nextMapped], step => ((step || {}).stack || []).map(word => DecodeUtils.Conversion.toBytes(word)))
    }
  }
});

exports.default = data;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.normalizeContexts = normalizeContexts;
exports.addInstance = addInstance;
exports.begin = begin;
exports.callstackAndCodexSaga = callstackAndCodexSaga;
exports.reset = reset;
exports.unload = unload;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(12);

var _actions2 = __webpack_require__(29);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _sagas = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:sagas");

/**
 * Adds EVM bytecode context
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addContext(context) {
  const contextHash = (0, _helpers.keccak256)({ type: "string", value: context.binary });
  //NOTE: we take hash as *string*, not as bytes, because the binary may
  //contain link references!

  debug("context %O", context);
  yield (0, _effects.put)(actions.addContext(context));

  return contextHash;
}

function* normalizeContexts() {
  yield (0, _effects.put)(actions.normalizeContexts());
}

/**
 * Adds known deployed instance of binary at address
 *
 * @param {string} binary - may be undefined (e.g. precompiles)
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addInstance(address, binary) {
  let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
  let context = search(binary);

  //now, whether we needed a new context or not, add the instance
  yield (0, _effects.put)(actions.addInstance(address, context, binary));

  return context;
}

function* begin({
  address,
  binary,
  data,
  storageAddress,
  status,
  sender,
  value,
  gasprice,
  block
}) {
  yield (0, _effects.put)(actions.saveGlobals(sender, gasprice, block));
  yield (0, _effects.put)(actions.saveStatus(status));
  debug("codex: %O", (yield (0, _effects.select)(_selectors2.default.current.codex)));
  if (address) {
    yield (0, _effects.put)(actions.call(address, data, storageAddress, sender, value));
  } else {
    yield (0, _effects.put)(actions.create(binary, storageAddress, sender, value));
  }
}

function* tickSaga() {
  debug("got TICK");

  yield* callstackAndCodexSaga();
  yield* trace.signalTickSagaCompletion();
}

function* callstackAndCodexSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.step.isExceptionalHalting)) {
    //let's handle this case first so we can be sure everything else is *not*
    //an exceptional halt
    debug("exceptional halt!");

    yield (0, _effects.put)(actions.fail());
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCall)) {
    debug("got call");
    // if there is no binary (e.g. in the case of precompiled contracts or
    // externally owned accounts), then there will be no trace steps for the
    // called code, and so we shouldn't tell the debugger that we're entering
    // another execution context
    if (yield (0, _effects.select)(_selectors2.default.current.step.callsPrecompileOrExternal)) {
      return;
    }

    let address = yield (0, _effects.select)(_selectors2.default.current.step.callAddress);
    let data = yield (0, _effects.select)(_selectors2.default.current.step.callData);

    debug("calling address %s", address);

    if (yield (0, _effects.select)(_selectors2.default.current.step.isDelegateCallStrict)) {
      //if delegating, leave storageAddress, sender, and value the same
      let { storageAddress, sender, value } = yield (0, _effects.select)(_selectors2.default.current.call);
      yield (0, _effects.put)(actions.call(address, data, storageAddress, sender, value));
    } else {
      //this branch covers CALL, CALLCODE, and STATICCALL
      let currentCall = yield (0, _effects.select)(_selectors2.default.current.call);
      let storageAddress = (yield (0, _effects.select)(_selectors2.default.current.step.isDelegateCallBroad)) ? currentCall.storageAddress //for CALLCODE
      : address;
      let sender = currentCall.storageAddress; //not the code address!
      let value = yield (0, _effects.select)(_selectors2.default.current.step.callValue); //0 if static
      yield (0, _effects.put)(actions.call(address, data, storageAddress, sender, value));
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCreate)) {
    debug("got create");
    let binary = yield (0, _effects.select)(_selectors2.default.current.step.createBinary);
    let createdAddress = yield (0, _effects.select)(_selectors2.default.current.step.createdAddress);
    let value = yield (0, _effects.select)(_selectors2.default.current.step.createValue);
    let sender = (yield (0, _effects.select)(_selectors2.default.current.call)).storageAddress;
    //not the code address!

    yield (0, _effects.put)(actions.create(binary, createdAddress, sender, value));
    //as above, storageAddress handles when calling from a creation call
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isHalting)) {
    debug("got return");

    let { binary, storageAddress } = yield (0, _effects.select)(_selectors2.default.current.call);

    if (binary) {
      //if we're returning from a successful creation call, let's log the
      //result
      let returnedBinary = yield (0, _effects.select)(_selectors2.default.current.step.returnValue);
      let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
      let returnedContext = search(returnedBinary);
      yield (0, _effects.put)(actions.returnCreate(storageAddress, returnedBinary, returnedContext));
    } else {
      yield (0, _effects.put)(actions.returnCall());
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.touchesStorage)) {
    let storageAddress = (yield (0, _effects.select)(_selectors2.default.current.call)).storageAddress;
    let slot = yield (0, _effects.select)(_selectors2.default.current.step.storageAffected);
    //note we get next storage, since we're updating to that
    let storage = yield (0, _effects.select)(_selectors2.default.next.state.storage);
    //normally we'd need a 0 fallback for this next line, but in this case we
    //can be sure the value will be there, since we're touching that storage
    if (yield (0, _effects.select)(_selectors2.default.current.step.isStore)) {
      yield (0, _effects.put)(actions.store(storageAddress, slot, storage[slot]));
    } else {
      //otherwise, it's a load
      yield (0, _effects.put)(actions.load(storageAddress, slot, storage[slot]));
    }
  }
}

function* reset() {
  let initialCall = yield (0, _effects.select)(_selectors2.default.transaction.initialCall);
  yield (0, _effects.put)(actions.reset());
  yield (0, _effects.put)(initialCall);
}

function* unload() {
  yield (0, _effects.put)(actions.unloadTransaction());
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("evm", saga);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(11);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(10);

var _selectors6 = _interopRequireDefault(_selectors5);

var _map = __webpack_require__(25);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:selectors"); //eslint-disable-line no-unused-vars

/**
 * @private
 */
const identity = x => x;

/**
 * controller
 */
const controller = (0, _reselectTree.createSelectorTree)({
  /**
   * controller.state
   */
  state: state => state.controller,
  /**
   * controller.current
   */
  current: {
    /**
     * controller.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * controller.current.executionContext
     */
    executionContext: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], identity),

    /**
     * controller.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], identity),

    /**
     * controller.current.location
     */
    location: {
      /**
       * controller.current.location.sourceRange
       */
      sourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.sourceRange, "/current/trace/loaded"], (range, loaded) => loaded ? range : null),

      /**
       * controller.current.location.source
       */
      source: (0, _reselectTree.createLeaf)([_selectors4.default.current.source, "/current/trace/loaded"], (source, loaded) => loaded ? source : null),

      /**
       * controller.current.location.node
       */
      node: (0, _reselectTree.createLeaf)([_selectors4.default.current.node, "/current/trace/loaded"], (node, loaded) => loaded ? node : null),

      /**
       * controller.current.location.isMultiline
       */
      isMultiline: (0, _reselectTree.createLeaf)([_selectors4.default.current.isMultiline, "/current/trace/loaded"], (raw, loaded) => loaded ? raw : false)
    },

    /*
     * controller.current.trace
     */
    trace: {
      /**
       * controller.current.trace.finished
       */
      finished: (0, _reselectTree.createLeaf)([_selectors6.default.finished], identity),

      /**
       * controller.current.trace.loaded
       */
      loaded: (0, _reselectTree.createLeaf)([_selectors6.default.loaded], identity)
    }
  },

  /**
   * controller.breakpoints (namespace)
   */
  breakpoints: {
    /**
     * controller.breakpoints (selector)
     */
    _: (0, _reselectTree.createLeaf)(["/state"], state => state.breakpoints),

    /**
     * controller.breakpoints.resolver (selector)
     * this selector returns a function that adjusts a given line-based
     * breakpoint (on node-based breakpoints it simply returns the input) by
     * repeatedly moving it down a line until it lands on a line where there's
     * actually somewhere to break.  if no such line exists beyond that point, it
     * returns null instead.
     */
    resolver: (0, _reselectTree.createLeaf)([_selectors4.default.info.sources], sources => breakpoint => {
      let adjustedBreakpoint;
      if (breakpoint.node === undefined) {
        let line = breakpoint.line;
        let { source, ast } = sources[breakpoint.sourceId];
        let lineLengths = source.split("\n").map(line => line.length);
        //why does neither JS nor lodash have a scan function like Haskell??
        //guess we'll have to do our scan manually
        let lineStarts = [0];
        for (let length of lineLengths) {
          lineStarts.push(lineStarts[lineStarts.length - 1] + length + 1);
          //+1 for the /n itself
        }
        debug("line: %s", source.slice(lineStarts[line], lineStarts[line] + lineLengths[line]));
        while (line < lineLengths.length && !(0, _map.anyNonSkippedInRange)(ast, lineStarts[line], lineLengths[line])) {
          debug("incrementing");
          line++;
        }
        if (line >= lineLengths.length) {
          adjustedBreakpoint = null;
        } else {
          adjustedBreakpoint = (0, _extends3.default)({}, breakpoint, { line });
        }
      } else {
        debug("node-based breakpoint");
        adjustedBreakpoint = breakpoint;
      }
      return adjustedBreakpoint;
    })
  },

  /**
   * controller.finished
   * deprecated alias for controller.current.trace.finished
   */
  finished: (0, _reselectTree.createLeaf)(["/current/finished"], finished => finished),

  /**
   * controller.isStepping
   */
  isStepping: (0, _reselectTree.createLeaf)(["./state"], state => state.isStepping)
});

exports.default = controller;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

exports.getRange = getRange;
exports.rangeNodes = rangeNodes;
exports.findOverlappingRange = findOverlappingRange;
exports.findRange = findRange;
exports.anyNonSkippedInRange = anyNonSkippedInRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _nodeIntervalTree = __webpack_require__(53);

var _nodeIntervalTree2 = _interopRequireDefault(_nodeIntervalTree);

var _jsonPointer = __webpack_require__(22);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:map");

/**
 * @private
 */
function getRange(node) {
  // src: "<start>:<length>:<_>"
  // returns [start, end]
  let [start, length] = node.src.split(":").slice(0, 2).map(i => parseInt(i));

  return [start, start + length];
}

/**
 * @private
 */
function rangeNodes(node, pointer = "") {
  if (node instanceof Array) {
    return [].concat(...node.map((sub, i) => rangeNodes(sub, `${pointer}/${i}`)));
  } else if (node instanceof Object) {
    let results = [];

    if (node.src !== undefined && node.id !== undefined) {
      //there are some "pseudo-nodes" with a src but no id.
      //these will cause problems, so we want to exclude them.
      //(to my knowledge this only happens with the externalReferences
      //to an InlineAssembly node, so excluding them just means we find
      //the InlineAssembly node instead, which is fine)
      results.push({ pointer, range: getRange(node) });
    }

    return results.concat(...(0, _keys2.default)(node).map(key => rangeNodes(node[key], `${pointer}/${key}`)));
  } else {
    return [];
  }
}

/**
 * @private
 */
function findOverlappingRange(node, sourceStart, sourceLength) {
  let ranges = rangeNodes(node);
  let tree = new _nodeIntervalTree2.default();

  for (let _ref of ranges) {
    let { range, pointer } = _ref;

    let [start, end] = range;
    tree.insert(start, end, { range, pointer });
  }

  let sourceEnd = sourceStart + sourceLength;

  return tree.search(sourceStart, sourceEnd);
  //returns everything overlapping the given range
}

/**
 * @private
 */
function findRange(node, sourceStart, sourceLength) {
  // find nodes that fully contain requested range,
  // return longest pointer
  let sourceEnd = sourceStart + sourceLength;
  return findOverlappingRange(node, sourceStart, sourceLength).filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1]).map(({ pointer }) => pointer).reduce((a, b) => a.length > b.length ? a : b, "");
}

/**
 * @private
 */
function anyNonSkippedInRange(node, sourceStart, sourceLength) {
  let sourceEnd = sourceStart + sourceLength;
  return findOverlappingRange(node, sourceStart, sourceLength).some(({ range, pointer }) => sourceStart <= range[0] && //we want to go by starting line
  range[0] < sourceEnd && !(0, _helpers.isSkippedNodeType)(_jsonPointer2.default.get(node, pointer))
  //NOTE: this doesn't actually catch everything skipped!  But doing better
  //is hard
  );
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(10);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(11);

var _selectors6 = _interopRequireDefault(_selectors5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:selectors");

const session = (0, _reselectTree.createSelectorTree)({
  /*
   * session.state
   */
  state: state => state.session,

  /**
   * session.info
   */
  info: {
    /**
     * session.info.affectedInstances
     */
    affectedInstances: (0, _reselectTree.createLeaf)([_selectors2.default.current.codex.instances, _selectors2.default.info.contexts, _selectors6.default.info.sources], (instances, contexts, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { context: contextId, binary }]) => {
      debug("instances %O", instances);
      debug("contexts %O", contexts);
      let context = contexts[contextId];
      if (!context) {
        return { [address]: { binary } };
      }
      let { contractName, primarySource } = context;

      let source = primarySource !== undefined ? sources[primarySource] : undefined;

      return {
        [address]: {
          contractName,
          source,
          binary
        }
      };
    })))
  },

  /**
   * session.transaction (namespace)
   */
  transaction: {
    /**
     * session.transaction (selector)
     * contains the web3 transaction object
     */
    _: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction),

    /**
     * session.transaction.receipt
     * contains the web3 receipt object
     */
    receipt: (0, _reselectTree.createLeaf)(["/state"], state => state.receipt),

    /**
     * session.transaction.block
     * contains the web3 block object
     */
    block: (0, _reselectTree.createLeaf)(["/state"], state => state.block)
  },

  /*
   * session.status (namespace)
   */
  status: {
    /*
     * session.status.readyOrError
     */
    readyOrError: (0, _reselectTree.createLeaf)(["/state"], state => state.ready),

    /*
     * session.status.ready
     */
    ready: (0, _reselectTree.createLeaf)(["./readyOrError", "./isError"], (readyOrError, error) => readyOrError && !error),

    /*
     * session.status.waiting
     */
    waiting: (0, _reselectTree.createLeaf)(["/state"], state => !state.ready),

    /*
     * session.status.error
     */
    error: (0, _reselectTree.createLeaf)(["/state"], state => state.lastLoadingError),

    /*
     * session.status.isError
     */
    isError: (0, _reselectTree.createLeaf)(["./error"], error => error !== null),

    /*
     * session.status.success
     */
    success: (0, _reselectTree.createLeaf)(["./error"], error => error === null),

    /*
     * session.status.errored
     */
    errored: (0, _reselectTree.createLeaf)(["./readyOrError", "./isError"], (readyOrError, error) => readyOrError && error),

    /*
     * session.status.loaded
     */
    loaded: (0, _reselectTree.createLeaf)([_selectors4.default.loaded], loaded => loaded),

    /*
     * session.status.projectInfoComputed
     */
    projectInfoComputed: (0, _reselectTree.createLeaf)(["/state"], state => state.projectInfoComputed)
  }
});

exports.default = session;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scope = scope;
exports.declare = declare;
exports.assign = assign;
exports.mapPathAndAssign = mapPathAndAssign;
exports.reset = reset;
exports.defineType = defineType;
exports.allocate = allocate;
const SCOPE = exports.SCOPE = "SCOPE";
function scope(id, pointer, parentId, sourceId) {
  return {
    type: SCOPE,
    id,
    pointer,
    parentId,
    sourceId
  };
}

const DECLARE = exports.DECLARE = "DECLARE_VARIABLE";
function declare(node) {
  return {
    type: DECLARE,
    node
  };
}

const ASSIGN = exports.ASSIGN = "ASSIGN";
function assign(assignments) {
  return {
    type: ASSIGN,
    assignments
  };
}

const MAP_PATH_AND_ASSIGN = exports.MAP_PATH_AND_ASSIGN = "MAP_PATH_AND_ASSIGN";
function mapPathAndAssign(address, slot, assignments, typeIdentifier, parentType) {
  return {
    type: MAP_PATH_AND_ASSIGN,
    address,
    slot,
    assignments,
    typeIdentifier,
    parentType
  };
}

const RESET = exports.RESET = "DATA_RESET";
function reset() {
  return { type: RESET };
}

const DEFINE_TYPE = exports.DEFINE_TYPE = "DEFINE_TYPE";
function defineType(node) {
  return {
    type: DEFINE_TYPE,
    node
  };
}

const ALLOCATE = exports.ALLOCATE = "ALLOCATE";
function allocate(storage, memory, calldata) {
  return {
    type: ALLOCATE,
    storage,
    memory,
    calldata
  };
}

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.normalizeContexts = normalizeContexts;
exports.addInstance = addInstance;
exports.saveGlobals = saveGlobals;
exports.saveStatus = saveStatus;
exports.call = call;
exports.create = create;
exports.returnCall = returnCall;
exports.returnCreate = returnCreate;
exports.fail = fail;
exports.store = store;
exports.load = load;
exports.reset = reset;
exports.unloadTransaction = unloadTransaction;
const ADD_CONTEXT = exports.ADD_CONTEXT = "EVM_ADD_CONTEXT";
function addContext({
  contractName,
  binary,
  sourceMap,
  compiler,
  abi,
  contractId,
  contractKind,
  isConstructor
}) {
  return {
    type: ADD_CONTEXT,
    contractName,
    binary,
    sourceMap,
    compiler,
    abi,
    contractId,
    contractKind,
    isConstructor
  };
}

const NORMALIZE_CONTEXTS = exports.NORMALIZE_CONTEXTS = "EVM_NORMALIZE_CONTEXTS";
function normalizeContexts() {
  return { type: NORMALIZE_CONTEXTS };
}

const ADD_INSTANCE = exports.ADD_INSTANCE = "EVM_ADD_INSTANCE";
function addInstance(address, context, binary) {
  return {
    type: ADD_INSTANCE,
    address,
    context,
    binary
  };
}

const SAVE_GLOBALS = exports.SAVE_GLOBALS = "SAVE_GLOBALS";
function saveGlobals(origin, gasprice, block) {
  return {
    type: SAVE_GLOBALS,
    origin,
    gasprice,
    block
  };
}

const SAVE_STATUS = exports.SAVE_STATUS = "SAVE_STATUS";
function saveStatus(status) {
  return {
    type: SAVE_STATUS,
    status
  };
}

const CALL = exports.CALL = "CALL";
function call(address, data, storageAddress, sender, value) {
  return {
    type: CALL,
    address,
    data,
    storageAddress,
    sender,
    value
  };
}

const CREATE = exports.CREATE = "CREATE";
function create(binary, storageAddress, sender, value) {
  return {
    type: CREATE,
    binary,
    storageAddress,
    sender,
    value
  };
}

const RETURN_CALL = exports.RETURN_CALL = "RETURN_CALL";
function returnCall() {
  return {
    type: RETURN_CALL
  };
}

const RETURN_CREATE = exports.RETURN_CREATE = "RETURN_CREATE";
function returnCreate(address, code, context) {
  return {
    type: RETURN_CREATE,
    address,
    code,
    context
  };
}

const FAIL = exports.FAIL = "FAIL";
function fail() {
  return {
    type: FAIL
  };
}

const STORE = exports.STORE = "STORE";
function store(address, slot, value) {
  return {
    type: STORE,
    address,
    slot,
    value
  };
}

const LOAD = exports.LOAD = "LOAD";
function load(address, slot, value) {
  return {
    type: LOAD,
    address,
    slot,
    value
  };
}

const RESET = exports.RESET = "EVM_RESET";
function reset(storageAddress) {
  return {
    type: RESET,
    storageAddress
  };
}

const UNLOAD_TRANSACTION = exports.UNLOAD_TRANSACTION = "EVM_UNLOAD_TRANSACTION";
function unloadTransaction() {
  return {
    type: UNLOAD_TRANSACTION
  };
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inspectTransaction = inspectTransaction;
exports.obtainBinaries = obtainBinaries;
exports.init = init;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(55);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(14);

var session = _interopRequireWildcard(_actions2);

var _bn = __webpack_require__(15);

var _bn2 = _interopRequireDefault(_bn);

var _web = __webpack_require__(31);

var _web2 = _interopRequireDefault(_web);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _adapter = __webpack_require__(56);

var _adapter2 = _interopRequireDefault(_adapter);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:sagas"); //just for utils!


function* fetchTransactionInfo(adapter, { txHash }) {
  debug("inspecting transaction");
  var trace;
  try {
    trace = yield (0, _effects.apply)(adapter, adapter.getTrace, [txHash]);
  } catch (e) {
    debug("putting error");
    yield (0, _effects.put)(actions.error(e));
    return;
  }

  debug("got trace");
  yield (0, _effects.put)(actions.receiveTrace(trace));

  let tx = yield (0, _effects.apply)(adapter, adapter.getTransaction, [txHash]);
  debug("tx %O", tx);
  let receipt = yield (0, _effects.apply)(adapter, adapter.getReceipt, [txHash]);
  debug("receipt %O", receipt);
  let block = yield (0, _effects.apply)(adapter, adapter.getBlock, [tx.blockNumber]);
  debug("block %O", block);

  yield (0, _effects.put)(session.saveTransaction(tx));
  yield (0, _effects.put)(session.saveReceipt(receipt));
  yield (0, _effects.put)(session.saveBlock(block));

  //these ones get grouped together for convenience
  let solidityBlock = {
    coinbase: block.miner,
    difficulty: new _bn2.default(block.difficulty),
    gaslimit: new _bn2.default(block.gasLimit),
    number: new _bn2.default(block.number),
    timestamp: new _bn2.default(block.timestamp)
  };

  if (tx.to != null) {
    yield (0, _effects.put)(actions.receiveCall({
      address: tx.to,
      data: tx.input,
      storageAddress: tx.to,
      status: receipt.status,
      sender: tx.from,
      value: new _bn2.default(tx.value),
      gasprice: new _bn2.default(tx.gasPrice),
      block: solidityBlock
    }));
  } else {
    let storageAddress = _web2.default.utils.isAddress(receipt.contractAddress) ? receipt.contractAddress : DecodeUtils.EVM.ZERO_ADDRESS;
    yield (0, _effects.put)(actions.receiveCall({
      binary: tx.input,
      storageAddress,
      status: receipt.status,
      sender: tx.from,
      value: new _bn2.default(tx.value),
      gasprice: new _bn2.default(tx.gasPrice),
      block: solidityBlock
    }));
  }
}

function* fetchBinary(adapter, { address, block }) {
  debug("fetching binary for %s", address);
  let binary = yield (0, _effects.apply)(adapter, adapter.getDeployedCode, [address, block]);

  debug("received binary for %s", address);
  yield (0, _effects.put)(actions.receiveBinary(address, binary));
}

function* inspectTransaction(txHash) {
  yield (0, _effects.put)(actions.inspect(txHash));

  let action = yield (0, _effects.take)([actions.RECEIVE_TRACE, actions.ERROR_WEB3]);
  debug("action %o", action);

  var trace;
  if (action.type == actions.RECEIVE_TRACE) {
    trace = action.trace;
    debug("received trace");
  } else {
    return { error: action.error };
  }

  let {
    address,
    binary,
    data,
    storageAddress,
    status,
    sender,
    value,
    gasprice,
    block
  } = yield (0, _effects.take)(actions.RECEIVE_CALL);
  debug("received call");

  return {
    trace,
    address,
    binary,
    data,
    storageAddress,
    status,
    sender,
    value,
    gasprice,
    block
  };
}

//NOTE: the block argument is optional
function* obtainBinaries(addresses, block) {
  let tasks = yield (0, _effects.all)(addresses.map(address => (0, _effects.fork)(receiveBinary, address)));

  debug("requesting binaries");
  yield (0, _effects.all)(addresses.map(address => (0, _effects.put)(actions.fetchBinary(address, block))));

  let binaries = [];
  binaries = yield (0, _effects.join)(tasks);

  debug("binaries %o", binaries);

  return binaries;
}

function* receiveBinary(address) {
  let { binary } = yield (0, _effects.take)(action => action.type == actions.RECEIVE_BINARY && action.address == address);
  debug("got binary for %s", address);

  return binary;
}

function* init(provider) {
  yield (0, _effects.put)(actions.init(provider));
}

function* saga() {
  // wait for web3 init signal
  let { provider } = yield (0, _effects.take)(actions.INIT_WEB3);
  let adapter = new _adapter2.default(provider);

  yield (0, _effects.takeEvery)(actions.INSPECT, fetchTransactionInfo, adapter);
  yield (0, _effects.takeEvery)(actions.FETCH_BINARY, fetchBinary, adapter);
}

exports.default = (0, _helpers.prefixName)("web3", saga);

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = require("web3");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("truffle-decoder");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

exports.saga = saga;
exports.reset = reset;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(23);

var evm = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(34);

var solidity = _interopRequireWildcard(_sagas4);

var _actions = __webpack_require__(20);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(24);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

const STEP_SAGAS = {
  [actions.ADVANCE]: advance,
  [actions.STEP_NEXT]: stepNext,
  [actions.STEP_OVER]: stepOver,
  [actions.STEP_INTO]: stepInto,
  [actions.STEP_OUT]: stepOut,
  [actions.CONTINUE]: continueUntilBreakpoint
};

function* saga() {
  while (true) {
    debug("waiting for control action");
    let action = yield (0, _effects.take)((0, _keys2.default)(STEP_SAGAS));
    if (!(yield (0, _effects.select)(_selectors2.default.current.trace.loaded))) {
      continue; //while no trace is loaded, step actions are ignored
    }
    debug("got control action");
    let saga = STEP_SAGAS[action.type];

    yield (0, _effects.put)(actions.startStepping());
    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action), //not all will use this
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
    yield (0, _effects.put)(actions.doneStepping());
  }
}

exports.default = (0, _helpers.prefixName)("controller", saga);

/*
 * Advance the state by the given number of instructions (but not past the end)
 * (if no count given, advance 1)
 */

function* advance(action) {
  let count = action !== undefined && action.count !== undefined ? action.count : 1;
  //default is, as mentioned, to advance 1
  for (let i = 0; i < count && !(yield (0, _effects.select)(_selectors2.default.current.trace.finished)); i++) {
    yield* trace.advance();
  }
}

/**
 * stepNext - step to the next logical code segment
 *
 * Note: It might take multiple instructions to express the same section of code.
 * "Stepping", then, is stepping to the next logical item, not stepping to the next
 * instruction. See advance() if you'd like to advance by one instruction.
 */
function* stepNext() {
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);

  var upcoming, finished;

  do {
    // advance at least once step
    yield* advance();

    // and check the next source range
    try {
      upcoming = yield (0, _effects.select)(_selectors2.default.current.location);
    } catch (e) {
      upcoming = null;
    }

    finished = yield (0, _effects.select)(_selectors2.default.current.trace.finished);

    // if the next step's source range is still the same, keep going
  } while (!finished && (!upcoming || !upcoming.node || (0, _helpers.isDeliberatelySkippedNodeType)(upcoming.node) || upcoming.sourceRange.start == startingRange.start && upcoming.sourceRange.length == startingRange.length));
}

/**
 * stepInto - step into the current function
 *
 * Conceptually this is easy, but from a programming standpoint it's hard.
 * Code like `getBalance(msg.sender)` might be highlighted, but there could
 * be a number of different intermediate steps (like evaluating `msg.sender`)
 * before `getBalance` is stepped into. This function will step into the first
 * function available (where instruction.jump == "i"), ignoring any intermediate
 * steps that fall within the same code range. If there's a step encountered
 * that exists outside of the range, then stepInto will only execute until that
 * step.
 */
function* stepInto() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    yield* stepNext();
    return;
  }

  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();
    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;
  var finished;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
    finished = yield (0, _effects.select)(_selectors2.default.current.trace.finished);
  } while (
  //we aren't finished,
  !finished &&
  // the function stack has not increased,
  currentDepth <= startingDepth &&
  // the current source range begins on or after the starting range,
  currentRange.start >= startingRange.start &&
  // and the current range ends on or before the starting range ends
  currentRange.start + currentRange.length <= startingRange.start + startingRange.length);
}

/**
 * Step out of the current function
 *
 * This will run until the debugger encounters a decrease in function depth
 * (or finishes)
 */
function* stepOut() {
  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();
    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  var currentDepth;
  var finished;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    finished = yield (0, _effects.select)(_selectors2.default.current.trace.finished);
  } while (!finished && currentDepth >= startingDepth);
}

/**
 * stepOver - step over the current line
 *
 * Step over the current line. This will step to the next instruction that
 * exists on a different line of code within the same function depth.
 */
function* stepOver() {
  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;
  var finished;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
    finished = yield (0, _effects.select)(_selectors2.default.current.trace.finished);
  } while (
  // keep stepping provided:
  //
  // we haven't finished
  !finished &&
  // we haven't jumped out
  !(currentDepth < startingDepth) && (
  // either: function depth is greater than starting (ignore function calls)
  // or, if we're at the same depth, keep stepping until we're on a new
  // line.
  currentDepth > startingDepth || currentRange.lines.start.line == startingRange.lines.start.line));
}

/**
 * continueUntilBreakpoint - step through execution until a breakpoint
 */
function* continueUntilBreakpoint(action) {
  //if breakpoints was not specified, use the stored list from the state.
  //if it was, override that with the specified list.
  //note that explicitly specifying an empty list will advance to the end.
  let breakpoints = action !== undefined && action.breakpoints !== undefined ? action.breakpoints : yield (0, _effects.select)(_selectors2.default.breakpoints);

  let breakpointHit = false;

  let currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
  let currentLine = currentLocation.sourceRange.lines.start.line;
  let currentSourceId = currentLocation.source.id;

  do {
    yield* stepNext();

    //note these two have not been updated yet; they'll be updated a
    //few lines down.  but at this point these are still the previous
    //values.
    let previousLine = currentLine;
    let previousSourceId = currentSourceId;

    currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
    debug("currentLocation: %O", currentLocation);
    let finished = yield (0, _effects.select)(_selectors2.default.current.trace.finished);
    if (finished) {
      break; //can break immediately if finished
    }

    currentSourceId = currentLocation.source.id;
    if (currentSourceId === undefined) {
      continue; //never stop on an unmapped instruction
    }
    let currentNode = currentLocation.node.id;
    currentLine = currentLocation.sourceRange.lines.start.line;

    breakpointHit = breakpoints.filter(({ sourceId, line, node }) => {
      if (node !== undefined) {
        return sourceId === currentSourceId && node === currentNode;
      }
      //otherwise, we have a line-style breakpoint; we want to stop at the
      //*first* point on the line
      return sourceId === currentSourceId && line === currentLine && (currentSourceId !== previousSourceId || currentLine !== previousLine);
    }).length > 0;
  } while (!breakpointHit);
}

/**
 * reset -- reset the state of the debugger
 */
function* reset() {
  yield* data.reset();
  yield* evm.reset();
  yield* solidity.reset();
  yield* trace.reset();
}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(35);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(12);

var _sagas = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(11);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:sagas");

function* addSource(source, sourcePath, ast, compiler) {
  yield (0, _effects.put)(actions.addSource(source, sourcePath, ast, compiler));
}

function* tickSaga() {
  debug("got TICK");

  yield* functionDepthSaga();
  debug("instruction: %O", (yield (0, _effects.select)(_selectors2.default.current.instruction)));
  yield* trace.signalTickSagaCompletion();
}

function* functionDepthSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.willFail)) {
    //we do this case first so we can be sure we're not failing in any of the
    //other cases below!
    yield (0, _effects.put)(actions.externalReturn());
  } else if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    let jumpDirection = yield (0, _effects.select)(_selectors2.default.current.jumpDirection);
    yield (0, _effects.put)(actions.jump(jumpDirection));
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCall)) {
    debug("about to call");
    if (yield (0, _effects.select)(_selectors2.default.current.callsPrecompileOrExternal)) {
      //call to precompile or externally-owned account; do nothing
    } else {
      yield (0, _effects.put)(actions.externalCall());
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCreate)) {
    yield (0, _effects.put)(actions.externalCall());
  } else if (yield (0, _effects.select)(_selectors2.default.current.willReturn)) {
    yield (0, _effects.put)(actions.externalReturn());
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions2.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("solidity", saga);

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.jump = jump;
exports.externalCall = externalCall;
exports.externalReturn = externalReturn;
exports.reset = reset;
const ADD_SOURCE = exports.ADD_SOURCE = "SOLIDITY_ADD_SOURCE";
function addSource(source, sourcePath, ast, compiler) {
  return {
    type: ADD_SOURCE,
    source,
    sourcePath,
    ast,
    compiler
  };
}

const JUMP = exports.JUMP = "JUMP";
function jump(jumpDirection) {
  return {
    type: JUMP,
    jumpDirection
  };
}

const EXTERNAL_CALL = exports.EXTERNAL_CALL = "EXTERNAL_CALL";
function externalCall() {
  return { type: EXTERNAL_CALL };
}

const EXTERNAL_RETURN = exports.EXTERNAL_RETURN = "EXTERNAL_RETURN";
function externalReturn() {
  return { type: EXTERNAL_RETURN };
}

const RESET = exports.RESET = "SOLIDITY_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(11);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:selectors");

/**
 * ast
 */
const ast = (0, _reselectTree.createSelectorTree)({
  /**
   * ast.views
   */
  views: {
    /**
     * ast.views.sources
     */
    sources: (0, _reselectTree.createLeaf)([_selectors2.default.info.sources], sources => sources)
  }
});

exports.default = ast;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var Debugger = __webpack_require__(38).default;

module.exports = Debugger;



/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(18);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _expect = __webpack_require__(39);

var _expect2 = _interopRequireDefault(_expect);

var _session = __webpack_require__(40);

var _session2 = _interopRequireDefault(_session);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(36);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(10);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(9);

var _selectors8 = _interopRequireDefault(_selectors7);

var _selectors9 = __webpack_require__(11);

var _selectors10 = _interopRequireDefault(_selectors9);

var _selectors11 = __webpack_require__(26);

var _selectors12 = _interopRequireDefault(_selectors11);

var _selectors13 = __webpack_require__(24);

var _selectors14 = _interopRequireDefault(_selectors13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger");


/**
 * @example
 * let session = Debugger
 *   .forTx(<txHash>, {
 *     contracts: [<contract obj>, ...],
 *     provider: <provider instance>
 *   })
 *   .connect();
 */
class Debugger {
  /**
   * @param {Session} session - debugger session
   * @private
   */
  constructor(session) {
    /**
     * @private
     */
    this._session = session;
  }

  /**
   * Instantiates a Debugger for a given transaction hash.
   *
   * @param {String} txHash - transaction hash with leading "0x"
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */
  static forTx(txHash, options = {}) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _expect2.default.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, options.provider, txHash);

      try {
        yield session.ready();
        debug("session ready");
      } catch (e) {
        debug("error occurred, unloaded");
        session.unload();
      }

      return new _this(session);
    })();
  }

  /*
   * Instantiates a Debugger for a given project (with no transaction loaded)
   *
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */
  static forProject(options = {}) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _expect2.default.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, options.provider);

      yield session.ready();

      return new _this2(session);
    })();
  }

  /**
   * Connects to the instantiated Debugger.
   *
   * @return {Session} session instance
   */
  connect() {
    return this._session;
  }

  /**
   * Exported selectors
   *
   * See individual selector docs for full listing
   *
   * @example
   * Debugger.selectors.ast.current.tree
   *
   * @example
   * Debugger.selectors.solidity.current.instruction
   *
   * @example
   * Debugger.selectors.trace.steps
   */
  static get selectors() {
    return (0, _reselectTree.createNestedSelector)({
      ast: _selectors4.default,
      data: _selectors2.default,
      trace: _selectors6.default,
      evm: _selectors8.default,
      solidity: _selectors10.default,
      session: _selectors12.default,
      controller: _selectors14.default
    });
  }
}

exports.default = Debugger; /**
                             * @typedef {Object} Contract
                             * @property {string} contractName contract name
                             * @property {string} source solidity source code
                             * @property {string} sourcePath path to source file
                             * @property {string} binary 0x-prefixed hex string with create bytecode
                             * @property {string} sourceMap solidity source map for create bytecode
                             * @property {Object} ast Abstract Syntax Tree from Solidity
                             * @property {string} deployedBinary 0x-prefixed compiled binary (on chain)
                             * @property {string} deployedSourceMap solidity source map for on-chain bytecode
                             */

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = require("@truffle/expect");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _values = __webpack_require__(19);

var _values2 = _interopRequireDefault(_values);

var _asyncToGenerator2 = __webpack_require__(18);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = __webpack_require__(41);

var _promise2 = _interopRequireDefault(_promise);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _store = __webpack_require__(42);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(20);

var controller = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(14);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(26);

var _selectors4 = _interopRequireDefault(_selectors3);

var _sagas = __webpack_require__(17);

var dataSagas = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(33);

var controllerSagas = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(59);

var sagas = _interopRequireWildcard(_sagas3);

var _selectors5 = __webpack_require__(24);

var _selectors6 = _interopRequireDefault(_selectors5);

var _reducers = __webpack_require__(61);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session");

/**
 * Debugger Session
 */
class Session {
  /**
   * @param {Array<Contract>} contracts - contract definitions
   * @param {Array<String>} files - array of filenames for sourceMap indexes
   * @param {Web3Provider} provider - web3 provider
   * txHash parameter is now optional!
   * @private
   */
  constructor(contracts, files, provider, txHash) {
    /**
     * @private
     */
    let { store, sagaMiddleware } = (0, _store2.default)(_reducers2.default, sagas.default);
    this._store = store;
    this._sagaMiddleware = sagaMiddleware;

    let { contexts, sources } = Session.normalize(contracts, files);

    // record contracts
    this._store.dispatch(actions.recordContracts(contexts, sources));

    //set up the ready listener
    this._ready = new _promise2.default((accept, reject) => {
      const unsubscribe = this._store.subscribe(() => {
        if (this.view(_selectors4.default.status.ready)) {
          debug("ready!");
          unsubscribe();
          accept();
        } else if (this.view(_selectors4.default.status.errored)) {
          debug("error!");
          unsubscribe();
          reject(this.view(_selectors4.default.status.error));
        }
      });
    });

    //note that txHash is now optional
    this._store.dispatch(actions.start(provider, txHash));
  }

  ready() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this._ready;
    })();
  }

  readyAgainAfterLoading(sessionAction) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        let hasStartedWaiting = false;
        debug("reready listener set up");
        const unsubscribe = _this2._store.subscribe(function () {
          debug("reready?");
          if (hasStartedWaiting) {
            if (_this2.view(_selectors4.default.status.ready)) {
              debug("reready!");
              unsubscribe();
              accept(true);
            } else if (_this2.view(_selectors4.default.status.errored)) {
              unsubscribe();
              debug("error!");
              reject(_this2.view(_selectors4.default.status.error));
            }
          } else {
            if (_this2.view(_selectors4.default.status.waiting)) {
              debug("started waiting");
              hasStartedWaiting = true;
            }
            return;
          }
        });
        _this2.dispatch(sessionAction);
      });
    })();
  }

  /**
   * Split up artifacts into "contexts" and "sources", dividing artifact
   * data into appropriate buckets.
   *
   * Multiple contracts can be defined in the same source file, but have
   * different bytecodes.
   *
   * This iterates over the contracts and collects binaries separately
   * from sources, using the optional `files` argument to force
   * source ordering.
   * @private
   */
  static normalize(contracts, files = null) {
    let sourcesByPath = {};
    let contexts = [];
    let sources;

    for (let contract of contracts) {
      let {
        contractName,
        binary,
        sourceMap,
        deployedBinary,
        deployedSourceMap,
        sourcePath,
        source,
        ast,
        abi,
        compiler
      } = contract;

      let contractNode = ast.nodes.find(node => node.nodeType === "ContractDefinition" && node.name === contractName); //ideally we'd hold this off till later, but that would break the
      //direction of the evm/solidity dependence, so we do it now

      let contractId = contractNode.id;
      let contractKind = contractNode.contractKind;

      debug("contractName %s", contractName);
      debug("sourceMap %o", sourceMap);
      debug("compiler %o", compiler);
      debug("abi %O", abi);

      sourcesByPath[sourcePath] = { sourcePath, source, ast, compiler };

      if (binary && binary != "0x") {
        contexts.push({
          contractName,
          binary,
          sourceMap,
          abi,
          compiler,
          contractId,
          contractKind,
          isConstructor: true
        });
      }

      if (deployedBinary && deployedBinary != "0x") {
        contexts.push({
          contractName,
          binary: deployedBinary,
          sourceMap: deployedSourceMap,
          abi,
          compiler,
          contractId,
          contractKind,
          isConstructor: false
        });
      }
    }

    if (!files) {
      sources = (0, _values2.default)(sourcesByPath);
    } else {
      sources = files.map(file => sourcesByPath[file]);
    }

    return { contexts, sources };
  }

  get state() {
    return this._store.getState();
  }

  view(selector) {
    return selector(this.state);
  }

  dispatch(action) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this3._store.dispatch(action);

      return true;
    })();
  }

  /**
   * @private
   * Allows running any saga -- for internal use only!
   * Using this could seriously screw up the debugger state if you
   * don't know what you're doing!
   */
  _runSaga(saga, ...args) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this4._sagaMiddleware.run(saga, ...args).toPromise();
    })();
  }

  interrupt() {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this5.dispatch(actions.interrupt());
      yield _this5.dispatch(controller.interrupt());
    })();
  }

  doneStepping(stepperAction) {
    var _this6 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (resolve) {
        let hasStarted = false;
        const unsubscribe = _this6._store.subscribe(function () {
          const isStepping = _this6.view(_selectors6.default.isStepping);

          if (isStepping && !hasStarted) {
            hasStarted = true;
            debug("heard step start");
            return;
          }

          if (!isStepping && hasStarted) {
            debug("heard step stop");
            unsubscribe();
            resolve(true);
          }
        });
        _this6.dispatch(stepperAction);
      });
    })();
  }

  //returns true on success, false on already loaded, error object on failure
  load(txHash) {
    var _this7 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (_this7.view(_selectors4.default.status.loaded)) {
        return false;
      }
      try {
        return yield _this7.readyAgainAfterLoading(actions.loadTransaction(txHash));
      } catch (e) {
        _this7._runSaga(sagas.unload);
        return e;
      }
    })();
  }

  //returns true on success, false on already unloaded
  unload() {
    var _this8 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (!_this8.view(_selectors4.default.status.loaded)) {
        return false;
      }
      debug("unloading");
      yield _this8._runSaga(sagas.unload);
      return true;
    })();
  }

  //Note: count is an optional argument; default behavior is to advance 1
  advance(count) {
    var _this9 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this9.doneStepping(controller.advance(count));
    })();
  }

  stepNext() {
    var _this10 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this10.doneStepping(controller.stepNext());
    })();
  }

  stepOver() {
    var _this11 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this11.doneStepping(controller.stepOver());
    })();
  }

  stepInto() {
    var _this12 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this12.doneStepping(controller.stepInto());
    })();
  }

  stepOut() {
    var _this13 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this13.doneStepping(controller.stepOut());
    })();
  }

  reset() {
    var _this14 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      let loaded = _this14.view(_selectors4.default.status.loaded);
      if (!loaded) {
        return;
      }
      return yield _this14._runSaga(controllerSagas.reset);
    })();
  }

  //NOTE: breakpoints is an OPTIONAL argument for if you want to supply your
  //own list of breakpoints; leave it out to use the internal one (as
  //controlled by the functions below)
  continueUntilBreakpoint(breakpoints) {
    var _this15 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this15.doneStepping(controller.continueUntilBreakpoint(breakpoints));
    })();
  }

  addBreakpoint(breakpoint) {
    var _this16 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this16.dispatch(controller.addBreakpoint(breakpoint));
    })();
  }

  removeBreakpoint(breakpoint) {
    var _this17 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this17.dispatch(controller.removeBreakpoint(breakpoint));
    })();
  }

  removeAllBreakpoints() {
    var _this18 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this18.dispatch(controller.removeAllBreakpoints());
    })();
  }

  //deprecated -- decode is now *always* ready!
  decodeReady() {
    return (0, _asyncToGenerator3.default)(function* () {
      return true;
    })();
  }

  variable(name) {
    var _this19 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const definitions = _this19.view(_selectors2.default.current.identifiers.definitions);
      const refs = _this19.view(_selectors2.default.current.identifiers.refs);

      return yield _this19._runSaga(dataSagas.decode, definitions[name], refs[name]);
    })();
  }

  variables() {
    var _this20 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (!_this20.view(_selectors4.default.status.loaded)) {
        return {};
      }
      let definitions = _this20.view(_selectors2.default.current.identifiers.definitions);
      let refs = _this20.view(_selectors2.default.current.identifiers.refs);
      let decoded = {};
      for (let [identifier, ref] of (0, _entries2.default)(refs)) {
        if (identifier in definitions) {
          decoded[identifier] = yield _this20._runSaga(dataSagas.decode, definitions[identifier], ref);
        }
      }
      return decoded;
    })();
  }
}
exports.default = Session;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(43);
} else if (process.env.NODE_ENV === "test") {
  module.exports = require("./test");
} else {
  module.exports = require("./development");
}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(44);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _common2.default;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

exports.abbreviateValues = abbreviateValues;
exports.default = configureStore;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _reduxSaga = __webpack_require__(45);

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _reduxCliLogger = __webpack_require__(46);

var _reduxCliLogger2 = _interopRequireDefault(_reduxCliLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:store:common");
const reduxDebug = (0, _debug2.default)("debugger:redux");

function abbreviateValues(value, options = {}, depth = 0) {
  options.stringLimit = options.stringLimit || 66;
  options.arrayLimit = options.arrayLimit || 8;
  options.recurseLimit = options.recurseLimit || 4;

  if (depth > options.recurseLimit) {
    return "...";
  }

  const recurse = child => abbreviateValues(child, options, depth + 1);

  if (value instanceof Array) {
    if (value.length > options.arrayLimit) {
      value = [...value.slice(0, options.arrayLimit / 2), "...", ...value.slice(value.length - options.arrayLimit / 2 + 1)];
    }

    return value.map(recurse);
  } else if (value instanceof Object) {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([k, v]) => ({ [recurse(k)]: recurse(v) })));
  } else if (typeof value === "string" && value.length > options.stringLimit) {
    let inner = "...";
    let extractAmount = (options.stringLimit - inner.length) / 2;
    let leading = value.slice(0, Math.ceil(extractAmount));
    let trailing = value.slice(value.length - Math.floor(extractAmount));
    return `${leading}${inner}${trailing}`;
  } else {
    return value;
  }
}

function configureStore(reducer, saga, initialState, composeEnhancers) {
  const sagaMiddleware = (0, _reduxSaga2.default)();

  if (!composeEnhancers) {
    composeEnhancers = _redux.compose;
  }

  const loggerMiddleware = (0, _reduxCliLogger2.default)({
    log: reduxDebug,
    stateTransformer: state => abbreviateValues(state, {
      arrayLimit: 4,
      recurseLimit: 3
    }),
    actionTransformer: abbreviateValues
  });

  let store = (0, _redux.createStore)(reducer, initialState, composeEnhancers((0, _redux.applyMiddleware)(sagaMiddleware, loggerMiddleware)));

  sagaMiddleware.run(saga);

  return { store, sagaMiddleware };
}

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = require("redux-saga");

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("redux-cli-logger");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(48);

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

exports.parse = __webpack_require__(49);
exports.stringify = __webpack_require__(50);


/***/ }),
/* 49 */
/***/ (function(module, exports) {

var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};


/***/ }),
/* 50 */
/***/ (function(module, exports) {

var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};


/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = require("@truffle/solidity-utils");

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = require("@truffle/code-utils");

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = __webpack_require__(54);
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.inspect = inspect;
exports.fetchBinary = fetchBinary;
exports.receiveBinary = receiveBinary;
exports.receiveTrace = receiveTrace;
exports.receiveCall = receiveCall;
exports.error = error;
const INIT_WEB3 = exports.INIT_WEB3 = "INIT_WEB3";
function init(provider) {
  return {
    type: INIT_WEB3,
    provider
  };
}

const INSPECT = exports.INSPECT = "INSPECT_TRANSACTION";
function inspect(txHash) {
  return {
    type: INSPECT,
    txHash
  };
}

const FETCH_BINARY = exports.FETCH_BINARY = "FETCH_BINARY";
function fetchBinary(address, block) {
  return {
    type: FETCH_BINARY,
    address,
    block //optional
  };
}

const RECEIVE_BINARY = exports.RECEIVE_BINARY = "RECEIVE_BINARY";
function receiveBinary(address, binary) {
  return {
    type: RECEIVE_BINARY,
    address,
    binary
  };
}

const RECEIVE_TRACE = exports.RECEIVE_TRACE = "RECEIVE_TRACE";
function receiveTrace(trace) {
  return {
    type: RECEIVE_TRACE,
    trace
  };
}

const RECEIVE_CALL = exports.RECEIVE_CALL = "RECEIVE_CALL";
function receiveCall({
  address,
  binary,
  data,
  storageAddress,
  status,
  sender,
  value,
  gasprice,
  block
}) {
  return {
    type: RECEIVE_CALL,
    address,
    binary,
    data,
    storageAddress,
    status, //only used for creation calls at present!
    sender,
    value,
    gasprice,
    block
  };
}

const ERROR_WEB3 = exports.ERROR_WEB3 = "ERROR_WEB3";
function error(error) {
  return {
    type: ERROR_WEB3,
    error
  };
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(18);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _web = __webpack_require__(31);

var _web2 = _interopRequireDefault(_web);

var _util = __webpack_require__(57);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:adapter");

class Web3Adapter {
  constructor(provider) {
    this.web3 = new _web2.default(provider);
  }

  getTrace(txHash) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      let result = yield (0, _util.promisify)(_this.web3.currentProvider.send)(
      //send *only* uses callbacks, so we use promsifiy to make things more
      //readable
      {
        jsonrpc: "2.0",
        method: "debug_traceTransaction",
        params: [txHash, {}],
        id: new Date().getTime()
      });
      if (result.error) {
        throw new Error(result.error.message);
      } else {
        return result.result.structLogs;
      }
    })();
  }

  getTransaction(txHash) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this2.web3.eth.getTransaction(txHash);
    })();
  }

  getReceipt(txHash) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this3.web3.eth.getTransactionReceipt(txHash);
    })();
  }

  getBlock(blockNumberOrHash) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this4.web3.eth.getBlock(blockNumberOrHash);
    })();
  }

  /**
   * getDeployedCode - get the deployed code for an address from the client
   * NOTE: the block argument is optional
   * @param  {String} address
   * @return {String}         deployedBinary
   */
  getDeployedCode(address, block) {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("getting deployed code for %s", address);
      let code = yield _this5.web3.eth.getCode(address, block);
      return code === "0x0" ? "0x" : code;
    })();
  }
}
exports.default = Web3Adapter;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = require("lodash.sum");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

exports.saga = saga;
exports.processTransaction = processTransaction;
exports.unload = unload;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(60);

var ast = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(33);

var controller = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(34);

var solidity = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(23);

var evm = _interopRequireWildcard(_sagas4);

var _sagas5 = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas5);

var _sagas6 = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas6);

var _sagas7 = __webpack_require__(30);

var web3 = _interopRequireWildcard(_sagas7);

var _actions = __webpack_require__(14);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:sagas");

const LOAD_SAGAS = {
  [actions.LOAD_TRANSACTION]: load
  //will also add reconstruct action/saga once it exists
};

function* listenerSaga() {
  while (true) {
    let action = yield (0, _effects.take)((0, _keys2.default)(LOAD_SAGAS));
    let saga = LOAD_SAGAS[action.type];

    yield (0, _effects.put)(actions.wait());
    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action), //not all will use this
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
    yield (0, _effects.put)(actions.ready());
  }
}

function* saga() {
  debug("starting listeners");
  yield* forkListeners();

  // receiving & saving contracts into state
  debug("waiting for contract information");
  let { contexts, sources } = yield (0, _effects.take)(actions.RECORD_CONTRACTS);

  debug("recording contract binaries");
  yield* recordContexts(...contexts);

  debug("recording contract sources");
  yield* recordSources(...sources);

  debug("normalizing contexts");
  yield* evm.normalizeContexts();

  debug("waiting for start");
  // wait for start signal
  let { txHash, provider } = yield (0, _effects.take)(actions.START);
  debug("starting");

  debug("visiting ASTs");
  // visit asts
  yield* ast.visitAll();

  //save allocation table
  debug("saving allocation table");
  yield* data.recordAllocations();

  //initialize web3 adapter
  yield* web3.init(provider);

  //process transaction (if there is one)
  //(note: this part may also set the error state)
  if (txHash !== undefined) {
    yield* processTransaction(txHash);
  }

  debug("readying");
  // signal that commands can begin
  yield* ready();
}

function* processTransaction(txHash) {
  // process transaction
  debug("fetching transaction info");
  let err = yield* fetchTx(txHash);
  if (err) {
    debug("error %o", err);
    yield* error(err);
  }
}

exports.default = (0, _helpers.prefixName)("session", saga);


function* forkListeners() {
  yield (0, _effects.fork)(listenerSaga); //session listener; this one is separate, sorry
  //(I didn't want to mess w/ the existing structure of defaults)
  return yield (0, _effects.all)([controller, data, evm, solidity, trace, web3].map(app => (0, _effects.fork)(app.saga)
  //ast no longer has a listener
  ));
}

function* fetchTx(txHash) {
  let result = yield* web3.inspectTransaction(txHash);
  debug("result %o", result);

  if (result.error) {
    return result.error;
  }

  //get addresses created/called during transaction
  debug("processing trace for addresses");
  let addresses = yield* trace.processTrace(result.trace);
  //add in the address of the call itself (if a call)
  if (result.address && !addresses.includes(result.address)) {
    addresses.push(result.address);
  }
  //if a create, only add in address if it was successful
  if (result.binary && result.status && !addresses.includes(result.storageAddress)) {
    addresses.push(result.storageAddress);
  }

  let blockNumber = result.block.number.toString(); //a BN is not accepted
  debug("obtaining binaries");
  let binaries = yield* web3.obtainBinaries(addresses, blockNumber);

  debug("recording instances");
  yield (0, _effects.all)(addresses.map((address, i) => (0, _effects.call)(recordInstance, address, binaries[i])));

  debug("sending initial call");
  yield* evm.begin(result);
}

function* recordContexts(...contexts) {
  for (let context of contexts) {
    yield* evm.addContext(context);
  }
}

function* recordSources(...sources) {
  for (let sourceData of sources) {
    if (sourceData !== undefined && sourceData !== null) {
      yield* solidity.addSource(sourceData.source, sourceData.sourcePath, sourceData.ast, sourceData.compiler);
    }
  }
}

function* recordInstance(address, binary) {
  yield* evm.addInstance(address, binary);
}

function* ready() {
  yield (0, _effects.put)(actions.ready());
}

function* error(err) {
  yield (0, _effects.put)(actions.error(err));
}

function* unload() {
  debug("unloading");
  yield* data.reset();
  yield* solidity.reset();
  yield* evm.unload();
  yield* trace.unload();
  yield (0, _effects.put)(actions.unloadTransaction());
}

//note that load takes an action as its argument, which is why it's separate
//from processTransaction
function* load({ txHash }) {
  yield* processTransaction(txHash);
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

exports.visitAll = visitAll;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _sagas = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(36);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:sagas");

function* walk(sourceId, node, pointer = "", parentId = null) {
  debug("walking %o %o", pointer, node);

  yield* handleEnter(sourceId, node, pointer, parentId);

  if (node instanceof Array) {
    for (let [i, child] of node.entries()) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${i}`, parentId);
    }
  } else if (node instanceof Object) {
    for (let [key, child] of (0, _entries2.default)(node)) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${key}`, node.id);
    }
  }

  yield* handleExit(sourceId, node, pointer);
}

function* handleEnter(sourceId, node, pointer, parentId) {
  if (!(node instanceof Object)) {
    return;
  }

  debug("entering %s", pointer);

  if (node.id !== undefined) {
    debug("%s recording scope %s", pointer, node.id);
    yield* data.scope(node.id, pointer, parentId, sourceId);
  }

  switch (node.nodeType) {
    case "VariableDeclaration":
      debug("%s recording variable %o", pointer, node);
      yield* data.declare(node);
      break;
    case "ContractDefinition":
    case "StructDefinition":
    case "EnumDefinition":
      yield* data.defineType(node);
      break;
  }
}

function* handleExit(sourceId, node, pointer) {
  debug("exiting %s", pointer);

  // no-op right now
}

function* visitAll() {
  let sources = yield (0, _effects.select)(_selectors2.default.views.sources);

  yield (0, _effects.all)((0, _entries2.default)(sources).filter(([_, source]) => source.ast).map(([id, { ast }]) => (0, _effects.call)(walk, id, ast)));

  debug("done visiting");
}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _reducers = __webpack_require__(62);

var _reducers2 = _interopRequireDefault(_reducers);

var _reducers3 = __webpack_require__(63);

var _reducers4 = _interopRequireDefault(_reducers3);

var _reducers5 = __webpack_require__(64);

var _reducers6 = _interopRequireDefault(_reducers5);

var _reducers7 = __webpack_require__(65);

var _reducers8 = _interopRequireDefault(_reducers7);

var _reducers9 = __webpack_require__(66);

var _reducers10 = _interopRequireDefault(_reducers9);

var _actions = __webpack_require__(14);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:reducers");

function ready(state = false, action) {
  switch (action.type) {
    case actions.READY:
      debug("readying");
      return true;

    case actions.WAIT:
      return false;

    default:
      return state;
  }
}

function projectInfoComputed(state = false, action) {
  switch (action.type) {
    case actions.PROJECT_INFO_COMPUTED:
      return true;
    default:
      return state;
  }
}

function lastLoadingError(state = null, action) {
  switch (action.type) {
    case actions.ERROR:
      debug("error: %o", action.error);
      return action.error;

    case actions.WAIT:
      return null;

    default:
      return state;
  }
}

function transaction(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_TRANSACTION:
      return action.transaction;
    case actions.UNLOAD_TRANSACTION:
      return {};
    default:
      return state;
  }
}

function receipt(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_RECEIPT:
      return action.receipt;
    case actions.UNLOAD_TRANSACTION:
      return {};
    default:
      return state;
  }
}

function block(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_BLOCK:
      return action.block;
    case actions.UNLOAD_TRANSACTION:
      return {};
    default:
      return state;
  }
}

const session = (0, _redux.combineReducers)({
  ready,
  lastLoadingError,
  projectInfoComputed,
  transaction,
  receipt,
  block
});

const reduceState = (0, _redux.combineReducers)({
  session,
  data: _reducers2.default,
  evm: _reducers4.default,
  solidity: _reducers6.default,
  trace: _reducers8.default,
  controller: _reducers10.default
});

exports.default = reduceState;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(28);

var _set2 = _interopRequireDefault(_set);

var _values = __webpack_require__(19);

var _values2 = _interopRequireDefault(_values);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(27);

var actions = _interopRequireWildcard(_actions);

var _truffleDecoder = __webpack_require__(32);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(4);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:reducers");

const DEFAULT_SCOPES = {
  byId: {}
};

function scopes(state = DEFAULT_SCOPES, action) {
  var scope;
  var variables;

  switch (action.type) {
    case actions.SCOPE:
      scope = state.byId[action.id] || {};

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.id]: (0, _extends3.default)({}, scope, {

            id: action.id,
            sourceId: action.sourceId,
            parentId: action.parentId,
            pointer: action.pointer
          })
        })
      };

    case actions.DECLARE:
      scope = state.byId[action.node.scope] || {};
      variables = scope.variables || [];

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.node.scope]: (0, _extends3.default)({}, scope, {

            variables: [...variables, { name: action.node.name, id: action.node.id }]
          })
        })
      };

    default:
      return state;
  }
}

//a note on the following reducer: solidity assigns a unique AST ID to every
//AST node among all the files being compiled together.  thus, it is, for now,
//safe to identify user-defined types solely by their AST ID.  In the future,
//once we eventually support having some files compiled separately from others,
//this will become a bug you'll have to fix, and you'll have to fix it in the
//decoder, too.  Sorry, future me! (or whoever's stuck doing this)

function userDefinedTypes(state = [], action) {
  switch (action.type) {
    case actions.DEFINE_TYPE:
      return [...state, action.node.id];
    default:
      return state;
  }
}

const DEFAULT_ALLOCATIONS = {
  storage: {},
  memory: {},
  calldata: {}
};

function allocations(state = DEFAULT_ALLOCATIONS, action) {
  if (action.type === actions.ALLOCATE) {
    return {
      storage: action.storage,
      memory: action.memory,
      calldata: action.calldata
    };
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  scopes,
  userDefinedTypes,
  allocations
});

const GLOBAL_ASSIGNMENTS = [[{ builtin: "msg" }, { special: "msg" }], [{ builtin: "tx" }, { special: "tx" }], [{ builtin: "block" }, { special: "block" }], [{ builtin: "this" }, { special: "this" }], [{ builtin: "now" }, { special: "timestamp" }] //we don't have an alias "now"
].map(([idObj, ref]) => (0, _helpers.makeAssignment)(idObj, ref));

const DEFAULT_ASSIGNMENTS = {
  byId: (0, _assign2.default)({}, //we start out with all globals assigned
  ...GLOBAL_ASSIGNMENTS.map(assignment => ({ [assignment.id]: assignment }))),
  byAstId: {}, //no regular variables assigned at start
  byBuiltin: (0, _assign2.default)({}, //again, all globals start assigned
  ...GLOBAL_ASSIGNMENTS.map(assignment => ({
    [assignment.builtin]: [assignment.id] //yes, that's a 1-element array
  })))
};

function assignments(state = DEFAULT_ASSIGNMENTS, action) {
  switch (action.type) {
    case actions.ASSIGN:
    case actions.MAP_PATH_AND_ASSIGN:
      debug("action.type %O", action.type);
      debug("action.assignments %O", action.assignments);
      return (0, _values2.default)(action.assignments).reduce((acc, assignment) => {
        let { id, astId } = assignment;
        //we assume for now that only ordinary variables will be assigned this
        //way, and not globals; globals are handled in DEFAULT_ASSIGNMENTS
        return (0, _extends3.default)({}, acc, {
          byId: (0, _extends3.default)({}, acc.byId, {
            [id]: assignment
          }),
          byAstId: (0, _extends3.default)({}, acc.byAstId, {
            [astId]: [...new _set2.default([...(acc.byAstId[astId] || []), id])]
            //we use a set for uniqueness
          })
        });
      }, state);

    case actions.RESET:
      return DEFAULT_ASSIGNMENTS;

    default:
      return state;
  }
}

const DEFAULT_PATHS = {
  byAddress: {}
};

//WARNING: do *not* rely on mappedPaths to keep track of paths that do not
//involve mapping keys!  Yes, many will get mapped, but there is no guarantee.
//Only when mapping keys are involved does it necessarily work reliably --
//which is fine, as that's all we need it for.
function mappedPaths(state = DEFAULT_PATHS, action) {
  switch (action.type) {
    case actions.MAP_PATH_AND_ASSIGN:
      let { address, slot, typeIdentifier, parentType } = action;
      //how this case works: first, we find the spot in our table (based on
      //address, type identifier, and slot address) where the new entry should
      //be added; if needed we set up all the objects needed along the way.  If
      //there's already something there, we do nothing.  If there's nothing
      //there, we record our given slot in that spot in that table -- however,
      //we alter it in one key way.  Before entry, we check if the slot's
      //*parent* has a spot in the table, based on address (same for both child
      //and parent), parentType, and the parent's slot address (which can be
      //found as the slotAddress of the slot's path object, if it exists -- if
      //it doesn't then we conclude that no the parent does not have a spot in
      //the table).  If the parent has a slot in the table already, then we
      //alter the child slot by replacing its path with the parent slot.  This
      //will keep the slotAddress the same, but since the versions kept in the
      //table here are supposed to preserve path information, we'll be
      //replacing a fairly bare-bones Slot object with one with a full path.

      //we do NOT want to distinguish between types with and without "_ptr" on
      //the end here!
      debug("typeIdentifier %s", typeIdentifier);
      typeIdentifier = _truffleDecodeUtils.Definition.restorePtr(typeIdentifier);
      parentType = _truffleDecodeUtils.Definition.restorePtr(parentType);

      debug("slot %o", slot);
      let hexSlotAddress = _truffleDecodeUtils.Conversion.toHexString((0, _truffleDecoder.slotAddress)(slot), _truffleDecodeUtils.EVM.WORD_SIZE);
      let parentAddress = slot.path ? _truffleDecodeUtils.Conversion.toHexString((0, _truffleDecoder.slotAddress)(slot.path), _truffleDecodeUtils.EVM.WORD_SIZE) : undefined;

      //this is going to be messy and procedural, sorry.  but let's start with
      //the easy stuff: create the new address if needed, clone if not
      let newState = (0, _extends3.default)({}, state, {
        byAddress: (0, _extends3.default)({}, state.byAddress, {
          [address]: {
            byType: (0, _extends3.default)({}, (state.byAddress[address] || { byType: {} }).byType)
          }
        })
      });

      //now, let's add in the new type, if needed
      newState.byAddress[address].byType = (0, _extends3.default)({}, newState.byAddress[address].byType, {
        [typeIdentifier]: {
          bySlotAddress: (0, _extends3.default)({}, (newState.byAddress[address].byType[typeIdentifier] || {
            bySlotAddress: {}
          }).bySlotAddress)
        }
      });

      let oldSlot = newState.byAddress[address].byType[typeIdentifier].bySlotAddress[hexSlotAddress];
      //yes, this looks strange, but we haven't changed it yet except to
      //clone or create empty (and we don't want undefined!)
      //now: is there something already there or no?  if no, we must add
      if (oldSlot === undefined) {
        let newSlot;
        debug("parentAddress %o", parentAddress);
        if (parentAddress !== undefined && newState.byAddress[address].byType[parentType] && newState.byAddress[address].byType[parentType].bySlotAddress[parentAddress]) {
          //if the parent is already present, use that instead of the given
          //parent!
          newSlot = (0, _extends3.default)({}, slot, {
            path: newState.byAddress[address].byType[parentType].bySlotAddress[parentAddress]
          });
        } else {
          newSlot = slot;
        }
        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[hexSlotAddress] = newSlot;
      }
      //if there's already something there, we don't need to do anything

      return newState;

    case actions.RESET:
      return DEFAULT_PATHS;

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  assignments,
  mappedPaths
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(29);

var actions = _interopRequireWildcard(_actions);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _bn = __webpack_require__(15);

var _bn2 = _interopRequireDefault(_bn);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:reducers");

const DEFAULT_CONTEXTS = {
  byContext: {}
};

function contexts(state = DEFAULT_CONTEXTS, action) {
  switch (action.type) {
    /*
     * Adding a new context
     */
    case actions.ADD_CONTEXT:
      const {
        contractName,
        binary,
        sourceMap,
        compiler,
        abi,
        contractId,
        contractKind,
        isConstructor
      } = action;
      debug("action %O", action);
      //NOTE: we take hash as *string*, not as bytes, because the binary may
      //contain link references!
      const context = (0, _helpers.keccak256)({ type: "string", value: binary });
      let primarySource;
      if (sourceMap !== undefined) {
        primarySource = (0, _helpers.extractPrimarySource)(sourceMap);
      }
      //otherwise leave it undefined

      return (0, _extends3.default)({}, state, {
        byContext: (0, _extends3.default)({}, state.byContext, {
          [context]: {
            contractName,
            context,
            binary,
            sourceMap,
            primarySource,
            compiler,
            abi,
            contractId,
            contractKind,
            isConstructor
          }
        })
      });

    case actions.NORMALIZE_CONTEXTS:
      return {
        byContext: DecodeUtils.Contexts.normalizeContexts(state.byContext)
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  contexts
});

const DEFAULT_TX = {
  gasprice: new _bn2.default(0),
  origin: DecodeUtils.EVM.ZERO_ADDRESS
};

function tx(state = DEFAULT_TX, action) {
  switch (action.type) {
    case actions.SAVE_GLOBALS:
      let { gasprice, origin } = action;
      return { gasprice, origin };
    case actions.UNLOAD_TRANSACTION:
      return DEFAULT_TX;
    default:
      return state;
  }
}

const DEFAULT_BLOCK = {
  coinbase: DecodeUtils.EVM.ZERO_ADDRESS,
  difficulty: new _bn2.default(0),
  gaslimit: new _bn2.default(0),
  number: new _bn2.default(0),
  timestamp: new _bn2.default(0)
};

function block(state = DEFAULT_BLOCK, action) {
  switch (action.type) {
    case actions.SAVE_GLOBALS:
      return action.block;
    case actions.UNLOAD_TRANSACTION:
      return DEFAULT_BLOCK;
    default:
      return state;
  }
}

const globals = (0, _redux.combineReducers)({
  tx,
  block
});

function status(state = null, action) {
  switch (action.type) {
    case actions.SAVE_STATUS:
      return action.status;
    case actions.UNLOAD_TRANSACTION:
      return null;
    default:
      return state;
  }
}

function initialCall(state = null, action) {
  switch (action.type) {
    case actions.CALL:
    case actions.CREATE:
      //we only want to save the initial call, so return
      //the current state if it's not null
      if (state !== null) {
        return state;
      } else {
        //we'll just store the action itself in the state
        return action;
      }
    case actions.UNLOAD_TRANSACTION:
      return null;
    default:
      return state;
  }
}

const transaction = (0, _redux.combineReducers)({
  globals,
  status,
  initialCall
});

function callstack(state = [], action) {
  switch (action.type) {
    case actions.CALL:
      {
        const { address, data, storageAddress, sender, value } = action;
        return state.concat([{ address, data, storageAddress, sender, value }]);
      }

    case actions.CREATE:
      {
        const { binary, storageAddress, sender, value } = action;
        return state.concat([{ binary, data: "0x", storageAddress, sender, value }]
        //the empty data field is to make msg.data and msg.sig come out right
        );
      }

    case actions.RETURN_CALL:
    case actions.RETURN_CREATE:
    case actions.FAIL:
      //pop the stack... unless (HACK) that would leave it empty (this will
      //only happen at the end when we want to keep the last one around)
      return state.length > 1 ? state.slice(0, -1) : state;

    case actions.RESET:
    case actions.UNLOAD_TRANSACTION:
      return [];

    default:
      return state;
  }
}

const DEFAULT_CODEX = [{
  accounts: {}
  //will be more here in the future!
}];

function codex(state = DEFAULT_CODEX, action) {
  let newState, topCodex;

  const updateFrameStorage = (frame, address, slot, value) => (0, _extends3.default)({}, frame, {
    accounts: (0, _extends3.default)({}, frame.accounts, {
      [address]: (0, _extends3.default)({}, frame.accounts[address], {
        storage: (0, _extends3.default)({}, frame.accounts[address].storage, {
          [slot]: value
        })
      })
    })
  });

  const updateFrameCode = (frame, address, code, context) => {
    let existingPage = frame.accounts[address] || { storage: {} };
    return (0, _extends3.default)({}, frame, {
      accounts: (0, _extends3.default)({}, frame.accounts, {
        [address]: (0, _extends3.default)({}, existingPage, {
          code: code,
          context: context
        })
      })
    });
  };

  //later: will add "force" parameter
  const safePop = array => array.length > 2 ? array.slice(0, -1) : array;

  //later: will add "force" parameter
  const safeSave = array => array.length > 2 ? array.slice(0, -2).concat([array[array.length - 1]]) : array;

  switch (action.type) {
    case actions.CALL:
      debug("call action");
      debug("codex: %O", state);
      //on a call, we can just make a new stackframe by cloning the top
      //stackframe; there should already be an account for the address we're
      //calling into, so we don't need to make one
      return [...state, state[state.length - 1]];

    case actions.CREATE:
      //on a create, make a new stackframe, then add a new pages to the
      //codex if necessary; don't add a zero page though (or pages that already
      //exist)

      //first, add a new stackframe by cloning the top one
      newState = [...state, state[state.length - 1]];
      topCodex = newState[newState.length - 1];
      //now, do we need to add a new address to this stackframe?
      if (topCodex.accounts[action.storageAddress] !== undefined || action.storageAddress === DecodeUtils.EVM.ZERO_ADDRESS) {
        //if we don't
        return newState;
      }
      //if we do
      newState[newState.length - 1] = (0, _extends3.default)({}, topCodex, {
        accounts: (0, _extends3.default)({}, topCodex.accounts, {
          [action.storageAddress]: {
            storage: {},
            code: "0x",
            context: null
            //there will be more here in the future!
          }
        })
      });
      return newState;

    case actions.STORE:
      {
        //on a store, the relevant page should already exist, so we can just
        //add or update the needed slot
        const { address, slot, value } = action;
        if (address === DecodeUtils.EVM.ZERO_ADDRESS) {
          //as always, we do not maintain a zero page
          return state;
        }
        newState = state.slice(); //clone the state
        topCodex = newState[newState.length - 1];
        newState[newState.length - 1] = updateFrameStorage(topCodex, address, slot, value);
        return newState;
      }

    case actions.LOAD:
      {
        //loads are a little more complicated -- usually we do nothing, but if
        //it's an external load (there was nothing already there), then we want
        //to update *every* stackframe
        const { address, slot, value } = action;
        if (address === DecodeUtils.EVM.ZERO_ADDRESS) {
          //as always, we do not maintain a zero page
          return state;
        }
        topCodex = state[state.length - 1];
        if (topCodex.accounts[address].storage[slot] !== undefined) {
          //if we already have a value in the *top* stackframe, update *no*
          //stackframes; don't update the top (no need, it's just a load, not a
          //store), don't update the rest (that would be wrong, you might be
          //loading a value that will get reverted later)
          return state;
        } else {
          //if we *don't* already have a value in the top stackframe, that means
          //we're loading a value from a previous transaction!  That's not a
          //value that will get reverted if this call fails, so update *every*
          //stackframe
          return state.map(frame => updateFrameStorage(frame, address, slot, value));
        }
      }

    case actions.RETURN_CALL:
      //we want to pop the top while making the new top a copy of the old top;
      //that is to say, we want to drop just the element *second* from the top
      //NOTE: we don't ever go down to 1 element!
      return safeSave(state);

    case actions.RETURN_CREATE:
      {
        //we're going to do the same things in this case as in the usual return
        //case, but first we need to record the code that was returned
        const { address, code, context } = action;
        newState = state.slice(); //clone the state
        //NOTE: since this is only for RETURN_CREATE, and not FAIL, we shouldn't
        //have to worry about accidentally getting a zero address here
        newState[newState.length - 1] = updateFrameCode(newState[newState.length - 1], address, code, context);
        debug("newState: %O", newState);
        return safeSave(newState);
      }

    case actions.FAIL:
      //pop the stack
      //NOTE: we don't ever go down to 1 element!
      return safePop(state);

    case actions.RESET:
      return [state[0]]; //leave the -1 frame on the stack

    case actions.UNLOAD_TRANSACTION:
      return DEFAULT_CODEX;

    case actions.ADD_INSTANCE:
      {
        //add the instance to every frame
        //(this is a little HACKy, but it *should* be fine)
        debug("adding instance");
        const { address, binary, context } = action;
        return state.map(frame => updateFrameCode(frame, address, binary, context));
      }

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  callstack,
  codex
});

const reducer = (0, _redux.combineReducers)({
  info,
  transaction,
  proc
});

exports.default = reducer;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(35);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_SOURCES = {
  byId: {}
};

function sources(state = DEFAULT_SOURCES, action) {
  switch (action.type) {
    /*
     * Adding a new source
     */
    case actions.ADD_SOURCE:
      let { ast, source, sourcePath, compiler } = action;

      let id = (0, _keys2.default)(state.byId).length;

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [id]: {
            id,
            ast,
            source,
            sourcePath,
            compiler
          }
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  sources
});

function functionDepthStack(state = [0], action) {
  switch (action.type) {
    case actions.JUMP:
      let newState = state.slice(); //clone the state
      const delta = spelunk(action.jumpDirection);
      let top = newState[newState.length - 1];
      newState[newState.length - 1] = top + delta;
      return newState;

    case actions.RESET:
      return [0];

    case actions.EXTERNAL_CALL:
      return [...state, state[state.length - 1] + 1];

    case actions.EXTERNAL_RETURN:
      //just pop the stack! unless, HACK, that would leave it empty
      return state.length > 1 ? state.slice(0, -1) : state;

    default:
      return state;
  }
}

function spelunk(jump) {
  if (jump === "i") {
    return 1;
  } else if (jump === "o") {
    return -1;
  } else {
    return 0;
  }
}

const proc = (0, _redux.combineReducers)({
  functionDepthStack
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(12);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:trace:reducers");

function index(state = 0, action) {
  switch (action.type) {
    case actions.TOCK:
      return state + 1;

    case actions.RESET:
    case actions.UNLOAD_TRANSACTION:
      return 0;

    default:
      return state;
  }
}

function finished(state = false, action) {
  switch (action.type) {
    case actions.END_OF_TRACE:
      return true;

    case actions.RESET:
    case actions.UNLOAD_TRANSACTION:
      return false;

    default:
      return state;
  }
}

function steps(state = null, action) {
  switch (action.type) {
    case actions.SAVE_STEPS:
      return action.steps;
    case actions.UNLOAD_TRANSACTION:
      debug("unloading");
      return null;
    default:
      return state;
  }
}

const transaction = (0, _redux.combineReducers)({
  steps
});

const proc = (0, _redux.combineReducers)({
  index,
  finished
});

const reducer = (0, _redux.combineReducers)({
  transaction,
  proc
});

exports.default = reducer;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(20);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:reducers");

function breakpoints(state = [], action) {
  switch (action.type) {
    case actions.ADD_BREAKPOINT:
      //check for any existing identical breakpoints to avoid redundancy
      if (state.filter(breakpoint => breakpoint.sourceId === action.breakpoint.sourceId && breakpoint.line === action.breakpoint.line && breakpoint.node === action.breakpoint.node //may be undefined
      ).length > 0) {
        //if it's already there, do nothing
        return state;
      } else {
        //otherwise add it
        return state.concat([action.breakpoint]);
      }
      break;

    case actions.REMOVE_BREAKPOINT:
      return state.filter(breakpoint => breakpoint.sourceId !== action.breakpoint.sourceId || breakpoint.line !== action.breakpoint.line || breakpoint.node !== action.breakpoint.node //may be undefined
      );
      break;

    case actions.REMOVE_ALL_BREAKPOINTS:
      return [];

    default:
      return state;
  }
}

function isStepping(state = false, action) {
  switch (action.type) {
    case actions.START_STEPPING:
      debug("got step start action");
      return true;
    case actions.DONE_STEPPING:
      debug("got step stop action");
      return false;
    default:
      return state;
  }
}

const reducer = (0, _redux.combineReducers)({
  breakpoints,
  isStepping
});

exports.default = reducer;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVidWdnZXIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2svYm9vdHN0cmFwIGIwZTg1ZmZlYzNkYTQ2NGEwYTI3IiwiZXh0ZXJuYWwgXCJkZWJ1Z1wiIiwibGliL2hlbHBlcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCIiLCJleHRlcm5hbCBcInJlc2VsZWN0LXRyZWVcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIiIsImV4dGVybmFsIFwicmVkdXgtc2FnYS9lZmZlY3RzXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiIiwiZXh0ZXJuYWwgXCJyZWR1eFwiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiIiwibGliL2V2bS9zZWxlY3RvcnMvaW5kZXguanMiLCJsaWIvdHJhY2Uvc2VsZWN0b3JzL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L3NlbGVjdG9ycy9pbmRleC5qcyIsImxpYi90cmFjZS9hY3Rpb25zL2luZGV4LmpzIiwibGliL3RyYWNlL3NhZ2FzL2luZGV4LmpzIiwibGliL3Nlc3Npb24vYWN0aW9ucy9pbmRleC5qcyIsImV4dGVybmFsIFwiYm4uanNcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIiLCJsaWIvZGF0YS9zYWdhcy9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXNcIiIsImxpYi9jb250cm9sbGVyL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvZGF0YS9zZWxlY3RvcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImpzb24tcG9pbnRlclwiIiwibGliL2V2bS9zYWdhcy9pbmRleC5qcyIsImxpYi9jb250cm9sbGVyL3NlbGVjdG9ycy9pbmRleC5qcyIsImxpYi9hc3QvbWFwLmpzIiwibGliL3Nlc3Npb24vc2VsZWN0b3JzL2luZGV4LmpzIiwibGliL2RhdGEvYWN0aW9ucy9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldFwiIiwibGliL2V2bS9hY3Rpb25zL2luZGV4LmpzIiwibGliL3dlYjMvc2FnYXMvaW5kZXguanMiLCJleHRlcm5hbCBcIndlYjNcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1kZWNvZGVyXCIiLCJsaWIvY29udHJvbGxlci9zYWdhcy9pbmRleC5qcyIsImxpYi9zb2xpZGl0eS9zYWdhcy9pbmRleC5qcyIsImxpYi9zb2xpZGl0eS9hY3Rpb25zL2luZGV4LmpzIiwibGliL2FzdC9zZWxlY3RvcnMvaW5kZXguanMiLCIvVXNlcnMvY3J1em1vbGluYS9Db2RlL3RydWZmbGUtcHJvamVjdHMvdHJ1ZmZsZS9wYWNrYWdlcy90cnVmZmxlLWRlYnVnZ2VyL2RlYnVnZ2VyLmpzIiwibGliL2RlYnVnZ2VyLmpzIiwiZXh0ZXJuYWwgXCJAdHJ1ZmZsZS9leHBlY3RcIiIsImxpYi9zZXNzaW9uL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiIiwibGliL3N0b3JlL2luZGV4LmpzIiwibGliL3N0b3JlL3Byb2R1Y3Rpb24uanMiLCJsaWIvc3RvcmUvY29tbW9uLmpzIiwiZXh0ZXJuYWwgXCJyZWR1eC1zYWdhXCIiLCJleHRlcm5hbCBcInJlZHV4LWNsaS1sb2dnZXJcIiIsIi9Vc2Vycy9jcnV6bW9saW5hL0NvZGUvdHJ1ZmZsZS1wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiLCIvVXNlcnMvY3J1em1vbGluYS9Db2RlL3RydWZmbGUtcHJvamVjdHMvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9jcnV6bW9saW5hL0NvZGUvdHJ1ZmZsZS1wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qcyIsIi9Vc2Vycy9jcnV6bW9saW5hL0NvZGUvdHJ1ZmZsZS1wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9zdHJpbmdpZnkuanMiLCJleHRlcm5hbCBcIkB0cnVmZmxlL3NvbGlkaXR5LXV0aWxzXCIiLCJleHRlcm5hbCBcIkB0cnVmZmxlL2NvZGUtdXRpbHNcIiIsIi9Vc2Vycy9jcnV6bW9saW5hL0NvZGUvdHJ1ZmZsZS1wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9ub2RlLWludGVydmFsLXRyZWUvbGliL2luZGV4LmpzIiwiL1VzZXJzL2NydXptb2xpbmEvQ29kZS90cnVmZmxlLXByb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qcyIsImxpYi93ZWIzL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvd2ViMy9hZGFwdGVyLmpzIiwiZXh0ZXJuYWwgXCJ1dGlsXCIiLCJleHRlcm5hbCBcImxvZGFzaC5zdW1cIiIsImxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwibGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImxpYi9zZXNzaW9uL3JlZHVjZXJzLmpzIiwibGliL2RhdGEvcmVkdWNlcnMuanMiLCJsaWIvZXZtL3JlZHVjZXJzLmpzIiwibGliL3NvbGlkaXR5L3JlZHVjZXJzLmpzIiwibGliL3RyYWNlL3JlZHVjZXJzLmpzIiwibGliL2NvbnRyb2xsZXIvcmVkdWNlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJEZWJ1Z2dlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEZWJ1Z2dlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEZWJ1Z2dlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGIwZTg1ZmZlYzNkYTQ2NGEwYTI3IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZGVidWdcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJkZWJ1Z1wiXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuXG5jb25zdCBzdHJpbmdpZnkgPSByZXF1aXJlKFwianNvbi1zdGFibGUtc3RyaW5naWZ5XCIpO1xuXG4vKiogQVNUIG5vZGUgdHlwZXMgdGhhdCBhcmUgc2tpcHBlZCBieSBzdGVwTmV4dCgpIHRvIGZpbHRlciBvdXQgc29tZSBub2lzZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVsaWJlcmF0ZWx5U2tpcHBlZE5vZGVUeXBlKG5vZGUpIHtcbiAgY29uc3Qgc2tpcHBlZFR5cGVzID0gW1wiQ29udHJhY3REZWZpbml0aW9uXCIsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiXTtcbiAgcmV0dXJuIHNraXBwZWRUeXBlcy5pbmNsdWRlcyhub2RlLm5vZGVUeXBlKTtcbn1cblxuLy9IQUNLXG4vL3RoZXNlIGFyZW4ndCB0aGUgb25seSB0eXBlcyBvZiBza2lwcGVkIG5vZGVzLCBidXQgZGV0ZXJtaW5pbmcgYWxsIHNraXBwZWRcbi8vbm9kZXMgd291bGQgYmUgdG9vIGRpZmZpY3VsdFxuZXhwb3J0IGZ1bmN0aW9uIGlzU2tpcHBlZE5vZGVUeXBlKG5vZGUpIHtcbiAgY29uc3Qgb3RoZXJTa2lwcGVkVHlwZXMgPSBbXCJWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50XCIsIFwiTWFwcGluZ1wiXTtcbiAgcmV0dXJuIChcbiAgICBpc0RlbGliZXJhdGVseVNraXBwZWROb2RlVHlwZShub2RlKSB8fFxuICAgIG90aGVyU2tpcHBlZFR5cGVzLmluY2x1ZGVzKG5vZGUubm9kZVR5cGUpIHx8XG4gICAgbm9kZS5ub2RlVHlwZS5pbmNsdWRlcyhcIlR5cGVOYW1lXCIpIHx8IC8vSEFDS1xuICAgIC8vc2tpcCBzdHJpbmcgbGl0ZXJhbHMgdG9vIC0tIHdlJ2xsIGhhbmRsZSB0aGF0IG1hbnVhbGx5XG4gICAgKG5vZGUudHlwZURlc2NyaXB0aW9ucyAhPT0gdW5kZWZpbmVkICYmIC8vc2VlbXMgdGhpcyBzb21ldGltZXMgaGFwcGVucz9cbiAgICAgIHV0aWxzLkRlZmluaXRpb24udHlwZUNsYXNzKG5vZGUpID09PSBcInN0cmluZ2xpdGVyYWxcIilcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeE5hbWUocHJlZml4LCBmbikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIFwibmFtZVwiLCB7XG4gICAgdmFsdWU6IGAke3ByZWZpeH0uJHtmbi5uYW1lfWAsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLypcbiAqIGV4dHJhY3QgdGhlIHByaW1hcnkgc291cmNlIGZyb20gYSBzb3VyY2UgbWFwXG4gKiAoaS5lLiwgdGhlIHNvdXJjZSBmb3IgdGhlIGZpcnN0IGluc3RydWN0aW9uLCBmb3VuZFxuICogYmV0d2VlbiB0aGUgc2Vjb25kIGFuZCB0aGlyZCBjb2xvbnMpXG4gKiAodGhpcyBpcyBzb21ldGhpbmcgb2YgYSBIQUNLKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFByaW1hcnlTb3VyY2Uoc291cmNlTWFwKSB7XG4gIHJldHVybiBwYXJzZUludChzb3VyY2VNYXAubWF0Y2goL15bXjpdKzpbXjpdKzooW146XSspOi8pWzFdKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJuIDB4LXByZWZpeCBzdHJpbmcgb2Yga2VjY2FrMjU2IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NiguLi5hcmdzKSB7XG4gIHJldHVybiB1dGlscy5Db252ZXJzaW9uLnRvSGV4U3RyaW5nKHV0aWxzLkVWTS5rZWNjYWsyNTYoLi4uYXJncykpO1xufVxuXG4vKipcbiAqIEdpdmVuIGFuIG9iamVjdCwgcmV0dXJuIGEgc3RhYmxlIGhhc2ggYnkgZmlyc3QgcnVubmluZyBpdCB0aHJvdWdoIGEgc3RhYmxlXG4gKiBzdHJpbmdpZnkgb3BlcmF0aW9uIGJlZm9yZSBoYXNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFibGVLZWNjYWsyNTYob2JqKSB7XG4gIHJldHVybiBrZWNjYWsyNTYoeyB0eXBlOiBcInN0cmluZ1wiLCB2YWx1ZTogc3RyaW5naWZ5KG9iaikgfSk7XG59XG5cbi8qXG4gKiB1c2VkIGJ5IGRhdGE7IHRha2VzIGFuIGlkIG9iamVjdCBhbmQgYSByZWYgKHBvaW50ZXIpIGFuZCByZXR1cm5zIGEgZnVsbFxuICogY29ycmVzcG9uZGluZyBhc3NpZ25tZW50IG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUFzc2lnbm1lbnQoaWRPYmosIHJlZikge1xuICBsZXQgaWQgPSBzdGFibGVLZWNjYWsyNTYoaWRPYmopO1xuICByZXR1cm4geyAuLi5pZE9iaiwgaWQsIHJlZiB9O1xufVxuXG4vKlxuICogR2l2ZW4gYSBtbWVtb25pYywgZGV0ZXJtaW5lIHdoZXRoZXIgaXQncyB0aGUgbW5lbW9uaWMgb2YgYSBjYWxsaW5nXG4gKiBpbnN0cnVjdGlvbiAoZG9lcyBOT1QgaW5jbHVkZSBjcmVhdGlvbiBpbnN0cnVjdGlvbnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxNbmVtb25pYyhvcCkge1xuICBjb25zdCBjYWxscyA9IFtcIkNBTExcIiwgXCJERUxFR0FURUNBTExcIiwgXCJTVEFUSUNDQUxMXCIsIFwiQ0FMTENPREVcIl07XG4gIHJldHVybiBjYWxscy5pbmNsdWRlcyhvcCk7XG59XG5cbi8qXG4gKiByZXR1cm5zIHRydWUgZm9yIG1uZW1vbmljcyBmb3IgY2FsbHMgdGhhdCB0YWtlIG9ubHkgNiBhcmdzIGluc3RlYWQgb2YgN1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTaG9ydENhbGxNbmVtb25pYyhvcCkge1xuICBjb25zdCBzaG9ydENhbGxzID0gW1wiREVMRUdBVEVDQUxMXCIsIFwiU1RBVElDQ0FMTFwiXTtcbiAgcmV0dXJuIHNob3J0Q2FsbHMuaW5jbHVkZXMob3ApO1xufVxuXG4vKlxuICogcmV0dXJucyB0cnVlIGZvciBtbmVtb25pY3MgZm9yIGNhbGxzIHRoYXQgZGVsZWdhdGUgc3RvcmFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWxlZ2F0ZUNhbGxNbmVtb25pY0Jyb2FkKG9wKSB7XG4gIGNvbnN0IGRlbGVnYXRlQ2FsbHMgPSBbXCJERUxFR0FURUNBTExcIiwgXCJDQUxMQ09ERVwiXTtcbiAgcmV0dXJuIGRlbGVnYXRlQ2FsbHMuaW5jbHVkZXMob3ApO1xufVxuXG4vKlxuICogcmV0dXJucyB0cnVlIGZvciBtbmVtb25pY3MgZm9yIGNhbGxzIHRoYXQgZGVsZWdhdGUgZXZlcnl0aGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWxlZ2F0ZUNhbGxNbmVtb25pY1N0cmljdChvcCkge1xuICBjb25zdCBkZWxlZ2F0ZUNhbGxzID0gW1wiREVMRUdBVEVDQUxMXCJdO1xuICByZXR1cm4gZGVsZWdhdGVDYWxscy5pbmNsdWRlcyhvcCk7XG59XG5cbi8qXG4gKiByZXR1cm5zIHRydWUgZm9yIG1uZW1vbmljcyBmb3Igc3RhdGljIGNhbGxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0YXRpY0NhbGxNbmVtb25pYyhvcCkge1xuICBjb25zdCBkZWxlZ2F0ZUNhbGxzID0gW1wiU1RBVElDQ0FMTFwiXTtcbiAgcmV0dXJuIGRlbGVnYXRlQ2FsbHMuaW5jbHVkZXMob3ApO1xufVxuXG4vKlxuICogR2l2ZW4gYSBtbWVtb25pYywgZGV0ZXJtaW5lIHdoZXRoZXIgaXQncyB0aGUgbW5lbW9uaWMgb2YgYSBjcmVhdGlvblxuICogaW5zdHJ1Y3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ3JlYXRlTW5lbW9uaWMob3ApIHtcbiAgY29uc3QgY3JlYXRlcyA9IFtcIkNSRUFURVwiLCBcIkNSRUFURTJcIl07XG4gIHJldHVybiBjcmVhdGVzLmluY2x1ZGVzKG9wKTtcbn1cblxuLypcbiAqIEdpdmVuIGEgbW1lbW9uaWMsIGRldGVybWluZSB3aGV0aGVyIGl0J3MgdGhlIG1uZW1vbmljIG9mIGEgbm9ybWFsXG4gKiBoYWx0aW5nIGluc3RydWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vcm1hbEhhbHRpbmdNbmVtb25pYyhvcCkge1xuICBjb25zdCBoYWx0cyA9IFtcIlNUT1BcIiwgXCJSRVRVUk5cIiwgXCJTRUxGREVTVFJVQ1RcIiwgXCJTVUlDSURFXCJdO1xuICAvL3RoZSBtbmVtb25pYyBTVUlDSURFIGlzIG5vIGxvbmdlciB1c2VkLCBidXQganVzdCBpbiBjYXNlLCBJJ20gaW5jbHVkaW5nIGl0XG4gIHJldHVybiBoYWx0cy5pbmNsdWRlcyhvcCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2hlbHBlcnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCJcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVzZWxlY3QtdHJlZVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlc2VsZWN0LXRyZWVcIlxuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtc2FnYS9lZmZlY3RzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVkdXgtc2FnYS9lZmZlY3RzXCJcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzXCJcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXhcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eFwiXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ25cIlxuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZXZtOnNlbGVjdG9yc1wiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuaW1wb3J0IEJOIGZyb20gXCJibi5qc1wiO1xuXG5pbXBvcnQgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0ICogYXMgRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5pbXBvcnQge1xuICBpc0NhbGxNbmVtb25pYyxcbiAgaXNDcmVhdGVNbmVtb25pYyxcbiAgaXNTaG9ydENhbGxNbmVtb25pYyxcbiAgaXNEZWxlZ2F0ZUNhbGxNbmVtb25pY0Jyb2FkLFxuICBpc0RlbGVnYXRlQ2FsbE1uZW1vbmljU3RyaWN0LFxuICBpc1N0YXRpY0NhbGxNbmVtb25pYyxcbiAgaXNOb3JtYWxIYWx0aW5nTW5lbW9uaWNcbn0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbi8qKlxuICogY3JlYXRlIEVWTS1sZXZlbCBzZWxlY3RvcnMgZm9yIGEgZ2l2ZW4gdHJhY2Ugc3RlcCBzZWxlY3RvclxuICogbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBzZWxlY3RvcnMgdG8gaW5jbHVkZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdGVwU2VsZWN0b3JzKHN0ZXAsIHN0YXRlID0gbnVsbCkge1xuICBsZXQgYmFzZSA9IHtcbiAgICAvKipcbiAgICAgKiAudHJhY2VcbiAgICAgKlxuICAgICAqIHRyYWNlIHN0ZXAgaW5mbyByZWxhdGVkIHRvIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRyYWNlOiBjcmVhdGVMZWFmKFtzdGVwXSwgc3RlcCA9PiB7XG4gICAgICBpZiAoIXN0ZXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgeyBnYXNDb3N0LCBvcCwgcGMgfSA9IHN0ZXA7XG4gICAgICByZXR1cm4geyBnYXNDb3N0LCBvcCwgcGMgfTtcbiAgICB9KSxcblxuICAgIC8qKlxuICAgICAqIC5wcm9ncmFtQ291bnRlclxuICAgICAqL1xuICAgIHByb2dyYW1Db3VudGVyOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT4gKHN0ZXAgPyBzdGVwLnBjIDogbnVsbCkpLFxuXG4gICAgLyoqXG4gICAgICogLmlzSnVtcFxuICAgICAqL1xuICAgIGlzSnVtcDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJhY2VcIl0sXG4gICAgICBzdGVwID0+IHN0ZXAub3AgIT0gXCJKVU1QREVTVFwiICYmIHN0ZXAub3AuaW5kZXhPZihcIkpVTVBcIikgPT0gMFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNDYWxsXG4gICAgICpcbiAgICAgKiB3aGV0aGVyIHRoZSBvcGNvZGUgd2lsbCBzd2l0Y2ggdG8gYW5vdGhlciBjYWxsaW5nIGNvbnRleHRcbiAgICAgKi9cbiAgICBpc0NhbGw6IGNyZWF0ZUxlYWYoW1wiLi90cmFjZVwiXSwgc3RlcCA9PiBpc0NhbGxNbmVtb25pYyhzdGVwLm9wKSksXG5cbiAgICAvKipcbiAgICAgKiAuaXNTaG9ydENhbGxcbiAgICAgKlxuICAgICAqIGZvciBjYWxscyB0aGF0IG9ubHkgdGFrZSA2IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIDdcbiAgICAgKi9cbiAgICBpc1Nob3J0Q2FsbDogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IGlzU2hvcnRDYWxsTW5lbW9uaWMoc3RlcC5vcCkpLFxuXG4gICAgLyoqXG4gICAgICogLmlzRGVsZWdhdGVDYWxsQnJvYWRcbiAgICAgKlxuICAgICAqIGZvciBjYWxscyB0aGF0IGRlbGVnYXRlIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBpc0RlbGVnYXRlQ2FsbEJyb2FkOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT5cbiAgICAgIGlzRGVsZWdhdGVDYWxsTW5lbW9uaWNCcm9hZChzdGVwLm9wKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNEZWxlZ2F0ZUNhbGxTdHJpY3RcbiAgICAgKlxuICAgICAqIGZvciBjYWxscyB0aGF0IGFkZGl0aW9uYWxseSBkZWxlZ2F0ZSBzZW5kZXIgYW5kIHZhbHVlXG4gICAgICovXG4gICAgaXNEZWxlZ2F0ZUNhbGxTdHJpY3Q6IGNyZWF0ZUxlYWYoW1wiLi90cmFjZVwiXSwgc3RlcCA9PlxuICAgICAgaXNEZWxlZ2F0ZUNhbGxNbmVtb25pY1N0cmljdChzdGVwLm9wKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNTdGF0aWNDYWxsXG4gICAgICovXG4gICAgaXNTdGF0aWNDYWxsOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT5cbiAgICAgIGlzU3RhdGljQ2FsbE1uZW1vbmljKHN0ZXAub3ApXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0NyZWF0ZVxuICAgICAqL1xuICAgIGlzQ3JlYXRlOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT4gaXNDcmVhdGVNbmVtb25pYyhzdGVwLm9wKSksXG5cbiAgICAvKipcbiAgICAgKiAuaXNIYWx0aW5nXG4gICAgICpcbiAgICAgKiB3aGV0aGVyIHRoZSBpbnN0cnVjdGlvbiBoYWx0cyBvciByZXR1cm5zIGZyb20gYSBjYWxsaW5nIGNvbnRleHRcbiAgICAgKiBOT1RFOiB0aGlzIGNvdmVycyBvbmx5IG9yZGluYXJ5IGhhbHRzLCBub3QgZXhjZXB0aW9uYWwgaGFsdHM7XG4gICAgICogYnV0IGl0IGRvZXNuJ3QgY2hlY2sgdGhlIHJldHVybiBzdGF0dXMsIHNvIGFueSBub3JtYWwgaGFsdGluZ1xuICAgICAqIGluc3RydWN0aW9uIHdpbGwgcXVhbGlmeSBoZXJlXG4gICAgICovXG4gICAgaXNIYWx0aW5nOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT5cbiAgICAgIGlzTm9ybWFsSGFsdGluZ01uZW1vbmljKHN0ZXAub3ApXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogLmlzU3RvcmVcbiAgICAgKi9cbiAgICBpc1N0b3JlOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT4gc3RlcC5vcCA9PSBcIlNTVE9SRVwiKSxcblxuICAgIC8qXG4gICAgICogLmlzTG9hZFxuICAgICAqL1xuICAgIGlzTG9hZDogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IHN0ZXAub3AgPT0gXCJTTE9BRFwiKSxcblxuICAgIC8qXG4gICAgICogLnRvdWNoZXNTdG9yYWdlXG4gICAgICpcbiAgICAgKiB3aGV0aGVyIHRoZSBpbnN0cnVjdGlvbiBpbnZvbHZlcyBzdG9yYWdlXG4gICAgICovXG4gICAgdG91Y2hlc1N0b3JhZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2lzU3RvcmVcIiwgXCJpc0xvYWRcIl0sXG4gICAgICAoc3RvcmVzLCBsb2FkcykgPT4gc3RvcmVzIHx8IGxvYWRzXG4gICAgKVxuICB9O1xuXG4gIGlmIChzdGF0ZSkge1xuICAgIGNvbnN0IGlzUmVsYXRpdmUgPSBwYXRoID0+XG4gICAgICB0eXBlb2YgcGF0aCA9PSBcInN0cmluZ1wiICYmXG4gICAgICAocGF0aC5zdGFydHNXaXRoKFwiLi9cIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpKTtcblxuICAgIGlmIChpc1JlbGF0aXZlKHN0YXRlKSkge1xuICAgICAgc3RhdGUgPSBgLi4vJHtzdGF0ZX1gO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oYmFzZSwge1xuICAgICAgLyoqXG4gICAgICAgKiAuY2FsbEFkZHJlc3NcbiAgICAgICAqXG4gICAgICAgKiBhZGRyZXNzIHRyYW5zZmVycmVkIHRvIGJ5IGNhbGwgb3BlcmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGNhbGxBZGRyZXNzOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL2lzQ2FsbFwiLCBzdGF0ZV0sXG5cbiAgICAgICAgKGlzQ2FsbCwgeyBzdGFjayB9KSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0NhbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBhZGRyZXNzID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl07XG4gICAgICAgICAgcmV0dXJuIERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIC5jcmVhdGVCaW5hcnlcbiAgICAgICAqXG4gICAgICAgKiBiaW5hcnkgY29kZSB0byBleGVjdXRlIHZpYSBjcmVhdGUgb3BlcmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZUJpbmFyeTogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NyZWF0ZVwiLCBzdGF0ZV0sXG5cbiAgICAgICAgKGlzQ3JlYXRlLCB7IHN0YWNrLCBtZW1vcnkgfSkgPT4ge1xuICAgICAgICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEdldCB0aGUgY29kZSB0aGF0J3MgZ29pbmcgdG8gYmUgY3JlYXRlZCBmcm9tIG1lbW9yeS5cbiAgICAgICAgICAvLyBOb3RlIHdlIG11bHRpcGx5IGJ5IDIgYmVjYXVzZSB0aGVzZSBvZmZzZXRzIGFyZSBpbiBieXRlcy5cbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwYXJzZUludChzdGFja1tzdGFjay5sZW5ndGggLSAyXSwgMTYpICogMjtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChzdGFja1tzdGFjay5sZW5ndGggLSAzXSwgMTYpICogMjtcblxuICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBtZW1vcnkuam9pbihcIlwiKS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIC5jYWxsRGF0YVxuICAgICAgICpcbiAgICAgICAqIGRhdGEgcGFzc2VkIHRvIEVWTSBjYWxsXG4gICAgICAgKi9cbiAgICAgIGNhbGxEYXRhOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL2lzQ2FsbFwiLCBcIi4vaXNTaG9ydENhbGxcIiwgc3RhdGVdLFxuICAgICAgICAoaXNDYWxsLCBzaG9ydCwgeyBzdGFjaywgbWVtb3J5IH0pID0+IHtcbiAgICAgICAgICBpZiAoIWlzQ2FsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9pZiBpdCdzIDYtYXJndW1lbnQgY2FsbCwgdGhlIGRhdGEgc3RhcnQgYW5kIG9mZnNldCB3aWxsIGJlIG9uZSBzcG90XG4gICAgICAgICAgLy9oaWdoZXIgaW4gdGhlIHN0YWNrIHRoYW4gdGhleSB3b3VsZCBiZSBmb3IgYSA3LWFyZ3VtZW50IGNhbGwsIHNvXG4gICAgICAgICAgLy9sZXQncyBpbnRyb2R1Y2UgYW4gb2Zmc2V0IHRvIGhhbmRsZSB0aGlzXG4gICAgICAgICAgbGV0IGFyZ09mZnNldCA9IHNob3J0ID8gMSA6IDA7XG5cbiAgICAgICAgICAvLyBHZXQgdGhlIGRhdGEgZnJvbSBtZW1vcnkuXG4gICAgICAgICAgLy8gTm90ZSB3ZSBtdWx0aXBseSBieSAyIGJlY2F1c2UgdGhlc2Ugb2Zmc2V0cyBhcmUgaW4gYnl0ZXMuXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQoc3RhY2tbc3RhY2subGVuZ3RoIC0gNCArIGFyZ09mZnNldF0sIDE2KSAqIDI7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoc3RhY2tbc3RhY2subGVuZ3RoIC0gNSArIGFyZ09mZnNldF0sIDE2KSAqIDI7XG5cbiAgICAgICAgICByZXR1cm4gXCIweFwiICsgbWVtb3J5LmpvaW4oXCJcIikuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuY2FsbFZhbHVlXG4gICAgICAgKlxuICAgICAgICogdmFsdWUgZm9yIHRoZSBjYWxsIChub3QgY3JlYXRlKTsgcmV0dXJucyBudWxsIGZvciBERUxFR0FURUNBTExcbiAgICAgICAqL1xuICAgICAgY2FsbFZhbHVlOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL2lzQ2FsbFwiLCBcIi4vaXNEZWxlZ2F0ZUNhbGxTdHJpY3RcIiwgXCIuL2lzU3RhdGljQ2FsbFwiLCBzdGF0ZV0sXG4gICAgICAgIChjYWxscywgZGVsZWdhdGVzLCBpc1N0YXRpYywgeyBzdGFjayB9KSA9PiB7XG4gICAgICAgICAgaWYgKCFjYWxscyB8fCBkZWxlZ2F0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCTigwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL290aGVyd2lzZSwgZm9yIENBTEwgYW5kIENBTExDT0RFLCBpdCdzIHRoZSAzcmQgYXJndW1lbnRcbiAgICAgICAgICBsZXQgdmFsdWUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAzXTtcbiAgICAgICAgICByZXR1cm4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0JOKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuY3JlYXRlVmFsdWVcbiAgICAgICAqXG4gICAgICAgKiB2YWx1ZSBmb3IgdGhlIGNyZWF0ZVxuICAgICAgICovXG4gICAgICBjcmVhdGVWYWx1ZTogY3JlYXRlTGVhZihbXCIuL2lzQ3JlYXRlXCIsIHN0YXRlXSwgKGlzQ3JlYXRlLCB7IHN0YWNrIH0pID0+IHtcbiAgICAgICAgaWYgKCFpc0NyZWF0ZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jcmVhdGVzIGhhdmUgdGhlIHZhbHVlIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAgICBsZXQgdmFsdWUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CTih2YWx1ZSk7XG4gICAgICB9KSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuc3RvcmFnZUFmZmVjdGVkXG4gICAgICAgKlxuICAgICAgICogc3RvcmFnZSBzbG90IGJlaW5nIHN0b3JlZCB0byBvciBsb2FkZWQgZnJvbVxuICAgICAgICogd2UgZG8gTk9UIHByZXBlbmQgXCIweFwiXG4gICAgICAgKi9cbiAgICAgIHN0b3JhZ2VBZmZlY3RlZDogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi90b3VjaGVzU3RvcmFnZVwiLCBzdGF0ZV0sXG5cbiAgICAgICAgKHRvdWNoZXNTdG9yYWdlLCB7IHN0YWNrIH0pID0+IHtcbiAgICAgICAgICBpZiAoIXRvdWNoZXNTdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIC8qXG4gICAgICAgKiAucmV0dXJuVmFsdWVcbiAgICAgICAqXG4gICAgICAgKiBmb3IgYSBSRVRVUk4gaW5zdHJ1Y3Rpb24sIHRoZSB2YWx1ZSByZXR1cm5lZFxuICAgICAgICogd2UgRE8gcHJlcGVuZCBcIjB4XCJcbiAgICAgICAqICh3aWxsIGFsc28gcmV0dXJuIFwiMHhcIiBmb3IgU1RPUCBvciBTRUxGREVTVFJVQ1QgYnV0XG4gICAgICAgKiBudWxsIG90aGVyd2lzZSlcbiAgICAgICAqL1xuICAgICAgcmV0dXJuVmFsdWU6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vdHJhY2VcIiwgXCIuL2lzSGFsdGluZ1wiLCBzdGF0ZV0sXG5cbiAgICAgICAgKHN0ZXAsIGlzSGFsdGluZywgeyBzdGFjaywgbWVtb3J5IH0pID0+IHtcbiAgICAgICAgICBpZiAoIWlzSGFsdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGVwLm9wICE9PSBcIlJFVFVSTlwiKSB7XG4gICAgICAgICAgICAvL1NUT1AgYW5kIFNFTEZERVNUUlVDVCByZXR1cm4gZW1wdHkgdmFsdWVcbiAgICAgICAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIG1lbW9yeS5cbiAgICAgICAgICAvLyBOb3RlIHdlIG11bHRpcGx5IGJ5IDIgYmVjYXVzZSB0aGVzZSBvZmZzZXRzIGFyZSBpbiBieXRlcy5cbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwYXJzZUludChzdGFja1tzdGFjay5sZW5ndGggLSAxXSwgMTYpICogMjtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChzdGFja1tzdGFjay5sZW5ndGggLSAyXSwgMTYpICogMjtcblxuICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBtZW1vcnkuam9pbihcIlwiKS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn1cblxuY29uc3QgZXZtID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGV2bS5zdGF0ZVxuICAgKi9cbiAgc3RhdGU6IHN0YXRlID0+IHN0YXRlLmV2bSxcblxuICAvKipcbiAgICogZXZtLmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBldm0uaW5mby5jb250ZXh0c1xuICAgICAqL1xuICAgIGNvbnRleHRzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaW5mby5jb250ZXh0cy5ieUNvbnRleHQpLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmluZm8uYmluYXJpZXNcbiAgICAgKi9cbiAgICBiaW5hcmllczoge1xuICAgICAgLyoqXG4gICAgICAgKiBldm0uaW5mby5iaW5hcmllcy5zZWFyY2hcbiAgICAgICAqXG4gICAgICAgKiByZXR1cm5zIGZ1bmN0aW9uIChiaW5hcnkpID0+IGNvbnRleHQgKHJldHVybnMgdGhlICpJRCogb2YgdGhlIGNvbnRleHQpXG4gICAgICAgKiAocmV0dXJucyBudWxsIG9uIG5vIG1hdGNoKVxuICAgICAgICovXG4gICAgICBzZWFyY2g6IGNyZWF0ZUxlYWYoW1wiL2luZm8vY29udGV4dHNcIl0sIGNvbnRleHRzID0+IGJpbmFyeSA9PlxuICAgICAgICBEZWNvZGVVdGlscy5Db250ZXh0cy5maW5kRGVidWdnZXJDb250ZXh0KGNvbnRleHRzLCBiaW5hcnkpXG4gICAgICApXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBldm0udHJhbnNhY3Rpb25cbiAgICovXG4gIHRyYW5zYWN0aW9uOiB7XG4gICAgLypcbiAgICAgKiBldm0udHJhbnNhY3Rpb24uZ2xvYmFsc1xuICAgICAqL1xuICAgIGdsb2JhbHM6IHtcbiAgICAgIC8qXG4gICAgICAgKiBldm0udHJhbnNhY3Rpb24uZ2xvYmFscy50eFxuICAgICAgICovXG4gICAgICB0eDogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLnRyYW5zYWN0aW9uLmdsb2JhbHMudHgpLFxuICAgICAgLypcbiAgICAgICAqIGV2bS50cmFuc2FjdGlvbi5nbG9iYWxzLmJsb2NrXG4gICAgICAgKi9cbiAgICAgIGJsb2NrOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUudHJhbnNhY3Rpb24uZ2xvYmFscy5ibG9jaylcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBldm0udHJhbnNhY3Rpb24uc3RhdHVzXG4gICAgICovXG4gICAgc3RhdHVzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUudHJhbnNhY3Rpb24uc3RhdHVzKSxcblxuICAgIC8qXG4gICAgICogZXZtLnRyYW5zYWN0aW9uLmluaXRpYWxDYWxsXG4gICAgICovXG4gICAgaW5pdGlhbENhbGw6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS50cmFuc2FjdGlvbi5pbml0aWFsQ2FsbClcbiAgfSxcblxuICAvKipcbiAgICogZXZtLmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jYWxsc3RhY2tcbiAgICAgKi9cbiAgICBjYWxsc3RhY2s6IHN0YXRlID0+IHN0YXRlLmV2bS5wcm9jLmNhbGxzdGFjayxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LmNhbGxcbiAgICAgKi9cbiAgICBjYWxsOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9jYWxsc3RhY2tcIl0sXG5cbiAgICAgIHN0YWNrID0+IChzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA6IHt9KVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jb250ZXh0XG4gICAgICovXG4gICAgY29udGV4dDogY3JlYXRlTGVhZihcbiAgICAgIFtcbiAgICAgICAgXCIuL2NhbGxcIixcbiAgICAgICAgXCIuL2NvZGV4L2luc3RhbmNlc1wiLFxuICAgICAgICBcIi9pbmZvL2JpbmFyaWVzL3NlYXJjaFwiLFxuICAgICAgICBcIi9pbmZvL2NvbnRleHRzXCJcbiAgICAgIF0sXG4gICAgICAoeyBhZGRyZXNzLCBiaW5hcnkgfSwgaW5zdGFuY2VzLCBzZWFyY2gsIGNvbnRleHRzKSA9PiB7XG4gICAgICAgIGxldCBjb250ZXh0SWQ7XG4gICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgLy9pZiB3ZSdyZSBpbiBhIGNhbGwgdG8gYSBkZXBsb3llZCBjb250cmFjdCwgd2UgbXVzdCBoYXZlIHJlY29yZGVkXG4gICAgICAgICAgLy90aGUgY29udGV4dCBpbiB0aGUgY29kZXgsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55IGZ1cnRoZXJcbiAgICAgICAgICAvL3NlYXJjaGluZ1xuICAgICAgICAgICh7IGNvbnRleHQ6IGNvbnRleHRJZCwgYmluYXJ5IH0gPSBpbnN0YW5jZXNbYWRkcmVzc10pO1xuICAgICAgICB9IGVsc2UgaWYgKGJpbmFyeSkge1xuICAgICAgICAgIC8vb3RoZXJ3aXNlLCBpZiB3ZSdyZSBpbiBhIGNvbnN0cnVjdG9yLCB3ZSdsbCBuZWVkIHRvIGFjdHVhbGx5IGRvIGFcbiAgICAgICAgICAvL3NlYXJjaFxuICAgICAgICAgIGNvbnRleHRJZCA9IHNlYXJjaChiaW5hcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vZXhjZXB0aW9uYWwgY2FzZTogbm8gdHJhbnNhY3Rpb24gaXMgbG9hZGVkXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dElkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vaWYgd2UgZm91bmQgdGhlIGNvbnRleHQsIHVzZSBpdFxuICAgICAgICAgIGxldCBjb250ZXh0ID0gY29udGV4dHNbY29udGV4dElkXTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIGJpbmFyeVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9vdGhlcndpc2Ugd2UnbGwgY29uc3RydWN0IHNvbWV0aGluZyBkZWZhdWx0XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJpbmFyeSxcbiAgICAgICAgICAgIGlzQ29uc3RydWN0b3I6IGFkZHJlc3MgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgLy9XQVJOSU5HOiB3ZSd2ZSBtdXRhdGVkIGJpbmFyeSBoZXJlLCBzb1xuICAgICAgICAgICAgLy9pbnN0ZWFkIHdlIGdvIGJ5IHdoZXRoZXIgYWRkcmVzcyBpcyB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LnN0YXRlXG4gICAgICpcbiAgICAgKiBldm0gc3RhdGUgaW5mbzogYXMgb2YgbGFzdCBvcGVyYXRpb24sIGJlZm9yZSBvcCBkZWZpbmVkIGluIHN0ZXBcbiAgICAgKi9cbiAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgLi4uW1wiZGVwdGhcIiwgXCJlcnJvclwiLCBcImdhc1wiLCBcIm1lbW9yeVwiLCBcInN0YWNrXCIsIFwic3RvcmFnZVwiXS5tYXAocGFyYW0gPT4gKHtcbiAgICAgICAgW3BhcmFtXTogY3JlYXRlTGVhZihbdHJhY2Uuc3RlcF0sIHN0ZXAgPT4gc3RlcFtwYXJhbV0pXG4gICAgICB9KSlcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuc3RlcFxuICAgICAqL1xuICAgIHN0ZXA6IHtcbiAgICAgIC4uLmNyZWF0ZVN0ZXBTZWxlY3RvcnModHJhY2Uuc3RlcCwgXCIuL3N0YXRlXCIpLFxuXG4gICAgICAvL3RoZSBmb2xsb3dpbmcgc3RlcCBzZWxlY3RvcnMgb25seSBleGlzdCBmb3IgY3VycmVudCwgbm90IG5leHQgb3IgYW55XG4gICAgICAvL290aGVyIHN0ZXBcblxuICAgICAgLypcbiAgICAgICAqIGV2bS5jdXJyZW50LnN0ZXAuY3JlYXRlZEFkZHJlc3NcbiAgICAgICAqXG4gICAgICAgKiBhZGRyZXNzIGNyZWF0ZWQgYnkgdGhlIGN1cnJlbnQgY3JlYXRlIHN0ZXBcbiAgICAgICAqL1xuICAgICAgY3JlYXRlZEFkZHJlc3M6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDcmVhdGVcIiwgXCIvbmV4dE9mU2FtZURlcHRoL3N0YXRlL3N0YWNrXCJdLFxuICAgICAgICAoaXNDcmVhdGUsIHN0YWNrKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0NyZWF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBhZGRyZXNzID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgcmV0dXJuIERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGV2bS5jdXJyZW50LnN0ZXAuY2FsbHNQcmVjb21waWxlT3JFeHRlcm5hbFxuICAgICAgICpcbiAgICAgICAqIGFyZSB3ZSBjYWxsaW5nIGEgcHJlY29tcGlsZWQgY29udHJhY3Qgb3IgYW4gZXh0ZXJuYWxseS1vd25lZCBhY2NvdW50LFxuICAgICAgICogcmF0aGVyIHRoYW4gYSBjb250cmFjdCBhY2NvdW50IHRoYXQgaXNuJ3QgcHJlY29tcGlsZWQ/XG4gICAgICAgKi9cbiAgICAgIGNhbGxzUHJlY29tcGlsZU9yRXh0ZXJuYWw6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDYWxsXCIsIFwiL2N1cnJlbnQvc3RhdGUvZGVwdGhcIiwgXCIvbmV4dC9zdGF0ZS9kZXB0aFwiXSxcbiAgICAgICAgKGNhbGxzLCBjdXJyZW50RGVwdGgsIG5leHREZXB0aCkgPT4gY2FsbHMgJiYgY3VycmVudERlcHRoID09PSBuZXh0RGVwdGhcbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogZXZtLmN1cnJlbnQuc3RlcC5pc0NvbnRleHRDaGFuZ2VcbiAgICAgICAqIGdyb3VwcyB0b2dldGhlciBjYWxscywgY3JlYXRlcywgaGFsdHMsIGFuZCBleGNlcHRpb25hbCBoYWx0c1xuICAgICAgICovXG4gICAgICBpc0NvbnRleHRDaGFuZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi9jdXJyZW50L3N0YXRlL2RlcHRoXCIsIFwiL25leHQvc3RhdGUvZGVwdGhcIl0sXG4gICAgICAgIChjdXJyZW50RGVwdGgsIG5leHREZXB0aCkgPT4gY3VycmVudERlcHRoICE9PSBuZXh0RGVwdGhcbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogZXZtLmN1cnJlbnQuc3RlcC5pc0V4Y2VwdGlvbmFsSGFsdGluZ1xuICAgICAgICovXG4gICAgICBpc0V4Y2VwdGlvbmFsSGFsdGluZzogY3JlYXRlTGVhZihcbiAgICAgICAgW1xuICAgICAgICAgIFwiLi9pc0hhbHRpbmdcIixcbiAgICAgICAgICBcIi9jdXJyZW50L3N0YXRlL2RlcHRoXCIsXG4gICAgICAgICAgXCIvbmV4dC9zdGF0ZS9kZXB0aFwiLFxuICAgICAgICAgIFwiLi9yZXR1cm5TdGF0dXNcIlxuICAgICAgICBdLFxuICAgICAgICAoaGFsdGluZywgY3VycmVudERlcHRoLCBuZXh0RGVwdGgsIHN0YXR1cykgPT5cbiAgICAgICAgICBoYWx0aW5nXG4gICAgICAgICAgICA/ICFzdGF0dXMgLy9pZiBkZWxpYmVyYXRlbHkgaGFsdGluZywgY2hlY2sgdGhlIHJldHVybiBzdGF0dXNcbiAgICAgICAgICAgIDogbmV4dERlcHRoIDwgY3VycmVudERlcHRoIC8vaWYgbm90IG9uIGEgZGVsaWJlcmF0ZSBoYWx0LCBhbnkgaGFsdFxuICAgICAgICAvL2lzIGFuIGV4Y2VwdGlvbmFsIGhhbHRcbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogZXZtLmN1cnJlbnQuc3RlcC5yZXR1cm5TdGF0dXNcbiAgICAgICAqIGNoZWNrcyB0aGUgcmV0dXJuIHN0YXR1cyBvZiB0aGUgKmN1cnJlbnQqIGhhbHRpbmcgaW5zdHJ1Y3Rpb24gKGZvclxuICAgICAgICogbm9ybWFsIGhhbHRzIG9ubHkpXG4gICAgICAgKiAocmV0dXJucyBhIGJvb2xlYW4gLS0gdHJ1ZSBmb3Igc3VjY2VzcywgZmFsc2UgZm9yIGZhaWx1cmUpXG4gICAgICAgKi9cbiAgICAgIHJldHVyblN0YXR1czogY3JlYXRlTGVhZihcbiAgICAgICAgW1xuICAgICAgICAgIFwiLi9pc0hhbHRpbmdcIixcbiAgICAgICAgICBcIi9uZXh0L3N0YXRlXCIsXG4gICAgICAgICAgdHJhY2Uuc3RlcHNSZW1haW5pbmcsXG4gICAgICAgICAgXCIvdHJhbnNhY3Rpb24vc3RhdHVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgKGlzSGFsdGluZywgeyBzdGFjayB9LCByZW1haW5pbmcsIGZpbmFsU3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0hhbHRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvL25vdCBjbGVhciB0aGlzJ2xsIGRvIG11Y2ggZ29vZCBzaW5jZSB0aGlzIG1heSBnZXRcbiAgICAgICAgICAgIC8vcmVhZCBhcyBmYWxzZSwgYnV0LCBvaCB3ZWxsLCBtYXkgYXMgd2VsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbFN0YXR1cztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgWkVST19XT1JEID0gXCIwMFwiLnJlcGVhdChEZWNvZGVVdGlscy5FVk0uV09SRF9TSVpFKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSAhPT0gWkVST19XT1JEO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jb2RleCAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIGNvZGV4OiB7XG4gICAgICAvKipcbiAgICAgICAqIGV2bS5jdXJyZW50LmNvZGV4IChzZWxlY3RvcilcbiAgICAgICAqIHRoZSB3aG9sZSBjb2RleCEgbm90IHRoYXQgdGhhdCdzIHZlcnkgbXVjaCBhdCB0aGUgbW9tZW50XG4gICAgICAgKi9cbiAgICAgIF86IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5wcm9jLmNvZGV4KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBldm0uY3VycmVudC5jb2RleC5zdG9yYWdlXG4gICAgICAgKiB0aGUgY3VycmVudCBzdG9yYWdlLCBhcyBmZXRjaGVkIGZyb20gdGhlIGNvZGV4Li4uIHVubGVzcyB3ZSdyZSBpbiBhXG4gICAgICAgKiBmYWlsZWQgY3JlYXRpb24gY2FsbCwgdGhlbiB3ZSBqdXN0IGZhbGwgYmFjayBvbiB0aGUgc3RhdGUgKHdoaWNoIHdpbGxcbiAgICAgICAqIHdvcmssIHNpbmNlIG5vdGhpbmcgZWxzZSBjYW4gaW50ZXJmZXJlIHdpdGggdGhlIHN0b3JhZ2Ugb2YgYSBmYWlsZWRcbiAgICAgICAqIGNyZWF0aW9uIGNhbGwhKVxuICAgICAgICovXG4gICAgICBzdG9yYWdlOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL19cIiwgXCIuLi9zdGF0ZS9zdG9yYWdlXCIsIFwiLi4vY2FsbFwiXSxcbiAgICAgICAgKGNvZGV4LCByYXdTdG9yYWdlLCB7IHN0b3JhZ2VBZGRyZXNzIH0pID0+XG4gICAgICAgICAgc3RvcmFnZUFkZHJlc3MgPT09IERlY29kZVV0aWxzLkVWTS5aRVJPX0FERFJFU1NcbiAgICAgICAgICAgID8gcmF3U3RvcmFnZSAvL0hBQ0sgLS0gaWYgemVybyBhZGRyZXNzIGlnbm9yZSB0aGUgY29kZXhcbiAgICAgICAgICAgIDogY29kZXhbY29kZXgubGVuZ3RoIC0gMV0uYWNjb3VudHNbc3RvcmFnZUFkZHJlc3NdLnN0b3JhZ2VcbiAgICAgICksXG5cbiAgICAgIC8qXG4gICAgICAgKiBldm0uY3VycmVudC5jb2RleC5pbnN0YW5jZXNcbiAgICAgICAqL1xuICAgICAgaW5zdGFuY2VzOiBjcmVhdGVMZWFmKFtcIi4vX1wiXSwgY29kZXggPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhjb2RleFtjb2RleC5sZW5ndGggLSAxXS5hY2NvdW50cykubWFwKFxuICAgICAgICAgICAgKFthZGRyZXNzLCB7IGNvZGUsIGNvbnRleHQgfV0pID0+ICh7XG4gICAgICAgICAgICAgIFthZGRyZXNzXTogeyBhZGRyZXNzLCBiaW5hcnk6IGNvZGUsIGNvbnRleHQgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGV2bS5uZXh0XG4gICAqL1xuICBuZXh0OiB7XG4gICAgLyoqXG4gICAgICogZXZtLm5leHQuc3RhdGVcbiAgICAgKlxuICAgICAqIGV2bSBzdGF0ZSBhcyBhIHJlc3VsdCBvZiBuZXh0IHN0ZXAgb3BlcmF0aW9uXG4gICAgICovXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIC4uLltcImRlcHRoXCIsIFwiZXJyb3JcIiwgXCJnYXNcIiwgXCJtZW1vcnlcIiwgXCJzdGFja1wiLCBcInN0b3JhZ2VcIl0ubWFwKHBhcmFtID0+ICh7XG4gICAgICAgIFtwYXJhbV06IGNyZWF0ZUxlYWYoW3RyYWNlLm5leHRdLCBzdGVwID0+IHN0ZXBbcGFyYW1dKVxuICAgICAgfSkpXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZXZtLm5leHQuc3RlcFxuICAgICAqL1xuICAgIHN0ZXA6IGNyZWF0ZVN0ZXBTZWxlY3RvcnModHJhY2UubmV4dCwgXCIuL3N0YXRlXCIpXG4gIH0sXG5cbiAgLyoqXG4gICAqIGV2bS5uZXh0T2ZTYW1lRGVwdGhcbiAgICovXG4gIG5leHRPZlNhbWVEZXB0aDoge1xuICAgIC8qKlxuICAgICAqIGV2bS5uZXh0T2ZTYW1lRGVwdGguc3RhdGVcbiAgICAgKlxuICAgICAqIGV2bSBzdGF0ZSBhdCB0aGUgbmV4dCBzdGVwIG9mIHNhbWUgZGVwdGhcbiAgICAgKi9cbiAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgLi4uW1wiZGVwdGhcIiwgXCJlcnJvclwiLCBcImdhc1wiLCBcIm1lbW9yeVwiLCBcInN0YWNrXCIsIFwic3RvcmFnZVwiXS5tYXAocGFyYW0gPT4gKHtcbiAgICAgICAgW3BhcmFtXTogY3JlYXRlTGVhZihbdHJhY2UubmV4dE9mU2FtZURlcHRoXSwgc3RlcCA9PiBzdGVwW3BhcmFtXSlcbiAgICAgIH0pKVxuICAgIClcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGV2bTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL3NlbGVjdG9ycy9pbmRleC5qcyIsImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5cbmNvbnN0IFBBU1RfRU5EX09GX1RSQUNFID0ge1xuICBkZXB0aDogLTEsIC8vdGhpcyBpcyB0aGUgcGFydCB0aGF0IG1hdHRlcnMhXG4gIC8vdGhlIHJlc3Qgb2YgdGhpcyBpcyBqdXN0IHRvIGxvb2sgbGlrZSBhIHRyYWNlIHN0ZXBcbiAgZXJyb3I6IFwiXCIsXG4gIGdhczogMCxcbiAgbWVtb3J5OiBbXSxcbiAgc3RhY2s6IFtdLFxuICBzdG9yYWdlOiB7fSxcbiAgZ2FzQ29zdDogMCxcbiAgb3A6IFwiU1RPUFwiLFxuICBwYzogLTEgLy90aGlzIGlzIG5vdCBhdCBhbGwgdmFsaWQgYnV0IHRoYXQncyBmaW5lXG59O1xuXG5sZXQgdHJhY2UgPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogdHJhY2UuaW5kZXhcbiAgICpcbiAgICogY3VycmVudCBzdGVwIGluZGV4XG4gICAqL1xuICBpbmRleDogc3RhdGUgPT4gc3RhdGUudHJhY2UucHJvYy5pbmRleCxcblxuICAvKlxuICAgKiB0cmFjZS5sb2FkZWRcbiAgICogaXMgYSB0cmFjZSBsb2FkZWQ/XG4gICAqL1xuICBsb2FkZWQ6IGNyZWF0ZUxlYWYoW1wiL3N0ZXBzXCJdLCBzdGVwcyA9PiBzdGVwcyAhPT0gbnVsbCksXG5cbiAgLyoqXG4gICAqIHRyYWNlLmZpbmlzaGVkXG4gICAqIGlzIHRoZSB0cmFjZSBmaW5pc2hlZD9cbiAgICovXG4gIGZpbmlzaGVkOiBzdGF0ZSA9PiBzdGF0ZS50cmFjZS5wcm9jLmZpbmlzaGVkLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5maW5pc2hlZE9yVW5sb2FkZWRcbiAgICpcbiAgICogaXMgdGhlIHRyYWNlIGZpbmlzaGVkLCBpbmNsdWRpbmcgaWYgaXQncyB1bmxvYWRlZD9cbiAgICovXG4gIGZpbmlzaGVkT3JVbmxvYWRlZDogY3JlYXRlTGVhZihcbiAgICBbXCIvZmluaXNoZWRcIiwgXCIvbG9hZGVkXCJdLFxuICAgIChmaW5pc2hlZCwgbG9hZGVkKSA9PiBmaW5pc2hlZCB8fCAhbG9hZGVkXG4gICksXG5cbiAgLyoqXG4gICAqIHRyYWNlLnN0ZXBzXG4gICAqXG4gICAqIGFsbCB0cmFjZSBzdGVwc1xuICAgKi9cbiAgc3RlcHM6IHN0YXRlID0+IHN0YXRlLnRyYWNlLnRyYW5zYWN0aW9uLnN0ZXBzLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwc1JlbWFpbmluZ1xuICAgKlxuICAgKiBudW1iZXIgb2Ygc3RlcHMgcmVtYWluaW5nIGluIHRyYWNlXG4gICAqL1xuICBzdGVwc1JlbWFpbmluZzogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSxcbiAgICAoc3RlcHMsIGluZGV4KSA9PiBzdGVwcy5sZW5ndGggLSBpbmRleFxuICApLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwXG4gICAqXG4gICAqIGN1cnJlbnQgdHJhY2Ugc3RlcFxuICAgKi9cbiAgc3RlcDogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSxcbiAgICAoc3RlcHMsIGluZGV4KSA9PiAoc3RlcHMgPyBzdGVwc1tpbmRleF0gOiBudWxsKSAvL251bGwgaWYgbm8gdHggbG9hZGVkXG4gICksXG5cbiAgLyoqXG4gICAqIHRyYWNlLm5leHRcbiAgICpcbiAgICogbmV4dCB0cmFjZSBzdGVwXG4gICAqIEhBQ0s6IGlmIGF0IHRoZSBlbmQsXG4gICAqIHdlIHdpbGwgcmV0dXJuIGEgc3Bvb2ZlZCBcInBhc3QgZW5kXCIgc3RlcFxuICAgKi9cbiAgbmV4dDogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSxcbiAgICAoc3RlcHMsIGluZGV4KSA9PlxuICAgICAgaW5kZXggPCBzdGVwcy5sZW5ndGggLSAxID8gc3RlcHNbaW5kZXggKyAxXSA6IFBBU1RfRU5EX09GX1RSQUNFXG4gICksXG5cbiAgLypcbiAgICogdHJhY2UubmV4dE9mU2FtZURlcHRoXG4gICAqIG5leHQgdHJhY2Ugc3RlcCB0aGF0J3MgYXQgdGhlIHNhbWUgZGVwdGggYXMgdGhpcyBvbmVcbiAgICogTk9URTogaWYgdGhlcmUgaXMgbm9uZSwgd2lsbCByZXR1cm4gdW5kZWZpbmVkXG4gICAqIChzaG91bGQgbm90IGJlIHVzZWQgaW4gc3VjaCBjYXNlcylcbiAgICovXG4gIG5leHRPZlNhbWVEZXB0aDogY3JlYXRlTGVhZihbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSwgKHN0ZXBzLCBpbmRleCkgPT4ge1xuICAgIGxldCBkZXB0aCA9IHN0ZXBzW2luZGV4XS5kZXB0aDtcbiAgICByZXR1cm4gc3RlcHMuc2xpY2UoaW5kZXggKyAxKS5maW5kKHN0ZXAgPT4gc3RlcC5kZXB0aCA9PT0gZGVwdGgpO1xuICB9KVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHRyYWNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9zZWxlY3RvcnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c29saWRpdHk6c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuaW1wb3J0IFNvbGlkaXR5VXRpbHMgZnJvbSBcIkB0cnVmZmxlL3NvbGlkaXR5LXV0aWxzXCI7XG5pbXBvcnQgQ29kZVV0aWxzIGZyb20gXCJAdHJ1ZmZsZS9jb2RlLXV0aWxzXCI7XG5cbmltcG9ydCB7IGZpbmRSYW5nZSB9IGZyb20gXCJsaWIvYXN0L21hcFwiO1xuaW1wb3J0IGpzb25wb2ludGVyIGZyb20gXCJqc29uLXBvaW50ZXJcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NlbGVjdG9yc1wiO1xuXG5mdW5jdGlvbiBnZXRTb3VyY2VSYW5nZShpbnN0cnVjdGlvbiA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGluc3RydWN0aW9uLnN0YXJ0IHx8IDAsXG4gICAgbGVuZ3RoOiBpbnN0cnVjdGlvbi5sZW5ndGggfHwgMCxcbiAgICBsaW5lczogaW5zdHJ1Y3Rpb24ucmFuZ2UgfHwge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY29sdW1uOiAwXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIGxpbmU6IDAsXG4gICAgICAgIGNvbHVtbjogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy9mdW5jdGlvbiB0byBjcmVhdGUgc2VsZWN0b3JzIHRoYXQgbmVlZCBib3RoIGEgY3VycmVudCBhbmQgbmV4dCB2ZXJzaW9uXG5mdW5jdGlvbiBjcmVhdGVNdWx0aXN0ZXBTZWxlY3RvcnMoc3RlcFNlbGVjdG9yKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogLmluc3RydWN0aW9uXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb246IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvY3VycmVudC9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIiwgc3RlcFNlbGVjdG9yLnByb2dyYW1Db3VudGVyXSxcbiAgICAgIC8vSEFDSzogd2UgdXNlIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyXG4gICAgICAvL2V2ZW4gaWYgd2UncmUgbG9va2luZyBhdCBzb2xpZGl0eS5uZXh0LlxuICAgICAgLy9UaGlzIGlzIGhhcm1sZXNzLi4uIHNvIGxvbmcgYXMgdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24gaXNuJ3QgYSBjb250ZXh0XG4gICAgICAvL2NoYW5nZS4gIFNvLCBkb24ndCB1c2Ugc29saWRpdHkubmV4dCB3aGVuIGl0IGlzLlxuXG4gICAgICAobWFwLCBwYykgPT4gbWFwW3BjXSB8fCB7fVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuc291cmNlXG4gICAgICovXG4gICAgc291cmNlOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL2luZm8vc291cmNlc1wiLCBcIi4vaW5zdHJ1Y3Rpb25cIl0sXG5cbiAgICAgIChzb3VyY2VzLCB7IGZpbGU6IGlkIH0pID0+IHNvdXJjZXNbaWRdIHx8IHt9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5zb3VyY2VSYW5nZVxuICAgICAqL1xuICAgIHNvdXJjZVJhbmdlOiBjcmVhdGVMZWFmKFtcIi4vaW5zdHJ1Y3Rpb25cIl0sIGdldFNvdXJjZVJhbmdlKSxcblxuICAgIC8qKlxuICAgICAqIC5wb2ludGVyXG4gICAgICovXG4gICAgcG9pbnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vc291cmNlXCIsIFwiLi9zb3VyY2VSYW5nZVwiXSxcblxuICAgICAgKHsgYXN0IH0sIHJhbmdlKSA9PiBmaW5kUmFuZ2UoYXN0LCByYW5nZS5zdGFydCwgcmFuZ2UubGVuZ3RoKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAubm9kZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3NvdXJjZVwiLCBcIi4vcG9pbnRlclwiXSxcbiAgICAgICh7IGFzdCB9LCBwb2ludGVyKSA9PlxuICAgICAgICBwb2ludGVyID8ganNvbnBvaW50ZXIuZ2V0KGFzdCwgcG9pbnRlcikgOiBqc29ucG9pbnRlci5nZXQoYXN0LCBcIlwiKVxuICAgIClcbiAgfTtcbn1cblxubGV0IHNvbGlkaXR5ID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIHNvbGlkaXR5LnN0YXRlXG4gICAqL1xuICBzdGF0ZTogc3RhdGUgPT4gc3RhdGUuc29saWRpdHksXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5pbmZvLnNvdXJjZXNcbiAgICAgKi9cbiAgICBzb3VyY2VzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaW5mby5zb3VyY2VzLmJ5SWQpXG4gIH0sXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5LmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZU1hcFxuICAgICAqL1xuICAgIHNvdXJjZU1hcDogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uY3VycmVudC5jb250ZXh0XSxcblxuICAgICAgY29udGV4dCA9PiAoY29udGV4dCA/IGNvbnRleHQuc291cmNlTWFwIDogbnVsbCkgLy9udWxsIHdoZW4gbm8gdHggbG9hZGVkXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aFN0YWNrXG4gICAgICovXG4gICAgZnVuY3Rpb25EZXB0aFN0YWNrOiBzdGF0ZSA9PiBzdGF0ZS5zb2xpZGl0eS5wcm9jLmZ1bmN0aW9uRGVwdGhTdGFjayxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uRGVwdGg6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2Z1bmN0aW9uRGVwdGhTdGFja1wiXSxcbiAgICAgIHN0YWNrID0+IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25zOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL2luZm8vc291cmNlc1wiLCBldm0uY3VycmVudC5jb250ZXh0LCBcIi4vc291cmNlTWFwXCJdLFxuXG4gICAgICAoc291cmNlcywgY29udGV4dCwgc291cmNlTWFwKSA9PiB7XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmluYXJ5ID0gY29udGV4dC5iaW5hcnk7XG4gICAgICAgIGlmICghYmluYXJ5KSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG51bUluc3RydWN0aW9ucztcbiAgICAgICAgaWYgKHNvdXJjZU1hcCkge1xuICAgICAgICAgIG51bUluc3RydWN0aW9ucyA9IHNvdXJjZU1hcC5zcGxpdChcIjtcIikubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vSEFDS1xuICAgICAgICAgIG51bUluc3RydWN0aW9ucyA9IChiaW5hcnkubGVuZ3RoIC0gMikgLyAyO1xuICAgICAgICAgIC8vdGhpcyBpcyBhY3R1YWxseSBhbiBvdmVyZXN0aW1hdGUsIGJ1dCB0aGF0J3MgT0tcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYmVjYXVzZSB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYSBjb25zdHJ1Y3RvciB3aXRoIGFyZ3VtZW50cywgd2UgZG9cbiAgICAgICAgLy8qbm90KiByZW1vdmUgbWV0YWRhdGEgbWFudWFsbHlcbiAgICAgICAgbGV0IGluc3RydWN0aW9ucyA9IENvZGVVdGlscy5wYXJzZUNvZGUoYmluYXJ5LCBudW1JbnN0cnVjdGlvbnMpO1xuXG4gICAgICAgIGlmICghc291cmNlTWFwKSB7XG4gICAgICAgICAgLy8gSEFDS1xuICAgICAgICAgIC8vIExldCdzIGNyZWF0ZSBhIHNvdXJjZSBtYXAgdG8gdXNlIHNpbmNlIG5vbmUgZXhpc3RzLiBUaGlzIHNvdXJjZVxuICAgICAgICAgIC8vIG1hcCBtYXBzIGp1c3QgYXMgbWFueSByYW5nZXMgYXMgdGhlcmUgYXJlIGluc3RydWN0aW9ucyAob3JcbiAgICAgICAgICAvLyBwb3NzaWJseSBtb3JlKSwgYW5kIG1hcmtzIHRoZW0gYWxsIGFzIGJlaW5nIFNvbGlkaXR5LWludGVybmFsIGFuZFxuICAgICAgICAgIC8vIG5vdCBqdW1wcy5cbiAgICAgICAgICBzb3VyY2VNYXAgPVxuICAgICAgICAgICAgYmluYXJ5ICE9PSBcIjB4XCJcbiAgICAgICAgICAgICAgPyBcIjA6MDotMTotXCIuY29uY2F0KFwiO1wiLnJlcGVhdChpbnN0cnVjdGlvbnMubGVuZ3RoIC0gMSkpXG4gICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lQW5kQ29sdW1uTWFwcGluZ3MgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHNvdXJjZXMpLm1hcCgoW2lkLCB7IHNvdXJjZSB9XSkgPT4gKHtcbiAgICAgICAgICAgIFtpZF06IFNvbGlkaXR5VXRpbHMuZ2V0Q2hhcmFjdGVyT2Zmc2V0VG9MaW5lQW5kQ29sdW1uTWFwcGluZyhcbiAgICAgICAgICAgICAgc291cmNlIHx8IFwiXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KSlcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGh1bWFuUmVhZGFibGVTb3VyY2VNYXAgPSBTb2xpZGl0eVV0aWxzLmdldEh1bWFuUmVhZGFibGVTb3VyY2VNYXAoXG4gICAgICAgICAgc291cmNlTWFwXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHByaW1hcnlGaWxlID0gaHVtYW5SZWFkYWJsZVNvdXJjZU1hcFswXS5maWxlO1xuICAgICAgICBkZWJ1ZyhcInByaW1hcnlGaWxlICVvXCIsIHByaW1hcnlGaWxlKTtcblxuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgLm1hcCgoaW5zdHJ1Y3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBsb29rdXAgc291cmNlIG1hcCBieSBpbmRleCBhbmQgYWRkIGBpbmRleGAgcHJvcGVydHkgdG9cbiAgICAgICAgICAgIC8vIGluc3RydWN0aW9uXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VNYXAgPSBodW1hblJlYWRhYmxlU291cmNlTWFwW2luZGV4XSB8fCB7fTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb246IHsgLi4uaW5zdHJ1Y3Rpb24sIGluZGV4IH0sXG4gICAgICAgICAgICAgIHNvdXJjZU1hcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tYXAoKHsgaW5zdHJ1Y3Rpb24sIHNvdXJjZU1hcCB9KSA9PiB7XG4gICAgICAgICAgICAvLyBhZGQgc291cmNlIG1hcCBpbmZvcm1hdGlvbiB0byBpbnN0cnVjdGlvbiwgb3IgZGVmYXVsdHNcbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAganVtcCxcbiAgICAgICAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICAgICAgICBmaWxlID0gcHJpbWFyeUZpbGVcbiAgICAgICAgICAgIH0gPSBzb3VyY2VNYXA7XG4gICAgICAgICAgICBjb25zdCBsaW5lQW5kQ29sdW1uTWFwcGluZyA9IGxpbmVBbmRDb2x1bW5NYXBwaW5nc1tmaWxlXSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICAgICAgICBzdGFydDogbGluZUFuZENvbHVtbk1hcHBpbmdbc3RhcnRdIHx8IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogbnVsbFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlbmQ6IGxpbmVBbmRDb2x1bW5NYXBwaW5nW3N0YXJ0ICsgbGVuZ3RoXSB8fCB7XG4gICAgICAgICAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LmxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGVidWcoXCJzb3VyY2VNYXAgJW9cIiwgc291cmNlTWFwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uaW5zdHJ1Y3Rpb24sXG5cbiAgICAgICAgICAgICAganVtcCxcbiAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICAgcmFuZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25BdFByb2dyYW1Db3VudGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9pbnN0cnVjdGlvbnNcIl0sXG5cbiAgICAgIGluc3RydWN0aW9ucyA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4gKHtcbiAgICAgICAgICAgIFtpbnN0cnVjdGlvbi5wY106IGluc3RydWN0aW9uXG4gICAgICAgICAgfSkpXG4gICAgICAgIClcbiAgICApLFxuXG4gICAgLi4uY3JlYXRlTXVsdGlzdGVwU2VsZWN0b3JzKGV2bS5jdXJyZW50LnN0ZXApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pc1NvdXJjZVJhbmdlRmluYWxcbiAgICAgKi9cbiAgICBpc1NvdXJjZVJhbmdlRmluYWw6IGNyZWF0ZUxlYWYoXG4gICAgICBbXG4gICAgICAgIFwiLi9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIixcbiAgICAgICAgZXZtLmN1cnJlbnQuc3RlcC5wcm9ncmFtQ291bnRlcixcbiAgICAgICAgZXZtLm5leHQuc3RlcC5wcm9ncmFtQ291bnRlclxuICAgICAgXSxcblxuICAgICAgKG1hcCwgY3VycmVudCwgbmV4dCkgPT4ge1xuICAgICAgICBpZiAoIW1hcFtuZXh0XSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IG1hcFtjdXJyZW50XTtcbiAgICAgICAgbmV4dCA9IG1hcFtuZXh0XTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGN1cnJlbnQuc3RhcnQgIT0gbmV4dC5zdGFydCB8fFxuICAgICAgICAgIGN1cnJlbnQubGVuZ3RoICE9IG5leHQubGVuZ3RoIHx8XG4gICAgICAgICAgY3VycmVudC5maWxlICE9IG5leHQuZmlsZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25zQnlQcm9ncmFtQ291bnRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uc0J5UHJvZ3JhbUNvdW50ZXI6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2luc3RydWN0aW9uc1wiLCBcIi9pbmZvL3NvdXJjZXNcIl0sXG4gICAgICAoaW5zdHJ1Y3Rpb25zLCBzb3VyY2VzKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLmluc3RydWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcihpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi5uYW1lID09PSBcIkpVTVBERVNUXCIpXG4gICAgICAgICAgICAuZmlsdGVyKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLmZpbGUgIT09IC0xKVxuICAgICAgICAgICAgLy9ub3RlIHRoYXQgdGhlIGRlc2lnbmF0ZWQgaW52YWxpZCBmdW5jdGlvbiAqZG9lcyogaGF2ZSBhbiBhc3NvY2lhdGVkXG4gICAgICAgICAgICAvL2ZpbGUsIHNvIGl0ICppcyogc2FmZSB0byBqdXN0IGZpbHRlciBvdXQgdGhlIG9uZXMgdGhhdCBkb24ndFxuICAgICAgICAgICAgLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICAgICAgICAgIGRlYnVnKFwiaW5zdHJ1Y3Rpb24gJU9cIiwgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICBsZXQgc291cmNlID0gaW5zdHJ1Y3Rpb24uZmlsZTtcbiAgICAgICAgICAgICAgZGVidWcoXCJzb3VyY2UgJU9cIiwgc291cmNlc1tzb3VyY2VdKTtcbiAgICAgICAgICAgICAgbGV0IGFzdCA9IHNvdXJjZXNbc291cmNlXS5hc3Q7XG4gICAgICAgICAgICAgIGxldCByYW5nZSA9IGdldFNvdXJjZVJhbmdlKGluc3RydWN0aW9uKTtcbiAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBmaW5kUmFuZ2UoYXN0LCByYW5nZS5zdGFydCwgcmFuZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgbGV0IG5vZGUgPSBwb2ludGVyXG4gICAgICAgICAgICAgICAgPyBqc29ucG9pbnRlci5nZXQoYXN0LCBwb2ludGVyKVxuICAgICAgICAgICAgICAgIDoganNvbnBvaW50ZXIuZ2V0KGFzdCwgXCJcIik7XG4gICAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9PSBcIkZ1bmN0aW9uRGVmaW5pdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy9maWx0ZXIgb3V0IEpVTVBERVNUcyB0aGF0IGFyZW4ndCBmdW5jdGlvbiBkZWZpbml0aW9ucy4uLlxuICAgICAgICAgICAgICAgIC8vZXhjZXB0IGZvciB0aGUgZGVzaWduYXRlZCBpbnZhbGlkIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgbGV0IG5leHRJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpbnN0cnVjdGlvbi5pbmRleCArIDFdIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmIChuZXh0SW5zdHJ1Y3Rpb24ubmFtZSA9PT0gXCJJTlZBTElEXCIpIHtcbiAgICAgICAgICAgICAgICAgIC8vZGVzaWduYXRlZCBpbnZhbGlkLCBpbmNsdWRlIGl0XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBbaW5zdHJ1Y3Rpb24ucGNdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNEZXNpZ25hdGVkSW52YWxpZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvL25vdCBkZXNpZ25hdGVkIGludmFsaWQsIGZpbHRlciBpdCBvdXRcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9vdGhlcndpc2UsIHdlJ3JlIGdvb2QgdG8gZ28sIHNvIGxldCdzIGZpbmQgdGhlIGNvbnRyYWN0IG5vZGUgYW5kXG4gICAgICAgICAgICAgIC8vcHV0IGl0IGFsbCB0b2dldGhlclxuICAgICAgICAgICAgICAvL3RvIGdldCB0aGUgY29udHJhY3Qgbm9kZSwgd2UgZ28gdXAgdHdpY2UgZnJvbSB0aGUgZnVuY3Rpb24gbm9kZTtcbiAgICAgICAgICAgICAgLy90aGUgcGF0aCBmcm9tIG9uZSB0byB0aGUgb3RoZXIgc2hvdWxkIGhhdmUgYSB2ZXJ5IHNwZWNpZmljIGZvcm0sXG4gICAgICAgICAgICAgIC8vc28gdGhpcyBpcyBlYXN5XG4gICAgICAgICAgICAgIGxldCBjb250cmFjdFBvaW50ZXIgPSBwb2ludGVyLnJlcGxhY2UoL1xcL25vZGVzXFwvXFxkKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgbGV0IGNvbnRyYWN0Tm9kZSA9IGpzb25wb2ludGVyLmdldChhc3QsIGNvbnRyYWN0UG9pbnRlcik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW2luc3RydWN0aW9uLnBjXToge1xuICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0UG9pbnRlcixcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0Tm9kZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0TmFtZTogY29udHJhY3ROb2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgICBjb250cmFjdElkOiBjb250cmFjdE5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICBjb250cmFjdEtpbmQ6IGNvbnRyYWN0Tm9kZS5jb250cmFjdEtpbmQsXG4gICAgICAgICAgICAgICAgICBpc0Rlc2lnbmF0ZWRJbnZhbGlkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pc011bHRpbGluZVxuICAgICAqL1xuICAgIGlzTXVsdGlsaW5lOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9zb3VyY2VSYW5nZVwiXSxcblxuICAgICAgKHsgbGluZXMgfSkgPT4gbGluZXMuc3RhcnQubGluZSAhPSBsaW5lcy5lbmQubGluZVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LndpbGxKdW1wXG4gICAgICovXG4gICAgd2lsbEp1bXA6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LnN0ZXAuaXNKdW1wXSwgaXNKdW1wID0+IGlzSnVtcCksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50Lmp1bXBEaXJlY3Rpb25cbiAgICAgKi9cbiAgICBqdW1wRGlyZWN0aW9uOiBjcmVhdGVMZWFmKFtcIi4vaW5zdHJ1Y3Rpb25cIl0sIChpID0ge30pID0+IGkuanVtcCB8fCBcIi1cIiksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LndpbGxDYWxsXG4gICAgICovXG4gICAgd2lsbENhbGw6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LnN0ZXAuaXNDYWxsXSwgeCA9PiB4KSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbENyZWF0ZVxuICAgICAqL1xuICAgIHdpbGxDcmVhdGU6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LnN0ZXAuaXNDcmVhdGVdLCB4ID0+IHgpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5jYWxsc1ByZWNvbXBpbGVPckV4dGVybmFsXG4gICAgICovXG4gICAgY2FsbHNQcmVjb21waWxlT3JFeHRlcm5hbDogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uY3VycmVudC5zdGVwLmNhbGxzUHJlY29tcGlsZU9yRXh0ZXJuYWxdLFxuICAgICAgeCA9PiB4XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbFJldHVyblxuICAgICAqL1xuICAgIHdpbGxSZXR1cm46IGNyZWF0ZUxlYWYoXG4gICAgICBbZXZtLmN1cnJlbnQuc3RlcC5pc0hhbHRpbmddLFxuICAgICAgaXNIYWx0aW5nID0+IGlzSGFsdGluZ1xuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LndpbGxGYWlsXG4gICAgICovXG4gICAgd2lsbEZhaWw6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LnN0ZXAuaXNFeGNlcHRpb25hbEhhbHRpbmddLCB4ID0+IHgpLFxuXG4gICAgLypcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50Lm5leHRNYXBwZWRcbiAgICAgKiByZXR1cm5zIHRoZSBuZXh0IHRyYWNlIHN0ZXAgYWZ0ZXIgdGhpcyBvbmUgd2hpY2ggaXMgc291cmNlbWFwcGVkXG4gICAgICogSEFDSzogdGhpcyBhc3N1bWVzIHdlJ3JlIG5vdCBhYm91dCB0byBjaGFuZ2UgY29udGV4dCEgZG9uJ3QgdXNlIHRoaXMgaWZcbiAgICAgKiB3ZSBhcmUhXG4gICAgICogQUxTTywgdGhpcyBtYXkgcmV0dXJuIHVuZGVmaW5lZCwgc28gYmUgcHJlcGFyZWQgZm9yIHRoYXRcbiAgICAgKi9cbiAgICBuZXh0TWFwcGVkOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIiwgdHJhY2Uuc3RlcHMsIHRyYWNlLmluZGV4XSxcbiAgICAgIChtYXAsIHN0ZXBzLCBpbmRleCkgPT5cbiAgICAgICAgc3RlcHMuc2xpY2UoaW5kZXggKyAxKS5maW5kKCh7IHBjIH0pID0+IG1hcFtwY10gJiYgbWFwW3BjXS5maWxlICE9PSAtMSlcbiAgICApXG4gIH0sXG5cbiAgLyoqXG4gICAqIHNvbGlkaXR5Lm5leHRcbiAgICogSEFDSyBXQVJOSU5HOiBkbyBub3QgdXNlIHRoZXNlIHNlbGVjdG9ycyB3aGVuIHRoZSBjdXJyZW50IGluc3RydWN0aW9uIGlzIGFcbiAgICogY29udGV4dCBjaGFuZ2UhIChldm0gY2FsbCBvciBldm0gcmV0dXJuKVxuICAgKi9cbiAgbmV4dDogY3JlYXRlTXVsdGlzdGVwU2VsZWN0b3JzKGV2bS5uZXh0LnN0ZXApXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc29saWRpdHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L3NlbGVjdG9ycy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBTQVZFX1NURVBTID0gXCJTQVZFX1NURVBTXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZVN0ZXBzKHN0ZXBzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9TVEVQUyxcbiAgICBzdGVwc1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgTkVYVCA9IFwiTkVYVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIG5leHQoKSB7XG4gIHJldHVybiB7IHR5cGU6IE5FWFQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFRJQ0sgPSBcIlRJQ0tcIjtcbmV4cG9ydCBmdW5jdGlvbiB0aWNrKCkge1xuICByZXR1cm4geyB0eXBlOiBUSUNLIH07XG59XG5cbmV4cG9ydCBjb25zdCBUT0NLID0gXCJUT0NLXCI7XG5leHBvcnQgZnVuY3Rpb24gdG9jaygpIHtcbiAgcmV0dXJuIHsgdHlwZTogVE9DSyB9O1xufVxuXG5leHBvcnQgY29uc3QgRU5EX09GX1RSQUNFID0gXCJFT1RcIjtcbmV4cG9ydCBmdW5jdGlvbiBlbmRUcmFjZSgpIHtcbiAgcmV0dXJuIHsgdHlwZTogRU5EX09GX1RSQUNFIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVNFVCA9IFwiVFJBQ0VfUkVTRVRcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNldCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogUkVTRVQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFVOTE9BRF9UUkFOU0FDVElPTiA9IFwiVFJBQ0VfVU5MT0FEX1RSQU5TQUNUSU9OXCI7XG5leHBvcnQgZnVuY3Rpb24gdW5sb2FkVHJhbnNhY3Rpb24oKSB7XG4gIHJldHVybiB7IHR5cGU6IFVOTE9BRF9UUkFOU0FDVElPTiB9O1xufVxuXG5leHBvcnQgY29uc3QgQkFDS1RJQ0sgPSBcIkJBQ0tUSUNLXCI7XG5leHBvcnQgZnVuY3Rpb24gYmFja3RpY2soKSB7XG4gIHJldHVybiB7IHR5cGU6IEJBQ0tUSUNLIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6dHJhY2U6c2FnYXNcIik7XG5cbmltcG9ydCB7IHRha2UsIHRha2VFdmVyeSwgcHV0LCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lLCBpc0NhbGxNbmVtb25pYyB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBEZWNvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgdHJhY2UgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24qIGFkdmFuY2UoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLm5leHQoKSk7XG5cbiAgZGVidWcoXCJUT0NLIHRvIHRha2VcIik7XG4gIHlpZWxkIHRha2UoW2FjdGlvbnMuVE9DSywgYWN0aW9ucy5FTkRfT0ZfVFJBQ0VdKTtcbiAgZGVidWcoXCJUT0NLIHRha2VuXCIpO1xufVxuXG5jb25zdCBTVUJNT0RVTEVfQ09VTlQgPSAzOyAvL2RhdGEsIGV2bSwgc29saWRpdHlcblxuZnVuY3Rpb24qIG5leHQoKSB7XG4gIGxldCByZW1haW5pbmcgPSB5aWVsZCBzZWxlY3QodHJhY2Uuc3RlcHNSZW1haW5pbmcpO1xuICBkZWJ1ZyhcInJlbWFpbmluZzogJW9cIiwgcmVtYWluaW5nKTtcbiAgbGV0IHN0ZXBzID0geWllbGQgc2VsZWN0KHRyYWNlLnN0ZXBzKTtcbiAgZGVidWcoXCJ0b3RhbCBzdGVwczogJW9cIiwgc3RlcHMubGVuZ3RoKTtcbiAgbGV0IHdhaXRpbmdGb3JTdWJtb2R1bGVzID0gMDtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIGRlYnVnKFwicHV0dGluZyBUSUNLXCIpO1xuICAgIC8vIHVwZGF0ZXMgc3RhdGUgZm9yIGN1cnJlbnQgc3RlcFxuICAgIHdhaXRpbmdGb3JTdWJtb2R1bGVzID0gU1VCTU9EVUxFX0NPVU5UO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnRpY2soKSk7XG4gICAgZGVidWcoXCJwdXQgVElDS1wiKTtcblxuICAgIC8vd2FpdCBmb3IgYWxsIGJhY2t0aWNrcyBiZWZvcmUgY29udGludWluZ1xuICAgIHdoaWxlICh3YWl0aW5nRm9yU3VibW9kdWxlcyA+IDApIHtcbiAgICAgIHlpZWxkIHRha2UoYWN0aW9ucy5CQUNLVElDSyk7XG4gICAgICBkZWJ1ZyhcImdvdCBCQUNLVElDS1wiKTtcbiAgICAgIHdhaXRpbmdGb3JTdWJtb2R1bGVzLS07XG4gICAgfVxuXG4gICAgcmVtYWluaW5nLS07IC8vIGxvY2FsIHVwZGF0ZSwganVzdCBmb3IgY29udmVuaWVuY2VcbiAgfVxuXG4gIGlmIChyZW1haW5pbmcpIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgVE9DS1wiKTtcbiAgICAvLyB1cGRhdGVzIHN0ZXAgdG8gbmV4dCBzdGVwIGluIHRyYWNlXG4gICAgeWllbGQgcHV0KGFjdGlvbnMudG9jaygpKTtcbiAgICBkZWJ1ZyhcInB1dCBUT0NLXCIpO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKFwicHV0dGluZyBFTkRfT0ZfVFJBQ0VcIik7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZW5kVHJhY2UoKSk7XG4gICAgZGVidWcoXCJwdXQgRU5EX09GX1RSQUNFXCIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2lnbmFsVGlja1NhZ2FDb21wbGV0aW9uKCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5iYWNrdGljaygpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBwcm9jZXNzVHJhY2Uoc3RlcHMpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZVN0ZXBzKHN0ZXBzKSk7XG5cbiAgbGV0IGFkZHJlc3NlcyA9IFtcbiAgICAuLi5uZXcgU2V0KFxuICAgICAgc3RlcHNcbiAgICAgICAgLm1hcChcbiAgICAgICAgICAoeyBvcCwgc3RhY2sgfSkgPT5cbiAgICAgICAgICAgIGlzQ2FsbE1uZW1vbmljKG9wKVxuICAgICAgICAgICAgICA/IC8vaWYgaXQncyBhIGNhbGwsIGp1c3QgZmV0Y2ggdGhlIGFkZHJlc3Mgb2ZmIHRoZSBzdGFja1xuICAgICAgICAgICAgICAgIERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9BZGRyZXNzKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdKVxuICAgICAgICAgICAgICA6IC8vaWYgaXQncyBub3QgYSBjYWxsLCBqdXN0IHJldHVybiB1bmRlZmluZWQgKHdlJ3ZlIGdvbmUgYmFjayB0b1xuICAgICAgICAgICAgICAgIC8vc2tpcHBpbmcgY3JlYXRlcylcbiAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgKVxuICAgICAgICAvL2ZpbHRlciBvdXQgemVybyBhZGRyZXNzZXMgZnJvbSBmYWlsZWQgY3JlYXRlcyAoYXMgd2VsbCBhcyB1bmRlZmluZWRzKVxuICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgIGFkZHJlc3MgPT5cbiAgICAgICAgICAgIGFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiBhZGRyZXNzICE9PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTXG4gICAgICAgIClcbiAgICApXG4gIF07XG5cbiAgcmV0dXJuIGFkZHJlc3Nlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZXNldCgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVzZXQoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogdW5sb2FkKCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy51bmxvYWRUcmFuc2FjdGlvbigpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5ORVhULCBuZXh0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInRyYWNlXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9zYWdhcy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBTVEFSVCA9IFwiU0VTU0lPTl9TVEFSVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0KHByb3ZpZGVyLCB0eEhhc2gpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTVEFSVCxcbiAgICBwcm92aWRlcixcbiAgICB0eEhhc2ggLy9PUFRJT05BTFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgTE9BRF9UUkFOU0FDVElPTiA9IFwiTE9BRF9UUkFOU0FDVElPTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBMT0FEX1RSQU5TQUNUSU9OLFxuICAgIHR4SGFzaFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgSU5URVJSVVBUID0gXCJTRVNTSU9OX0lOVEVSUlVQVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGludGVycnVwdCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogSU5URVJSVVBUIH07XG59XG5cbmV4cG9ydCBjb25zdCBVTkxPQURfVFJBTlNBQ1RJT04gPSBcIlVOTE9BRF9UUkFOU0FDVElPTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIHVubG9hZFRyYW5zYWN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFVOTE9BRF9UUkFOU0FDVElPTlxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVBRFkgPSBcIlNFU1NJT05fUkVBRFlcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWFkeSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUFEWVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgV0FJVCA9IFwiU0VTU0lPTl9XQUlUXCI7XG5leHBvcnQgZnVuY3Rpb24gd2FpdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBXQUlUXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBFUlJPUiA9IFwiU0VTU0lPTl9FUlJPUlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRVJST1IsXG4gICAgZXJyb3JcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IENMRUFSX0VSUk9SID0gXCJDTEVBUl9FUlJPUlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyRXJyb3IoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQ0xFQVJfRVJST1JcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ09SRF9DT05UUkFDVFMgPSBcIlJFQ09SRF9DT05UUkFDVFNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRDb250cmFjdHMoY29udGV4dHMsIHNvdXJjZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNPUkRfQ09OVFJBQ1RTLFxuICAgIGNvbnRleHRzLFxuICAgIHNvdXJjZXNcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNBVkVfVFJBTlNBQ1RJT04gPSBcIlNBVkVfVFJBTlNBQ1RJT05cIjtcbmV4cG9ydCBmdW5jdGlvbiBzYXZlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTQVZFX1RSQU5TQUNUSU9OLFxuICAgIHRyYW5zYWN0aW9uXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBTQVZFX1JFQ0VJUFQgPSBcIlNBVkVfUkVDRUlQVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVSZWNlaXB0KHJlY2VpcHQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTQVZFX1JFQ0VJUFQsXG4gICAgcmVjZWlwdFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgU0FWRV9CTE9DSyA9IFwiU0FWRV9CTE9DS1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVCbG9jayhibG9jaykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNBVkVfQkxPQ0ssXG4gICAgYmxvY2tcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9hY3Rpb25zL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYm4uanNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJibi5qc1wiXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIlxuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6c2FnYXNcIik7XG5cbmltcG9ydCB7IHB1dCwgdGFrZUV2ZXJ5LCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUsIHN0YWJsZUtlY2NhazI1NiwgbWFrZUFzc2lnbm1lbnQgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZXZtIGZyb20gXCJsaWIvZXZtL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyB3ZWIzIGZyb20gXCJsaWIvd2ViMy9zYWdhc1wiO1xuXG5pbXBvcnQgZGF0YSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmltcG9ydCBzdW0gZnJvbSBcImxvZGFzaC5zdW1cIjtcblxuaW1wb3J0ICogYXMgRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5pbXBvcnQge1xuICBnZXRTdG9yYWdlQWxsb2NhdGlvbnMsXG4gIGdldE1lbW9yeUFsbG9jYXRpb25zLFxuICBnZXRDYWxsZGF0YUFsbG9jYXRpb25zLFxuICByZWFkU3RhY2ssXG4gIHN0b3JhZ2VTaXplLFxuICBmb3JFdm1TdGF0ZVxufSBmcm9tIFwidHJ1ZmZsZS1kZWNvZGVyXCI7XG5pbXBvcnQgQk4gZnJvbSBcImJuLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiogc2NvcGUobm9kZUlkLCBwb2ludGVyLCBwYXJlbnRJZCwgc291cmNlSWQpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2NvcGUobm9kZUlkLCBwb2ludGVyLCBwYXJlbnRJZCwgc291cmNlSWQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBkZWNsYXJlKG5vZGUpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuZGVjbGFyZShub2RlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogZGVmaW5lVHlwZShub2RlKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmRlZmluZVR5cGUobm9kZSkpO1xufVxuXG5mdW5jdGlvbiogdGlja1NhZ2EoKSB7XG4gIGRlYnVnKFwiZ290IFRJQ0tcIik7XG5cbiAgeWllbGQqIHZhcmlhYmxlc0FuZE1hcHBpbmdzU2FnYSgpO1xuICBkZWJ1ZyhcImFib3V0IHRvIFNVQlRPQ0tcIik7XG4gIHlpZWxkKiB0cmFjZS5zaWduYWxUaWNrU2FnYUNvbXBsZXRpb24oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBkZWNvZGUoZGVmaW5pdGlvbiwgcmVmKSB7XG4gIGxldCByZWZlcmVuY2VEZWNsYXJhdGlvbnMgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5yZWZlcmVuY2VEZWNsYXJhdGlvbnMpO1xuICBsZXQgc3RhdGUgPSB5aWVsZCBzZWxlY3QoZGF0YS5jdXJyZW50LnN0YXRlKTtcbiAgbGV0IG1hcHBpbmdLZXlzID0geWllbGQgc2VsZWN0KGRhdGEudmlld3MubWFwcGluZ0tleXMpO1xuICBsZXQgYWxsb2NhdGlvbnMgPSB5aWVsZCBzZWxlY3QoZGF0YS5pbmZvLmFsbG9jYXRpb25zKTtcbiAgbGV0IGluc3RhbmNlcyA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmluc3RhbmNlcyk7XG4gIGxldCBjb250ZXh0cyA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmNvbnRleHRzKTtcbiAgbGV0IGN1cnJlbnRDb250ZXh0ID0geWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5jb250ZXh0KTtcbiAgbGV0IGludGVybmFsRnVuY3Rpb25zVGFibGUgPSB5aWVsZCBzZWxlY3QoXG4gICAgZGF0YS5jdXJyZW50LmZ1bmN0aW9uc0J5UHJvZ3JhbUNvdW50ZXJcbiAgKTtcbiAgbGV0IGJsb2NrTnVtYmVyID0geWllbGQgc2VsZWN0KGRhdGEudmlld3MuYmxvY2tOdW1iZXIpO1xuXG4gIGxldCBaRVJPX1dPUkQgPSBuZXcgVWludDhBcnJheShEZWNvZGVVdGlscy5FVk0uV09SRF9TSVpFKTtcbiAgWkVST19XT1JELmZpbGwoMCk7XG4gIGxldCBOT19DT0RFID0gbmV3IFVpbnQ4QXJyYXkoKTsgLy9lbXB0eSBhcnJheVxuXG4gIGxldCBkZWNvZGVyID0gZm9yRXZtU3RhdGUoZGVmaW5pdGlvbiwgcmVmLCB7XG4gICAgcmVmZXJlbmNlRGVjbGFyYXRpb25zLFxuICAgIHN0YXRlLFxuICAgIG1hcHBpbmdLZXlzLFxuICAgIHN0b3JhZ2VBbGxvY2F0aW9uczogYWxsb2NhdGlvbnMuc3RvcmFnZSxcbiAgICBtZW1vcnlBbGxvY2F0aW9uczogYWxsb2NhdGlvbnMubWVtb3J5LFxuICAgIGNhbGxkYXRhQWxsb2NhdGlvbnM6IGFsbG9jYXRpb25zLmNhbGxkYXRhLFxuICAgIGNvbnRleHRzLFxuICAgIGN1cnJlbnRDb250ZXh0LFxuICAgIGludGVybmFsRnVuY3Rpb25zVGFibGVcbiAgfSk7XG5cbiAgbGV0IHJlc3VsdCA9IGRlY29kZXIubmV4dCgpO1xuICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgbGV0IHJlcXVlc3QgPSByZXN1bHQudmFsdWU7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHN3aXRjaCAocmVxdWVzdC50eXBlKSB7XG4gICAgICBjYXNlIFwic3RvcmFnZVwiOlxuICAgICAgICAvL3RoZSBkZWJ1Z2dlciBzdXBwbGllcyBhbGwgc3RvcmFnZSBpdCBrbm93cyBhdCB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAvL2FueSBzdG9yYWdlIGl0IGRvZXMgbm90IGtub3cgaXMgcHJlc3VtZWQgdG8gYmUgemVyby5cbiAgICAgICAgcmVzcG9uc2UgPSBaRVJPX1dPUkQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvZGVcIjpcbiAgICAgICAgbGV0IGFkZHJlc3MgPSByZXF1ZXN0LmFkZHJlc3M7XG4gICAgICAgIGlmIChhZGRyZXNzIGluIGluc3RhbmNlcykge1xuICAgICAgICAgIHJlc3BvbnNlID0gaW5zdGFuY2VzW2FkZHJlc3NdO1xuICAgICAgICB9IGVsc2UgaWYgKGFkZHJlc3MgPT09IERlY29kZVV0aWxzLkVWTS5aRVJPX0FERFJFU1MpIHtcbiAgICAgICAgICAvL0hBQ0s6IHRvIGF2b2lkIGRpc3BsYXlpbmcgdGhlIHplcm8gYWRkcmVzcyB0byB0aGUgdXNlciBhcyBhblxuICAgICAgICAgIC8vYWZmZWN0ZWQgYWRkcmVzcyBqdXN0IGJlY2F1c2UgdGhleSBkZWNvZGVkIGEgY29udHJhY3Qgb3IgZXh0ZXJuYWxcbiAgICAgICAgICAvL2Z1bmN0aW9uIHZhcmlhYmxlIHRoYXQgaGFkbid0IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LCB3ZSBnaXZlIHRoZVxuICAgICAgICAgIC8vemVybyBhZGRyZXNzJ3MgY29kZWxlc3NuZXNzIGl0cyBvd24gcHJpdmF0ZSBjYWNoZSA6UFxuICAgICAgICAgIHJlc3BvbnNlID0gTk9fQ09ERTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL0kgZG9uJ3Qgd2FudCB0byB3cml0ZSBhIG5ldyB3ZWIzIHNhZ2EsIHNvIGxldCdzIGp1c3QgdXNlXG4gICAgICAgICAgLy9vYnRhaW5CaW5hcmllcyB3aXRoIGEgb25lLWVsZW1lbnQgYXJyYXlcbiAgICAgICAgICBkZWJ1ZyhcImZldGNoaW5nIGJpbmFyeVwiKTtcbiAgICAgICAgICBsZXQgYmluYXJ5ID0gKHlpZWxkKiB3ZWIzLm9idGFpbkJpbmFyaWVzKFthZGRyZXNzXSwgYmxvY2tOdW1iZXIpKVswXTtcbiAgICAgICAgICBkZWJ1ZyhcImFkZGluZyBpbnN0YW5jZVwiKTtcbiAgICAgICAgICB5aWVsZCogZXZtLmFkZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSk7XG4gICAgICAgICAgcmVzcG9uc2UgPSBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQnl0ZXMoYmluYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGRlYnVnKFwidW5yZWNvZ25pemVkIHJlcXVlc3QgdHlwZSFcIik7XG4gICAgfVxuICAgIHJlc3VsdCA9IGRlY29kZXIubmV4dChyZXNwb25zZSk7XG4gIH1cbiAgLy9hdCB0aGlzIHBvaW50LCByZXN1bHQudmFsdWUgaG9sZHMgdGhlIGZpbmFsIHZhbHVlXG4gIC8vbm90ZTogd2UncmUgc3RpbGwgdXNpbmcgdGhlIG9sZCBkZWNvZGVyIG91dHB1dCBmb3JtYXQsIHNvIHdlIG5lZWQgdG8gY2xlYW5cbiAgLy9jb250YWluZXJzIGJlZm9yZSByZXR1cm5pbmcgc29tZXRoaW5nIHRoZSBkZWJ1Z2dlciBjYW4gdXNlXG4gIHJldHVybiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLmNsZWFuQ29udGFpbmVycyhyZXN1bHQudmFsdWUpO1xufVxuXG5mdW5jdGlvbiogdmFyaWFibGVzQW5kTWFwcGluZ3NTYWdhKCkge1xuICBsZXQgbm9kZSA9IHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQubm9kZSk7XG4gIGxldCBzY29wZXMgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5zY29wZXMuaW5saW5lZCk7XG4gIGxldCByZWZlcmVuY2VEZWNsYXJhdGlvbnMgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5yZWZlcmVuY2VEZWNsYXJhdGlvbnMpO1xuICBsZXQgYWxsb2NhdGlvbnMgPSB5aWVsZCBzZWxlY3QoZGF0YS5pbmZvLmFsbG9jYXRpb25zLnN0b3JhZ2UpO1xuICBsZXQgY3VycmVudEFzc2lnbm1lbnRzID0geWllbGQgc2VsZWN0KGRhdGEucHJvYy5hc3NpZ25tZW50cyk7XG4gIGxldCBtYXBwZWRQYXRocyA9IHlpZWxkIHNlbGVjdChkYXRhLnByb2MubWFwcGVkUGF0aHMpO1xuICBsZXQgY3VycmVudERlcHRoID0geWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgbGV0IGFkZHJlc3MgPSB5aWVsZCBzZWxlY3QoZGF0YS5jdXJyZW50LmFkZHJlc3MpO1xuICAvL3N0b3JhZ2UgYWRkcmVzcywgbm90IGNvZGUgYWRkcmVzc1xuXG4gIGxldCBzdGFjayA9IHlpZWxkIHNlbGVjdChkYXRhLm5leHQuc3RhdGUuc3RhY2spOyAvL25vdGUgdGhlIHVzZSBvZiBuZXh0IVxuICAvL2luIHRoaXMgc2FnYSB3ZSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKnJlc3VsdHMqIG9mIHRoZSBjdXJyZW50IGluc3RydWN0aW9uXG4gIC8vbm90ZSB0aGF0IHRoZSBkZWNvZGVyIGlzIHN0aWxsIGJhc2VkIG9uIGRhdGEuY3VycmVudC5zdGF0ZTsgdGhhdCdzIGZpbmVcbiAgLy90aG91Z2guICBUaGVyZSdzIGFscmVhZHkgYSBkZWxheSBiZXR3ZWVuIHdoZW4gd2UgcmVjb3JkIHRoaW5ncyBvZmYgdGhlXG4gIC8vc3RhY2sgYW5kIHdoZW4gd2UgZGVjb2RlIHRoZW0sIGFmdGVyIGFsbC4gIEJhc2ljYWxseSwgbm90aGluZyBzZXJpb3VzXG4gIC8vc2hvdWxkIGhhcHBlbiBhZnRlciBhbiBpbmRleCBub2RlIGJ1dCBiZWZvcmUgdGhlIGluZGV4IGFjY2VzcyBub2RlIHRoYXRcbiAgLy93b3VsZCBjYXVzZSBzdG9yYWdlLCBtZW1vcnksIG9yIGNhbGxkYXRhIHRvIGNoYW5nZSwgbWVhbmluZyB0aGF0IGV2ZW4gaWZcbiAgLy90aGUgbGl0ZXJhbCB3ZSByZWNvcmRlZCB3YXMgYSBwb2ludGVyLCBpdCB3aWxsIHN0aWxsIGJlIHZhbGlkIGF0IHRoZSB0aW1lXG4gIC8vd2UgdXNlIGl0LiAgKFRoZSBvdGhlciBsaXRlcmFscyB3ZSBtYWtlIHVzZSBvZiwgZm9yIHRoZSBiYXNlIGV4cHJlc3Npb25zLFxuICAvL2FyZSBub3QgZGVjb2RlZCwgc28gbm8gcG90ZW50aWFsIG1pc21hdGNoIHRoZXJlIHdvdWxkIGJlIHJlbGV2YW50IGFueXdheS4pXG5cbiAgbGV0IGFsdGVybmF0ZVN0YWNrID0geWllbGQgc2VsZWN0KGRhdGEubmV4dE1hcHBlZC5zdGF0ZS5zdGFjayk7XG4gIC8vSEFDSzogdW5mb3J0dW5hdGVseSwgaW4gc29tZSBjYXNlcywgZGF0YS5uZXh0LnN0YXRlLnN0YWNrIGdldHMgdGhlIHdyb25nXG4gIC8vcmVzdWx0cyBkdWUgdG8gdW5tYXBwZWQgaW5zdHJ1Y3Rpb25zIGludGVydmVuaW5nLiAgU28sIHdlIGdldCB0aGUgc3RhY2sgYXRcbiAgLy90aGUgbmV4dCAqbWFwcGVkKiBzdGFjayBpbnN0ZWFkLiAgVGhpcyBpcyBzb21ldGhpbmcgb2YgYSBoYWNrIGFuZCB3b24ndFxuICAvL3dvcmsgaWYgd2UncmUgYWJvdXQgdG8gY2hhbmdlIGNvbnRleHQsIGJ1dCBpdCBzaG91bGQgd29yayBpbiB0aGUgY2FzZXMgdGhhdFxuICAvL25lZWQgaXQuXG5cbiAgaWYgKCFzdGFjaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCB0b3AgPSBzdGFjay5sZW5ndGggLSAxO1xuICB2YXIgYXNzaWdubWVudCwgYXNzaWdubWVudHMsIHByZWFtYmxlQXNzaWdubWVudHMsIGJhc2VFeHByZXNzaW9uLCBzbG90LCBwYXRoO1xuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHN0YWNrIGlzIG9ubHkgcmVhZHkgZm9yIGludGVycHJldGF0aW9uIGFmdGVyIHRoZSBsYXN0IHN0ZXAgb2YgZWFjaFxuICAvLyBzb3VyY2UgcmFuZ2VcbiAgLy9cbiAgLy8gdGhlIGRhdGEgbW9kdWxlIGFsd2F5cyBsb29rcyBhdCB0aGUgcmVzdWx0IG9mIGEgcGFydGljdWxhciBvcGNvZGVcbiAgLy8gKGkuZS4sIHRoZSBmb2xsb3dpbmcgdHJhY2Ugc3RlcCdzIHN0YWNrL21lbW9yeS9zdG9yYWdlKSwgc28gdGhpc1xuICAvLyBhc3NlcnRzIHRoYXQgdGhlIF9jdXJyZW50XyBvcGVyYXRpb24gaXMgdGhlIGZpbmFsIG9uZSBiZWZvcmVcbiAgLy8gcHJvY2VlZGluZ1xuICBpZiAoISh5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5hdExhc3RJbnN0cnVjdGlvbkZvclNvdXJjZVJhbmdlKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvL0hBQ0s6IG1vZGlmaWVyIHByZWFtYmxlXG4gIC8vbW9kaWZpZXIgZGVmaW5pdGlvbnMgYXJlIHR5cGljYWxseSBza2lwcGVkICh0aGlzIGluY2x1ZGVzIGNvbnN0cnVjdG9yXG4gIC8vZGVmaW5pdGlvbnMgd2hlbiBjYWxsZWQgYXMgYSBiYXNlIGNvbnN0cnVjdG9yKTsgYXMgc3VjaCBJJ3ZlIGFkZGVkIHRoaXNcbiAgLy9cIm1vZGlmaWVyIHByZWFtYmxlXCIgdG8gY2F0Y2ggdGhlbVxuICBpZiAoeWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5hYm91dFRvTW9kaWZ5KSkge1xuICAgIGxldCBtb2RpZmllciA9IHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQubW9kaWZpZXJCZWluZ0ludm9rZWQpO1xuICAgIC8vbWF5IGJlIGVpdGhlciBhIG1vZGlmaWVyIG9yIGJhc2UgY29uc3RydWN0b3JcbiAgICBsZXQgY3VycmVudEluZGV4ID0geWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5tb2RpZmllckFyZ3VtZW50SW5kZXgpO1xuICAgIGRlYnVnKFwiY3VycmVudEluZGV4ICVkXCIsIGN1cnJlbnRJbmRleCk7XG4gICAgbGV0IHBhcmFtZXRlcnMgPSBtb2RpZmllci5wYXJhbWV0ZXJzLnBhcmFtZXRlcnM7XG4gICAgLy9ub3c6IGxvb2sgYXQgdGhlIHBhcmFtZXRlcnMgKmFmdGVyKiB0aGUgY3VycmVudCBpbmRleC4gIHdlJ2xsIG5lZWQgdG9cbiAgICAvL2FkanVzdCBmb3IgdGhvc2UuXG4gICAgbGV0IHBhcmFtZXRlcnNMZWZ0ID0gcGFyYW1ldGVycy5zbGljZShjdXJyZW50SW5kZXggKyAxKTtcbiAgICBsZXQgYWRqdXN0bWVudCA9IHN1bShwYXJhbWV0ZXJzTGVmdC5tYXAoRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5zdGFja1NpemUpKTtcbiAgICBkZWJ1ZyhcImFkanVzdG1lbnQgJWRcIiwgYWRqdXN0bWVudCk7XG4gICAgcHJlYW1ibGVBc3NpZ25tZW50cyA9IGFzc2lnblBhcmFtZXRlcnMoXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgdG9wICsgYWRqdXN0bWVudCxcbiAgICAgIGN1cnJlbnREZXB0aFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcHJlYW1ibGVBc3NpZ25tZW50cyA9IHt9O1xuICB9XG5cbiAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVmaW5pdGlvblwiOlxuICAgIGNhc2UgXCJNb2RpZmllckRlZmluaXRpb25cIjpcbiAgICAgIC8vTk9URTogdGhpcyB3aWxsICpub3QqIGNhdGNoIG1vc3QgbW9kaWZpZXIgZGVmaW5pdGlvbnMhXG4gICAgICAvL3RoZSByZXN0IGhvcGVmdWxseSB3aWxsIGJlIGNhdWdodCBieSB0aGUgbW9kaWZpZXIgcHJlYW1ibGVcbiAgICAgIC8vKGluIGZhY3QgdGhleSB3b24ndCBhbGwgYmUsIGJ1dC4uLilcblxuICAgICAgLy9IQUNLOiBmaWx0ZXIgb3V0IHNvbWUgZ2FyYmFnZVxuICAgICAgLy90aGlzIGZpbHRlcnMgb3V0IHRoZSBjYXNlIHdoZXJlIHdlJ3JlIHJlYWxseSBpbiBhbiBpbnZvY2F0aW9uIG9mIGFcbiAgICAgIC8vbW9kaWZpZXIgb3IgYmFzZSBjb25zdHJ1Y3RvciwgYnV0IGhhdmUgdGVtcG9yYXJpbHkgaGl0IHRoZSBkZWZpbml0aW9uXG4gICAgICAvL25vZGUgZm9yIHNvbWUgcmVhc29uLiAgSG93ZXZlciB0aGlzIG9idmlvdXNseSBjYW4gaGF2ZSBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAvL2luIHRoZSBjYXNlIHdoZXJlIGEgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG1vZGlmaWVyIHR3aWNlLlxuICAgICAgbGV0IG5leHRNb2RpZmllciA9IHlpZWxkIHNlbGVjdChkYXRhLm5leHQubW9kaWZpZXJCZWluZ0ludm9rZWQpO1xuICAgICAgaWYgKG5leHRNb2RpZmllciAmJiBuZXh0TW9kaWZpZXIuaWQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxldCBwYXJhbWV0ZXJzID0gbm9kZS5wYXJhbWV0ZXJzLnBhcmFtZXRlcnM7XG4gICAgICAvL25vdGUgdGhhdCB3ZSBkbyAqbm90KiBpbmNsdWRlIHJldHVybiBwYXJhbWV0ZXJzLCBzaW5jZSB0aG9zZSBhcmVcbiAgICAgIC8vaGFuZGxlZCBieSB0aGUgVmFyaWFibGVEZWNsYXJhdGlvbiBjYXNlIChubywgSSBkb24ndCBrbm93IHdoeSBpdFxuICAgICAgLy93b3JrcyBvdXQgdGhhdCB3YXkpXG5cbiAgICAgIC8vd2UgY2FuIHNraXAgcHJlYW1ibGVBc3NpZ25tZW50cyBoZXJlLCB0aGF0IGlzbid0IHVzZWQgaW4gdGhpcyBjYXNlXG4gICAgICBhc3NpZ25tZW50cyA9IGFzc2lnblBhcmFtZXRlcnMocGFyYW1ldGVycywgdG9wLCBjdXJyZW50RGVwdGgpO1xuXG4gICAgICBkZWJ1ZyhcIkZ1bmN0aW9uIGRlZmluaXRpb24gY2FzZVwiKTtcbiAgICAgIGRlYnVnKFwiYXNzaWdubWVudHMgJU9cIiwgYXNzaWdubWVudHMpO1xuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24oYXNzaWdubWVudHMpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiOlxuICAgICAgbGV0IGFsbG9jYXRpb24gPSBhbGxvY2F0aW9uc1tub2RlLmlkXTtcblxuICAgICAgZGVidWcoXCJDb250cmFjdCBkZWZpbml0aW9uIGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImFsbG9jYXRpb25zICVPXCIsIGFsbG9jYXRpb25zKTtcbiAgICAgIGRlYnVnKFwiYWxsb2NhdGlvbiAlT1wiLCBhbGxvY2F0aW9uKTtcbiAgICAgIGFzc2lnbm1lbnRzID0ge307XG4gICAgICBmb3IgKGxldCBpZCBpbiBhbGxvY2F0aW9uLm1lbWJlcnMpIHtcbiAgICAgICAgaWQgPSBOdW1iZXIoaWQpOyAvL25vdCBzdXJlIHdoeSB3ZSdyZSBnZXR0aW5nIHRoZW0gYXMgc3RyaW5ncywgYnV0Li4uXG4gICAgICAgIGxldCBpZE9iaiA9IHsgYXN0SWQ6IGlkLCBhZGRyZXNzIH07XG4gICAgICAgIGxldCBmdWxsSWQgPSBzdGFibGVLZWNjYWsyNTYoaWRPYmopO1xuICAgICAgICAvL3dlIGRvbid0IHVzZSBtYWtlQXNzaWdubWVudCBoZXJlIGFzIHdlIGhhZCB0byBjb21wdXRlIHRoZSBJRCBhbnl3YXlcbiAgICAgICAgYXNzaWdubWVudCA9IHtcbiAgICAgICAgICAuLi5pZE9iaixcbiAgICAgICAgICBpZDogZnVsbElkLFxuICAgICAgICAgIHJlZjoge1xuICAgICAgICAgICAgLi4uKChjdXJyZW50QXNzaWdubWVudHMuYnlJZFtmdWxsSWRdIHx8IHt9KS5yZWYgfHwge30pLFxuICAgICAgICAgICAgLi4uYWxsb2NhdGlvbi5tZW1iZXJzW2lkXS5wb2ludGVyXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhc3NpZ25tZW50c1tmdWxsSWRdID0gYXNzaWdubWVudDtcbiAgICAgIH1cbiAgICAgIGRlYnVnKFwiYXNzaWdubWVudHMgJU9cIiwgYXNzaWdubWVudHMpO1xuXG4gICAgICAvL3RoaXMgY2FzZSBkb2Vzbid0IG5lZWQgcHJlYW1ibGVBc3NpZ25tZW50cyBlaXRoZXJcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbihhc3NpZ25tZW50cykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiRnVuY3Rpb25UeXBlTmFtZVwiOlxuICAgICAgLy9IQUNLXG4gICAgICAvL2ZvciBzb21lIHJlYXNvbnMsIGZvciBkZWNsYXJhdGlvbnMgb2YgbG9jYWwgdmFyaWFibGVzIG9mIGZ1bmN0aW9uIHR5cGUsXG4gICAgICAvL3dlIGxhbmQgb24gdGhlIEZ1bmN0aW9uVHlwZU5hbWUgaW5zdGVhZCBvZiB0aGUgVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgIC8vc28gd2UgcmVwbGFjZSB0aGUgbm9kZSB3aXRoIGl0cyBwYXJlbnQgKHRoZSBWYXJpYWJsZURlY2xhcmF0aW9uKVxuICAgICAgbm9kZSA9IHNjb3Blc1tzY29wZXNbbm9kZS5pZF0ucGFyZW50SWRdLmRlZmluaXRpb247XG4gICAgICAvL2xldCdzIGRvIGEgcXVpY2sgY2hlY2sgdGhhdCBpdCAqaXMqIGEgVmFyaWFibGVEZWNsYXJhdGlvbiBiZWZvcmVcbiAgICAgIC8vY29udGludWluZ1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vb3RoZXJ3aXNlLCBkZWxpYmVyYXRlbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBWYXJpYWJsZURlY2xhcmF0aW9uIGNhc2VcbiAgICAvL05PVEU6IERFTElCRVJBVEUgRkFMTC1USFJPVUdIXG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgIGxldCB2YXJJZCA9IG5vZGUuaWQ7XG4gICAgICBkZWJ1ZyhcIlZhcmlhYmxlIGRlY2xhcmF0aW9uIGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImN1cnJlbnREZXB0aCAlZCB2YXJJZCAlZFwiLCBjdXJyZW50RGVwdGgsIHZhcklkKTtcblxuICAgICAgLy9OT1RFOiBXZSdyZSBnb2luZyB0byBtYWtlIHRoZSBhc3NpZ25tZW50IGNvbmRpdGlvbmFsIGhlcmU7IGhlcmUncyB3aHkuXG4gICAgICAvL1RoZXJlJ3MgYSBidWcgd2hlcmUgY2FsbGluZyB0aGUgYXV0b2dlbmVyYXRlZCBhY2Nlc3NvciBmb3IgYSBwdWJsaWNcbiAgICAgIC8vY29udHJhY3QgdmFyaWFibGUgY2F1c2VzIHRoZSBkZWJ1Z2dlciB0byBzZWUgdHdvIGFkZGl0aW9uYWxcbiAgICAgIC8vZGVjbGFyYXRpb25zIGZvciB0aGF0IHZhcmlhYmxlLi4uIHdoaWNoIHRoaXMgY29kZSByZWFkcyBhcyBsb2NhbFxuICAgICAgLy92YXJpYWJsZSBkZWNsYXJhdGlvbnMuICBSYXRoZXIgdGhhbiBwcmV2ZW50IHRoaXMgYXQgdGhlIHNvdXJjZSwgd2UncmVcbiAgICAgIC8vanVzdCBnb2luZyB0byBjaGVjayBmb3IgaXQgaGVyZSwgYnkgbm90IGFkZGluZyBhIGxvY2FsIHZhcmlhYmxlIGlmIHNhaWRcbiAgICAgIC8vdmFyaWFibGUgaXMgYWxyZWFkeSBhIGNvbnRyYWN0IHZhcmlhYmxlLlxuXG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRBc3NpZ25tZW50cy5ieUFzdElkW3ZhcklkXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGN1cnJlbnRBc3NpZ25tZW50cy5ieUFzdElkW3ZhcklkXS5zb21lKFxuICAgICAgICAgIGlkID0+IGN1cnJlbnRBc3NpZ25tZW50cy5ieUlkW2lkXS5hZGRyZXNzICE9PSB1bmRlZmluZWRcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGRlYnVnKFwiYWxyZWFkeSBhIGNvbnRyYWN0IHZhcmlhYmxlIVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vb3RoZXJ3aXNlLCBnbyBhaGVhZCBhbmQgbWFrZSB0aGUgYXNzaWdubWVudFxuICAgICAgYXNzaWdubWVudCA9IG1ha2VBc3NpZ25tZW50KFxuICAgICAgICB7IGFzdElkOiB2YXJJZCwgc3RhY2tmcmFtZTogY3VycmVudERlcHRoIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzdGFjazoge1xuICAgICAgICAgICAgZnJvbTogdG9wIC0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5zdGFja1NpemUobm9kZSkgKyAxLFxuICAgICAgICAgICAgdG86IHRvcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGFzc2lnbm1lbnRzID0geyBbYXNzaWdubWVudC5pZF06IGFzc2lnbm1lbnQgfTtcbiAgICAgIC8vdGhpcyBjYXNlIGRvZXNuJ3QgbmVlZCBwcmVhbWJsZUFzc2lnbm1lbnRzIGVpdGhlclxuICAgICAgZGVidWcoXCJhc3NpZ25tZW50czogJU9cIiwgYXNzaWdubWVudHMpO1xuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJJbmRleEFjY2Vzc1wiOlxuICAgICAgLy8gdG8gdHJhY2sgYG1hcHBpbmdgIHR5cGVzIGtub3duIGluZGljZXNcbiAgICAgIC8vIChhbmQgYWxzbyAqc29tZSoga25vd24gaW5kaWNlcyBmb3IgYXJyYXlzKVxuXG4gICAgICAvL0hBQ0s6IHdlIHVzZSB0aGUgYWx0ZXJuYXRlIHN0YWNrIGluIHRoaXMgY2FzZVxuXG4gICAgICBkZWJ1ZyhcIkluZGV4IGFjY2VzcyBjYXNlXCIpO1xuXG4gICAgICAvL3dlJ3JlIGdvaW5nIHRvIHN0YXJ0IGJ5IGRvaW5nIHRoZSBzYW1lIHRoaW5nIGFzIGluIHRoZSBkZWZhdWx0IGNhc2VcbiAgICAgIC8vKHNlZSBiZWxvdykgLS0gZ2V0dGluZyB0aGluZ3MgcmVhZHkgZm9yIGFuIGFzc2lnbm1lbnQuICBUaGVuIHdlJ3JlXG4gICAgICAvL2dvaW5nIHRvIGZvcmdldCB0aGlzIGZvciBhIGJpdCB3aGlsZSB3ZSBoYW5kbGUgdGhlIHJlc3QuLi5cbiAgICAgIGFzc2lnbm1lbnRzID0ge1xuICAgICAgICAuLi5wcmVhbWJsZUFzc2lnbm1lbnRzLFxuICAgICAgICAuLi5saXRlcmFsQXNzaWdubWVudHMobm9kZSwgYWx0ZXJuYXRlU3RhY2ssIGN1cnJlbnREZXB0aClcbiAgICAgIH07XG5cbiAgICAgIC8vd2UnbGwgbmVlZCB0aGlzXG4gICAgICBiYXNlRXhwcmVzc2lvbiA9IG5vZGUuYmFzZUV4cHJlc3Npb247XG5cbiAgICAgIC8vYnV0IGZpcnN0LCBhIGRpdmVyc2lvbiAtLSBpcyB0aGlzIHNvbWV0aGluZyB0aGF0IGNvdWxkIG5vdCAqcG9zc2libHkqXG4gICAgICAvL2xlYWQgdG8gYSBtYXBwaW5nPyAgaS5lLiwgZWl0aGVyIGEgYnl0ZXMsIG9yIGFuIGFycmF5IG9mIG5vbi1yZWZlcmVuY2VcbiAgICAgIC8vdHlwZXMsIG9yIGEgbm9uLXN0b3JhZ2UgYXJyYXk/XG4gICAgICAvL2lmIHNvLCB3ZSdsbCBqdXN0IGRvIHRoZSBhc3NpZ24gYW5kIHF1aXQgb3V0IGVhcmx5XG4gICAgICAvLyhub3RlOiB3ZSB3cml0ZSBpdCB0aGlzIHdheSBiZWNhdXNlIG1hcHBpbmdzIGFyZW4ndCBjYXVnaHQgYnlcbiAgICAgIC8vaXNSZWZlcmVuY2UpXG4gICAgICBpZiAoXG4gICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUNsYXNzKGJhc2VFeHByZXNzaW9uKSA9PT0gXCJieXRlc1wiIHx8XG4gICAgICAgIChEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVDbGFzcyhiYXNlRXhwcmVzc2lvbikgPT09IFwiYXJyYXlcIiAmJlxuICAgICAgICAgIChEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzUmVmZXJlbmNlKG5vZGUpXG4gICAgICAgICAgICA/IERlY29kZVV0aWxzLkRlZmluaXRpb24ucmVmZXJlbmNlVHlwZShiYXNlRXhwcmVzc2lvbikgIT09IFwic3RvcmFnZVwiXG4gICAgICAgICAgICA6ICFEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzTWFwcGluZyhub2RlKSkpXG4gICAgICApIHtcbiAgICAgICAgZGVidWcoXCJJbmRleCBjYXNlIGJhaWxlZCBvdXQgZWFybHlcIik7XG4gICAgICAgIGRlYnVnKFwidHlwZUNsYXNzICVzXCIsIERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUNsYXNzKGJhc2VFeHByZXNzaW9uKSk7XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgIFwicmVmZXJlbmNlVHlwZSAlc1wiLFxuICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24ucmVmZXJlbmNlVHlwZShiYXNlRXhwcmVzc2lvbilcbiAgICAgICAgKTtcbiAgICAgICAgZGVidWcoXCJpc1JlZmVyZW5jZShub2RlKSAlb1wiLCBEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzUmVmZXJlbmNlKG5vZGUpKTtcbiAgICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsZXQga2V5RGVmaW5pdGlvbiA9IERlY29kZVV0aWxzLkRlZmluaXRpb24ua2V5RGVmaW5pdGlvbihcbiAgICAgICAgYmFzZUV4cHJlc3Npb24sXG4gICAgICAgIHNjb3Blc1xuICAgICAgKTtcbiAgICAgIC8vaWYgd2UncmUgZGVhbGluZyB3aXRoIGFuIGFycmF5LCB0aGlzIHdpbGwganVzdCBzcG9vZiB1cCBhIHVpbnQgZGVmaW5pdGlvblxuICAgICAgLy86KVxuXG4gICAgICAvL25vdy4uLiB0aGUgZGVjb2RpbmchICh0aGlzIGlzIG1lc3N5KVxuICAgICAgbGV0IGluZGV4VmFsdWUgPSB5aWVsZCogZGVjb2RlTWFwcGluZ0tleVNhZ2EoXG4gICAgICAgIG5vZGUuaW5kZXhFeHByZXNzaW9uLFxuICAgICAgICBrZXlEZWZpbml0aW9uXG4gICAgICApO1xuXG4gICAgICBkZWJ1ZyhcImluZGV4IHZhbHVlICVPXCIsIGluZGV4VmFsdWUpO1xuICAgICAgZGVidWcoXCJrZXlEZWZpbml0aW9uICVvXCIsIGtleURlZmluaXRpb24pO1xuXG4gICAgICAvL3doZXchIEJ1dCB3ZSdyZSBub3QgZG9uZSB5ZXQgLS0gd2UgbmVlZCB0byB0dXJuIHRoaXMgZGVjb2RlZCBrZXkgaW50b1xuICAgICAgLy9hbiBhY3R1YWwgcGF0aCAoYXNzdW1pbmcgd2UgKmRpZCogZGVjb2RlIGl0KVxuICAgICAgLy9PSywgbm90IGFuIGFjdHVhbCBwYXRoIC0tIHdlJ3JlIGp1c3QgZ29pbmcgdG8gdXNlIGEgc2ltcGxlIG9mZnNldCBmb3JcbiAgICAgIC8vdGhlIHBhdGguICBCdXQgdGhhdCdzIE9LLCBiZWNhdXNlIHRoZSBtYXBwZWRQYXRocyByZWR1Y2VyIHdpbGwgdHVyblxuICAgICAgLy9pdCBpbnRvIGFuIGFjdHVhbCBwYXRoLlxuICAgICAgaWYgKGluZGV4VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXRoID0gZmV0Y2hCYXNlUGF0aChcbiAgICAgICAgICBiYXNlRXhwcmVzc2lvbixcbiAgICAgICAgICBtYXBwZWRQYXRocyxcbiAgICAgICAgICBjdXJyZW50QXNzaWdubWVudHMsXG4gICAgICAgICAgY3VycmVudERlcHRoXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IHNsb3QgPSB7IHBhdGggfTtcblxuICAgICAgICAvL3dlIG5lZWQgdG8gZG8gdGhpbmdzIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIGRlYWxpbmdcbiAgICAgICAgLy93aXRoIGFuIGFycmF5IG9yIG1hcHBpbmdcbiAgICAgICAgc3dpdGNoIChEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVDbGFzcyhiYXNlRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHNsb3QuaGFzaFBhdGggPSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzRHluYW1pY0FycmF5KFxuICAgICAgICAgICAgICBiYXNlRXhwcmVzc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNsb3Qub2Zmc2V0ID0gaW5kZXhWYWx1ZS5tdWxuKFxuICAgICAgICAgICAgICBzdG9yYWdlU2l6ZShub2RlLCByZWZlcmVuY2VEZWNsYXJhdGlvbnMsIGFsbG9jYXRpb25zKS53b3Jkc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtYXBwaW5nXCI6XG4gICAgICAgICAgICBzbG90LmtleSA9IGluZGV4VmFsdWU7XG4gICAgICAgICAgICBzbG90LmtleUVuY29kaW5nID0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5rZXlFbmNvZGluZyhcbiAgICAgICAgICAgICAga2V5RGVmaW5pdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNsb3Qub2Zmc2V0ID0gbmV3IEJOKDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRlYnVnKFwidW5yZWNvZ25pemVkIGluZGV4IGFjY2VzcyFcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJzbG90ICVPXCIsIHNsb3QpO1xuXG4gICAgICAgIC8vbm93LCBtYXAgaXQhIChhbmQgZG8gdGhlIGFzc2lnbiBhcyB3ZWxsKVxuICAgICAgICB5aWVsZCBwdXQoXG4gICAgICAgICAgYWN0aW9ucy5tYXBQYXRoQW5kQXNzaWduKFxuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHNsb3QsXG4gICAgICAgICAgICBhc3NpZ25tZW50cyxcbiAgICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUlkZW50aWZpZXIobm9kZSksXG4gICAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVJZGVudGlmaWVyKGJhc2VFeHByZXNzaW9uKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vaWYgd2UgZmFpbGVkIHRvIGRlY29kZSwganVzdCBkbyB0aGUgYXNzaWduIGZyb20gYWJvdmVcbiAgICAgICAgZGVidWcoXCJmYWlsZWQgdG8gZGVjb2RlLCBqdXN0IGFzc2lnbmluZ1wiKTtcbiAgICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIk1lbWJlckFjY2Vzc1wiOlxuICAgICAgLy9IQUNLOiB3ZSB1c2UgdGhlIGFsdGVybmF0ZSBzdGFjayBpbiB0aGlzIGNhc2VcblxuICAgICAgLy93ZSdyZSBnb2luZyB0byBzdGFydCBieSBkb2luZyB0aGUgc2FtZSB0aGluZyBhcyBpbiB0aGUgZGVmYXVsdCBjYXNlXG4gICAgICAvLyhzZWUgYmVsb3cpIC0tIGdldHRpbmcgdGhpbmdzIHJlYWR5IGZvciBhbiBhc3NpZ25tZW50LiAgVGhlbiB3ZSdyZVxuICAgICAgLy9nb2luZyB0byBmb3JnZXQgdGhpcyBmb3IgYSBiaXQgd2hpbGUgd2UgaGFuZGxlIHRoZSByZXN0Li4uXG4gICAgICBhc3NpZ25tZW50cyA9IHtcbiAgICAgICAgLi4ucHJlYW1ibGVBc3NpZ25tZW50cyxcbiAgICAgICAgLi4ubGl0ZXJhbEFzc2lnbm1lbnRzKG5vZGUsIGFsdGVybmF0ZVN0YWNrLCBjdXJyZW50RGVwdGgpXG4gICAgICB9O1xuXG4gICAgICBkZWJ1ZyhcIk1lbWJlciBhY2Nlc3MgY2FzZVwiKTtcblxuICAgICAgLy9NZW1iZXJBY2Nlc3MgdXNlcyBleHByZXNzaW9uLCBub3QgYmFzZUV4cHJlc3Npb25cbiAgICAgIGJhc2VFeHByZXNzaW9uID0gbm9kZS5leHByZXNzaW9uO1xuXG4gICAgICAvL2lmIHRoaXMgaXNuJ3QgYSBzdG9yYWdlIHN0cnVjdCwgb3IgdGhlIGVsZW1lbnQgaXNuJ3Qgb2YgcmVmZXJlbmNlIHR5cGUsXG4gICAgICAvL3dlJ2xsIGp1c3QgZG8gdGhlIGFzc2lnbm1lbnQgYW5kIHF1aXQgb3V0IChhZ2Fpbiwgbm90ZSB0aGF0IG1hcHBpbmdzXG4gICAgICAvL2FyZW4ndCBjYXVnaHQgYnkgaXNSZWZlcmVuY2UpXG4gICAgICBpZiAoXG4gICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUNsYXNzKGJhc2VFeHByZXNzaW9uKSAhPT0gXCJzdHJ1Y3RcIiB8fFxuICAgICAgICAoRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc1JlZmVyZW5jZShub2RlKVxuICAgICAgICAgID8gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5yZWZlcmVuY2VUeXBlKGJhc2VFeHByZXNzaW9uKSAhPT0gXCJzdG9yYWdlXCJcbiAgICAgICAgICA6ICFEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzTWFwcGluZyhub2RlKSlcbiAgICAgICkge1xuICAgICAgICBkZWJ1ZyhcIk1lbWJlciBjYXNlIGJhaWxlZCBvdXQgZWFybHlcIik7XG4gICAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbihhc3NpZ25tZW50cykpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy9idXQgaWYgaXQgaXMgYSBzdG9yYWdlIHN0cnVjdCwgd2UgaGF2ZSB0byBtYXAgdGhlIHBhdGggYXMgd2VsbFxuICAgICAgcGF0aCA9IGZldGNoQmFzZVBhdGgoXG4gICAgICAgIGJhc2VFeHByZXNzaW9uLFxuICAgICAgICBtYXBwZWRQYXRocyxcbiAgICAgICAgY3VycmVudEFzc2lnbm1lbnRzLFxuICAgICAgICBjdXJyZW50RGVwdGhcbiAgICAgICk7XG5cbiAgICAgIHNsb3QgPSB7IHBhdGggfTtcblxuICAgICAgbGV0IHN0cnVjdElkID0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi50eXBlSWQoYmFzZUV4cHJlc3Npb24pO1xuICAgICAgbGV0IG1lbWJlckFsbG9jYXRpb24gPVxuICAgICAgICBhbGxvY2F0aW9uc1tzdHJ1Y3RJZF0ubWVtYmVyc1tub2RlLnJlZmVyZW5jZWREZWNsYXJhdGlvbl07XG5cbiAgICAgIHNsb3Qub2Zmc2V0ID0gbWVtYmVyQWxsb2NhdGlvbi5wb2ludGVyLnN0b3JhZ2UuZnJvbS5zbG90Lm9mZnNldC5jbG9uZSgpO1xuXG4gICAgICBkZWJ1ZyhcInNsb3QgJW9cIiwgc2xvdCk7XG4gICAgICB5aWVsZCBwdXQoXG4gICAgICAgIGFjdGlvbnMubWFwUGF0aEFuZEFzc2lnbihcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIHNsb3QsXG4gICAgICAgICAgYXNzaWdubWVudHMsXG4gICAgICAgICAgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi50eXBlSWRlbnRpZmllcihub2RlKSxcbiAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVJZGVudGlmaWVyKGJhc2VFeHByZXNzaW9uKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChub2RlLnR5cGVEZXNjcmlwdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZyhcImRlY29kaW5nIGV4cHJlc3Npb24gdmFsdWUgJU9cIiwgbm9kZS50eXBlRGVzY3JpcHRpb25zKTtcbiAgICAgIGRlYnVnKFwiZGVmYXVsdCBjYXNlXCIpO1xuICAgICAgZGVidWcoXCJjdXJyZW50RGVwdGggJWQgbm9kZS5pZCAlZFwiLCBjdXJyZW50RGVwdGgsIG5vZGUuaWQpO1xuXG4gICAgICBhc3NpZ25tZW50cyA9IHtcbiAgICAgICAgLi4ucHJlYW1ibGVBc3NpZ25tZW50cyxcbiAgICAgICAgLi4ubGl0ZXJhbEFzc2lnbm1lbnRzKG5vZGUsIHN0YWNrLCBjdXJyZW50RGVwdGgpXG4gICAgICB9O1xuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiogZGVjb2RlTWFwcGluZ0tleVNhZ2EoaW5kZXhEZWZpbml0aW9uLCBrZXlEZWZpbml0aW9uKSB7XG4gIGxldCBzY29wZXMgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5zY29wZXMuaW5saW5lZCk7XG4gIGxldCBjdXJyZW50QXNzaWdubWVudHMgPSB5aWVsZCBzZWxlY3QoZGF0YS5wcm9jLmFzc2lnbm1lbnRzKTtcbiAgbGV0IGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG5cbiAgLy93aHkgdGhlIGxvb3A/IHNlZSB0aGUgZW5kIG9mIHRoZSBibG9jayBpdCBoZWFkcyBmb3IgYW4gZXhwbGFuYXRvcnlcbiAgLy9jb21tZW50XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IGluZGV4SWQgPSBpbmRleERlZmluaXRpb24uaWQ7XG4gICAgLy9pbmRpY2VzIG5lZWQgdG8gYmUgaWRlbnRpZmllZCBieSBzdGFja2ZyYW1lXG4gICAgbGV0IGluZGV4SWRPYmogPSB7IGFzdElkOiBpbmRleElkLCBzdGFja2ZyYW1lOiBjdXJyZW50RGVwdGggfTtcbiAgICBsZXQgZnVsbEluZGV4SWQgPSBzdGFibGVLZWNjYWsyNTYoaW5kZXhJZE9iaik7XG5cbiAgICBjb25zdCBpbmRleFJlZmVyZW5jZSA9IChjdXJyZW50QXNzaWdubWVudHMuYnlJZFtmdWxsSW5kZXhJZF0gfHwge30pLnJlZjtcblxuICAgIGlmIChEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzU2ltcGxlQ29uc3RhbnQoaW5kZXhEZWZpbml0aW9uKSkge1xuICAgICAgLy93aGlsZSB0aGUgbWFpbiBjYXNlIGlzIHRoZSBuZXh0IG9uZSwgd2hlcmUgd2UgbG9vayBmb3IgYSBwcmlvclxuICAgICAgLy9hc3NpZ25tZW50LCB3ZSBuZWVkIHRoaXMgY2FzZSAoYW5kIG5lZWQgaXQgZmlyc3QpIGZvciB0d28gcmVhc29uczpcbiAgICAgIC8vMS4gc29tZSBjb25zdGFudCBleHByZXNzaW9ucyAoc3BlY2lmaWNhbGx5LCBzdHJpbmcgYW5kIGhleCBsaXRlcmFscylcbiAgICAgIC8vYXJlbid0IHNvdXJjZW1hcHBlZCB0byBhbmQgc28gd29uJ3QgaGF2ZSBhIHByaW9yIGFzc2lnbm1lbnRcbiAgICAgIC8vMi4gaWYgdGhlIGtleSB0eXBlIGlzIGJ5dGVzTiBidXQgdGhlIGV4cHJlc3Npb24gaXMgY29uc3RhbnQsIHRoZVxuICAgICAgLy92YWx1ZSB3aWxsIGdvIG9uIHRoZSBzdGFjayAqbGVmdCotcGFkZGVkIGluc3RlYWQgb2YgcmlnaHQtcGFkZGVkLFxuICAgICAgLy9zbyBsb29raW5nIGZvciBhIHByaW9yIGFzc2lnbm1lbnQgd2lsbCByZWFkIHRoZSB3cm9uZyB2YWx1ZS5cbiAgICAgIC8vc28gaW5zdGVhZCBpdCdzIHByZWZlcmFibGUgdG8gdXNlIHRoZSBjb25zdGFudCBkaXJlY3RseS5cbiAgICAgIGRlYnVnKFwiYWJvdXQgdG8gZGVjb2RlIHNpbXBsZSBsaXRlcmFsXCIpO1xuICAgICAgcmV0dXJuIHlpZWxkKiBkZWNvZGUoa2V5RGVmaW5pdGlvbiwge1xuICAgICAgICBkZWZpbml0aW9uOiBpbmRleERlZmluaXRpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5kZXhSZWZlcmVuY2UpIHtcbiAgICAgIC8vaWYgYSBwcmlvciBhc3NpZ25tZW50IGlzIGZvdW5kXG4gICAgICBsZXQgc3BsaWNlZERlZmluaXRpb247XG4gICAgICAvL2luIGdlbmVyYWwsIHdlIHdhbnQgdG8gZGVjb2RlIHVzaW5nIHRoZSBrZXkgZGVmaW5pdGlvbiwgbm90IHRoZSBpbmRleFxuICAgICAgLy9kZWZpbml0aW9uLiBob3dldmVyLCB0aGUga2V5IGRlZmluaXRpb24gbWF5IGhhdmUgdGhlIHdyb25nIGxvY2F0aW9uXG4gICAgICAvL29uIGl0LiAgc28sIHdoZW4gYXBwbGljYWJsZSwgd2Ugc3BsaWNlIHRoZSBpbmRleCBkZWZpbml0aW9uIGxvY2F0aW9uXG4gICAgICAvL29udG8gdGhlIGtleSBkZWZpbml0aW9uIGxvY2F0aW9uLlxuICAgICAgaWYgKERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNSZWZlcmVuY2UoaW5kZXhEZWZpbml0aW9uKSkge1xuICAgICAgICBzcGxpY2VkRGVmaW5pdGlvbiA9IERlY29kZVV0aWxzLkRlZmluaXRpb24uc3BsaWNlTG9jYXRpb24oXG4gICAgICAgICAga2V5RGVmaW5pdGlvbixcbiAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnJlZmVyZW5jZVR5cGUoaW5kZXhEZWZpbml0aW9uKVxuICAgICAgICApO1xuICAgICAgICAvL3dlIGNvdWxkIHB1dCBjb2RlIGhlcmUgdG8gYWRkIG9uIHRoZSBcIl9wdHJcIiBlbmRpbmcgd2hlbiBhYnNlbnQsXG4gICAgICAgIC8vYnV0IHdlIHByZXNlbnRseSBpZ25vcmUgdGhhdCBlbmRpbmcsIHNvIHdlJ2xsIHNraXAgdGhhdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlZERlZmluaXRpb24gPSBrZXlEZWZpbml0aW9uO1xuICAgICAgfVxuICAgICAgZGVidWcoXCJhYm91dCB0byBkZWNvZGVcIik7XG4gICAgICByZXR1cm4geWllbGQqIGRlY29kZShzcGxpY2VkRGVmaW5pdGlvbiwgaW5kZXhSZWZlcmVuY2UpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpbmRleERlZmluaXRpb24ucmVmZXJlbmNlZERlY2xhcmF0aW9uICYmXG4gICAgICBzY29wZXNbaW5kZXhEZWZpbml0aW9uLnJlZmVyZW5jZWREZWNsYXJhdGlvbl1cbiAgICApIHtcbiAgICAgIC8vdGhlcmUncyBvbmUgbW9yZSByZWFzb24gd2UgbWlnaHQgaGF2ZSBmYWlsZWQgdG8gZGVjb2RlIGl0OiBpdCBtaWdodCBiZSBhXG4gICAgICAvL2NvbnN0YW50IHN0YXRlIHZhcmlhYmxlLiAgVW5mb3J0dW5hdGVseSwgd2UgZG9uJ3Qga25vdyBob3cgdG8gZGVjb2RlIGFsbFxuICAgICAgLy90aG9zZSBhdCB0aGUgbW9tZW50LCBidXQgd2UgY2FuIGhhbmRsZSB0aGUgb25lcyB3ZSBkbyBrbm93IGhvdyB0byBkZWNvZGUuXG4gICAgICAvL0luIHRoZSBmdXR1cmUgaG9wZWZ1bGx5IHdlIHdpbGwgZGVjb2RlIGFsbCBvZiB0aGVtXG4gICAgICBkZWJ1ZyhcInJlZmVyZW5jZWREZWNsYXJhdGlvbiAlZFwiLCBpbmRleERlZmluaXRpb24ucmVmZXJlbmNlZERlY2xhcmF0aW9uKTtcbiAgICAgIGxldCBpbmRleENvbnN0YW50RGVjbGFyYXRpb24gPVxuICAgICAgICBzY29wZXNbaW5kZXhEZWZpbml0aW9uLnJlZmVyZW5jZWREZWNsYXJhdGlvbl0uZGVmaW5pdGlvbjtcbiAgICAgIGRlYnVnKFwiaW5kZXhDb25zdGFudERlY2xhcmF0aW9uICVPXCIsIGluZGV4Q29uc3RhbnREZWNsYXJhdGlvbik7XG4gICAgICBpZiAoaW5kZXhDb25zdGFudERlY2xhcmF0aW9uLmNvbnN0YW50KSB7XG4gICAgICAgIGxldCBpbmRleENvbnN0YW50RGVmaW5pdGlvbiA9IGluZGV4Q29uc3RhbnREZWNsYXJhdGlvbi52YWx1ZTtcbiAgICAgICAgLy9uZXh0IGxpbmUgZmlsdGVycyBvdXQgY29uc3RhbnRzIHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZVxuICAgICAgICBpZiAoRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc1NpbXBsZUNvbnN0YW50KGluZGV4Q29uc3RhbnREZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlYnVnKFwiYWJvdXQgdG8gZGVjb2RlIHNpbXBsZSBjb25zdGFudFwiKTtcbiAgICAgICAgICByZXR1cm4geWllbGQqIGRlY29kZShrZXlEZWZpbml0aW9uLCB7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBpbmRleENvbnN0YW50RGVjbGFyYXRpb24udmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDsgLy9jYW4ndCBkZWNvZGU7IHNlZSBiZWxvdyBmb3IgbW9yZSBleHBsYW5hdGlvblxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy9jYW4ndCBkZWNvZGU7IHNlZSBiZWxvdyBmb3IgbW9yZSBleHBsYW5hdGlvblxuICAgICAgfVxuICAgIH1cbiAgICAvL3RoZXJlJ3Mgc3RpbGwgb25lIG1vcmUgcmVhc29uIHdlIG1pZ2h0IGhhdmUgZmFpbGVkIHRvIGRlY29kZSBpdDpcbiAgICAvL2NlcnRhaW4gKHNpbGVudCkgdHlwZSBjb252ZXJzaW9ucyBhcmVuJ3Qgc291cmNlbWFwcGVkIGVpdGhlci5cbiAgICAvLyh0aGFua2Z1bGx5LCBhbnkgdHlwZSBjb252ZXJzaW9uIHRoYXQgYWN0dWFsbHkgKmRvZXMqIHNvbWV0aGluZyBzZWVtc1xuICAgIC8vdG8gYmUgc291cmNlbWFwcGVkLikgIFNvIGlmIHdlJ3ZlIGZhaWxlZCB0byBkZWNvZGUgaXQsIHdlIHRyeSBhZ2FpblxuICAgIC8vd2l0aCB0aGUgYXJndW1lbnQgb2YgdGhlIHR5cGUgY29udmVyc2lvbiwgaWYgaXQgaXMgb25lOyB3ZSBsZWF2ZVxuICAgIC8vaW5kZXhWYWx1ZSB1bmRlZmluZWQgc28gdGhlIGxvb3Agd2lsbCBjb250aW51ZVxuICAgIC8vKG5vdGUgdGhhdCB0aGlzIGNhc2UgaXMgbGFzdCBmb3IgYSByZWFzb247IGlmIHRoaXMgd2VyZSBlYXJsaWVyLCBpdFxuICAgIC8vd291bGQgY2F0Y2ggKm5vbiotc2lsZW50IHR5cGUgY29udmVyc2lvbnMsIHdoaWNoIHdlIHdhbnQgdG8ganVzdCByZWFkXG4gICAgLy9vZmYgdGhlIHN0YWNrKVxuICAgIGVsc2UgaWYgKGluZGV4RGVmaW5pdGlvbi5raW5kID09PSBcInR5cGVDb252ZXJzaW9uXCIpIHtcbiAgICAgIGluZGV4RGVmaW5pdGlvbiA9IGluZGV4RGVmaW5pdGlvbi5hcmd1bWVudHNbMF07XG4gICAgfVxuICAgIC8vLi4uYWxzbyBwcmlvciB0byAwLjUuMCwgdW5hcnkgKyB3YXMgbGVnYWwsIHdoaWNoIG5lZWRzIHRvIGJlIGFjY291bnRlZFxuICAgIC8vZm9yIGZvciB0aGUgc2FtZSByZWFzb25cbiAgICBlbHNlIGlmIChcbiAgICAgIGluZGV4RGVmaW5pdGlvbi5ub2RlVHlwZSA9PT0gXCJVbmFyeU9wZXJhdGlvblwiICYmXG4gICAgICBpbmRleERlZmluaXRpb24ub3BlcmF0b3IgPT09IFwiK1wiXG4gICAgKSB7XG4gICAgICBpbmRleERlZmluaXRpb24gPSBpbmRleERlZmluaXRpb24uc3ViRXhwcmVzc2lvbjtcbiAgICB9XG4gICAgLy9vdGhlcndpc2UsIHdlJ3ZlIGp1c3QgdG90YWxseSBmYWlsZWQgdG8gZGVjb2RlIGl0LCBzbyB3ZSBtYXJrXG4gICAgLy9pbmRleFZhbHVlIGFzIG51bGwgKGFzIGRpc3RpbmN0IGZyb20gdW5kZWZpbmVkKSB0byBpbmRpY2F0ZSB0aGlzLiAgSW5cbiAgICAvL3RoZSBmdXR1cmUsIHdlIHNob3VsZCBiZSBhYmxlIHRvIGRlY29kZSBhbGwgbWFwcGluZyBrZXlzLCBidXQgd2UncmVcbiAgICAvL25vdCBxdWl0ZSB0aGVyZSB5ZXQsIHNvcnJ5IChiZWNhdXNlIHdlIGNhbid0IHlldCBoYW5kbGUgYWxsIGNvbnN0YW50XG4gICAgLy9zdGF0ZSB2YXJpYWJsZXMpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy9ub3csIGFzIG1lbnRpb25lZCwgcmV0cnkgaW4gdGhlIHR5cGVDb252ZXJzaW9uIGNhc2VcbiAgICAvLyhvciB1bmFyeSArIGNhc2UpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZXNldCgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVzZXQoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcmVjb3JkQWxsb2NhdGlvbnMoKSB7XG4gIGNvbnN0IGNvbnRyYWN0cyA9IHlpZWxkIHNlbGVjdChcbiAgICBkYXRhLnZpZXdzLnVzZXJEZWZpbmVkVHlwZXMuY29udHJhY3REZWZpbml0aW9uc1xuICApO1xuICBkZWJ1ZyhcImNvbnRyYWN0cyAlT1wiLCBjb250cmFjdHMpO1xuICBjb25zdCByZWZlcmVuY2VEZWNsYXJhdGlvbnMgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5yZWZlcmVuY2VEZWNsYXJhdGlvbnMpO1xuICBkZWJ1ZyhcInJlZmVyZW5jZURlY2xhcmF0aW9ucyAlT1wiLCByZWZlcmVuY2VEZWNsYXJhdGlvbnMpO1xuICBjb25zdCBzdG9yYWdlQWxsb2NhdGlvbnMgPSBnZXRTdG9yYWdlQWxsb2NhdGlvbnMoXG4gICAgcmVmZXJlbmNlRGVjbGFyYXRpb25zLFxuICAgIGNvbnRyYWN0c1xuICApO1xuICBkZWJ1ZyhcInN0b3JhZ2VBbGxvY2F0aW9ucyAlT1wiLCBzdG9yYWdlQWxsb2NhdGlvbnMpO1xuICBjb25zdCBtZW1vcnlBbGxvY2F0aW9ucyA9IGdldE1lbW9yeUFsbG9jYXRpb25zKHJlZmVyZW5jZURlY2xhcmF0aW9ucyk7XG4gIGNvbnN0IGNhbGxkYXRhQWxsb2NhdGlvbnMgPSBnZXRDYWxsZGF0YUFsbG9jYXRpb25zKHJlZmVyZW5jZURlY2xhcmF0aW9ucyk7XG4gIHlpZWxkIHB1dChcbiAgICBhY3Rpb25zLmFsbG9jYXRlKHN0b3JhZ2VBbGxvY2F0aW9ucywgbWVtb3J5QWxsb2NhdGlvbnMsIGNhbGxkYXRhQWxsb2NhdGlvbnMpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGxpdGVyYWxBc3NpZ25tZW50cyhub2RlLCBzdGFjaywgY3VycmVudERlcHRoKSB7XG4gIGxldCB0b3AgPSBzdGFjay5sZW5ndGggLSAxO1xuXG4gIGxldCBsaXRlcmFsID0gcmVhZFN0YWNrKFxuICAgIHN0YWNrLFxuICAgIHRvcCAtIERlY29kZVV0aWxzLkRlZmluaXRpb24uc3RhY2tTaXplKG5vZGUpICsgMSxcbiAgICB0b3BcbiAgKTtcblxuICBsZXQgYXNzaWdubWVudCA9IG1ha2VBc3NpZ25tZW50KFxuICAgIHsgYXN0SWQ6IG5vZGUuaWQsIHN0YWNrZnJhbWU6IGN1cnJlbnREZXB0aCB9LFxuICAgIHsgbGl0ZXJhbCB9XG4gICk7XG5cbiAgcmV0dXJuIHsgW2Fzc2lnbm1lbnQuaWRdOiBhc3NpZ25tZW50IH07XG59XG5cbi8vdGFrZXMgYSBwYXJhbWV0ZXIgbGlzdCBhcyBnaXZlbiBpbiB0aGUgQVNUXG5mdW5jdGlvbiBhc3NpZ25QYXJhbWV0ZXJzKHBhcmFtZXRlcnMsIHRvcCwgZnVuY3Rpb25EZXB0aCkge1xuICBsZXQgcmV2ZXJzZVBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAvL3JldmVyc2UgaXMgaW4tcGxhY2UsIHNvIHdlIHVzZSBzbGljZSgpIHRvIGNsb25lIGZpcnN0XG4gIGRlYnVnKFwicmV2ZXJzZVBhcmFtZXRlcnMgJW9cIiwgcGFyYW1ldGVycyk7XG5cbiAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHRvcDtcbiAgbGV0IGFzc2lnbm1lbnRzID0ge307XG5cbiAgZm9yIChsZXQgcGFyYW1ldGVyIG9mIHJldmVyc2VQYXJhbWV0ZXJzKSB7XG4gICAgbGV0IHdvcmRzID0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5zdGFja1NpemUocGFyYW1ldGVyKTtcbiAgICBsZXQgcG9pbnRlciA9IHtcbiAgICAgIHN0YWNrOiB7XG4gICAgICAgIGZyb206IGN1cnJlbnRQb3NpdGlvbiAtIHdvcmRzICsgMSxcbiAgICAgICAgdG86IGN1cnJlbnRQb3NpdGlvblxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGFzc2lnbm1lbnQgPSBtYWtlQXNzaWdubWVudChcbiAgICAgIHsgYXN0SWQ6IHBhcmFtZXRlci5pZCwgc3RhY2tmcmFtZTogZnVuY3Rpb25EZXB0aCB9LFxuICAgICAgcG9pbnRlclxuICAgICk7XG4gICAgYXNzaWdubWVudHNbYXNzaWdubWVudC5pZF0gPSBhc3NpZ25tZW50O1xuICAgIGN1cnJlbnRQb3NpdGlvbiAtPSB3b3JkcztcbiAgfVxuICByZXR1cm4gYXNzaWdubWVudHM7XG59XG5cbmZ1bmN0aW9uIGZldGNoQmFzZVBhdGgoXG4gIGJhc2VOb2RlLFxuICBtYXBwZWRQYXRocyxcbiAgY3VycmVudEFzc2lnbm1lbnRzLFxuICBjdXJyZW50RGVwdGhcbikge1xuICBsZXQgZnVsbElkID0gc3RhYmxlS2VjY2FrMjU2KHtcbiAgICBhc3RJZDogYmFzZU5vZGUuaWQsXG4gICAgc3RhY2tmcmFtZTogY3VycmVudERlcHRoXG4gIH0pO1xuICBkZWJ1ZyhcImFzdElkOiAlZFwiLCBiYXNlTm9kZS5pZCk7XG4gIGRlYnVnKFwic3RhY2tmcmFtZTogJWRcIiwgY3VycmVudERlcHRoKTtcbiAgZGVidWcoXCJmdWxsSWQ6ICVzXCIsIGZ1bGxJZCk7XG4gIGRlYnVnKFwiY3VycmVudEFzc2lnbm1lbnRzOiAlT1wiLCBjdXJyZW50QXNzaWdubWVudHMpO1xuICAvL2Jhc2UgZXhwcmVzc2lvbiBpcyBhbiBleHByZXNzaW9uLCBhbmQgc28gaGFzIGEgbGl0ZXJhbCBhc3NpZ25lZCB0b1xuICAvL2l0XG4gIGxldCBvZmZzZXQgPSBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQk4oXG4gICAgY3VycmVudEFzc2lnbm1lbnRzLmJ5SWRbZnVsbElkXS5yZWYubGl0ZXJhbFxuICApO1xuICByZXR1cm4geyBvZmZzZXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICB5aWVsZCB0YWtlRXZlcnkoVElDSywgdGlja1NhZ2EpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiZGF0YVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9zYWdhcy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIlxuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3ZhbHVlc1wiXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgQURWQU5DRSA9IFwiQURWQU5DRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkdmFuY2UoY291bnQpIHtcbiAgcmV0dXJuIHsgdHlwZTogQURWQU5DRSwgY291bnQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfTkVYVCA9IFwiU1RFUF9ORVhUXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE5leHQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFNURVBfTkVYVCB9O1xufVxuXG5leHBvcnQgY29uc3QgU1RFUF9PVkVSID0gXCJTVEVQX09WRVJcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwT3ZlcigpIHtcbiAgcmV0dXJuIHsgdHlwZTogU1RFUF9PVkVSIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVEVQX0lOVE8gPSBcIlNURVBfSU5UT1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBJbnRvKCkge1xuICByZXR1cm4geyB0eXBlOiBTVEVQX0lOVE8gfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfT1VUID0gXCJTVEVQX09VVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBPdXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFNURVBfT1VUIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVNFVCA9IFwiUkVTRVRcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNldCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogUkVTRVQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IElOVEVSUlVQVCA9IFwiQ09OVFJPTExFUl9JTlRFUlJVUFRcIjtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnJ1cHQoKSB7XG4gIHJldHVybiB7IHR5cGU6IElOVEVSUlVQVCB9O1xufVxuXG5leHBvcnQgY29uc3QgQ09OVElOVUUgPSBcIkNPTlRJTlVFXCI7XG5leHBvcnQgZnVuY3Rpb24gY29udGludWVVbnRpbEJyZWFrcG9pbnQoYnJlYWtwb2ludHMpIHtcbiAgLy9cImNvbnRpbnVlXCIgaXMgbm90IGEgbGVnYWwgbmFtZVxuICByZXR1cm4ge1xuICAgIHR5cGU6IENPTlRJTlVFLFxuICAgIGJyZWFrcG9pbnRzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBBRERfQlJFQUtQT0lOVCA9IFwiQUREX0JSRUFLUE9JTlRcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRCcmVha3BvaW50KGJyZWFrcG9pbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBRERfQlJFQUtQT0lOVCxcbiAgICBicmVha3BvaW50XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRU1PVkVfQlJFQUtQT0lOVCA9IFwiUkVNT1ZFX0JSRUFLUE9JTlRcIjtcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVCcmVha3BvaW50KGJyZWFrcG9pbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRU1PVkVfQlJFQUtQT0lOVCxcbiAgICBicmVha3BvaW50XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRU1PVkVfQUxMX0JSRUFLUE9JTlRTID0gXCJSRU1PVkVfQUxMX0JSRUFLUE9JTlRTXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsQnJlYWtwb2ludHMoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVNT1ZFX0FMTF9CUkVBS1BPSU5UU1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgU1RBUlRfU1RFUFBJTkcgPSBcIlNUQVJUX1NURVBQSU5HXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RhcnRTdGVwcGluZygpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTVEFSVF9TVEVQUElOR1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRE9ORV9TVEVQUElORyA9IFwiRE9ORV9TVEVQUElOR1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRvbmVTdGVwcGluZygpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBET05FX1NURVBQSU5HXG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2NvbnRyb2xsZXIvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpkYXRhOnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbi1wb2ludGVyXCI7XG5cbmltcG9ydCB7IHN0YWJsZUtlY2NhazI1NiB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCAqIGFzIERlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGlkZW50aXR5ID0geCA9PiB4O1xuXG5mdW5jdGlvbiBmaW5kQW5jZXN0b3JPZlR5cGUobm9kZSwgdHlwZXMsIHNjb3Blcykge1xuICAvL25vdGU6IEknbSBub3QgaW5jbHVkaW5nIGFueSBwcm90ZWN0aW9uIGFnYWluc3QgbnVsbCBpbiB0aGlzIGZ1bmN0aW9uLlxuICAvL1lvdSBhcmUgYWR2aXNlZCB0byBpbmNsdWRlIFwiU291cmNlVW5pdFwiIGFzIGEgZmFsbGJhY2sgdHlwZS5cbiAgd2hpbGUgKG5vZGUgJiYgIXR5cGVzLmluY2x1ZGVzKG5vZGUubm9kZVR5cGUpKSB7XG4gICAgbm9kZSA9IHNjb3Blc1tzY29wZXNbbm9kZS5pZF0ucGFyZW50SWRdLmRlZmluaXRpb247XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vZ2l2ZW4gYSBtb2RpZmllciBpbnZvY2F0aW9uIChvciBpbmhlcml0YW5jZSBzcGVjaWZpZXIpIG5vZGUsXG4vL2dldCB0aGUgbm9kZSBmb3IgdGhlIGFjdHVhbCBtb2RpZmllciAob3IgY29uc3RydWN0b3IpXG5mdW5jdGlvbiBtb2RpZmllckZvckludm9jYXRpb24oaW52b2NhdGlvbiwgc2NvcGVzKSB7XG4gIGxldCByYXdJZDsgLy9yYXcgcmVmZXJlbmNlZERlY2xhcmF0aW9uIElEIGV4dHJhY3RlZCBmcm9tIHRoZSBBU1QuXG4gIC8vaWYgaXQncyBhIG1vZGlmaWVyIHRoaXMgaXMgd2hhdCB3ZSB3YW50LCBidXQgaWYgaXQncyBiYXNlXG4gIC8vY29uc3RydWN0b3IsIHdlJ2xsIGdldCB0aGUgY29udHJhY3QgaW5zdGVhZCwgYW5kIG5lZWQgdG8gZmluZCBpdHNcbiAgLy9jb25zdHJ1Y3Rvci5cbiAgc3dpdGNoIChpbnZvY2F0aW9uLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBcIk1vZGlmaWVySW52b2NhdGlvblwiOlxuICAgICAgcmF3SWQgPSBpbnZvY2F0aW9uLm1vZGlmaWVyTmFtZS5yZWZlcmVuY2VkRGVjbGFyYXRpb247XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiSW5oZXJpdGFuY2VTcGVjaWZpZXJcIjpcbiAgICAgIHJhd0lkID0gaW52b2NhdGlvbi5iYXNlTmFtZS5yZWZlcmVuY2VkRGVjbGFyYXRpb247XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZGVidWcoXCJiYWQgaW52b2NhdGlvbiBub2RlXCIpO1xuICB9XG4gIGxldCByYXdOb2RlID0gc2NvcGVzW3Jhd0lkXS5kZWZpbml0aW9uO1xuICBzd2l0Y2ggKHJhd05vZGUubm9kZVR5cGUpIHtcbiAgICBjYXNlIFwiTW9kaWZpZXJEZWZpbml0aW9uXCI6XG4gICAgICByZXR1cm4gcmF3Tm9kZTtcbiAgICBjYXNlIFwiQ29udHJhY3REZWZpbml0aW9uXCI6XG4gICAgICByZXR1cm4gcmF3Tm9kZS5ub2Rlcy5maW5kKFxuICAgICAgICBub2RlID0+XG4gICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gXCJGdW5jdGlvbkRlZmluaXRpb25cIiAmJlxuICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24uZnVuY3Rpb25LaW5kKG5vZGUpID09PSBcImNvbnN0cnVjdG9yXCJcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vd2Ugc2hvdWxkIG5ldmVyIGhpdCB0aGlzIGNhc2VcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLy9zZWUgZGF0YS52aWV3cy5jb250ZXh0cyBmb3IgYW4gZXhwbGFuYXRpb25cbmZ1bmN0aW9uIGRlYnVnZ2VyQ29udGV4dFRvRGVjb2RlckNvbnRleHQoY29udGV4dCkge1xuICBsZXQge1xuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBiaW5hcnksXG4gICAgY29udHJhY3RJZCxcbiAgICBjb250cmFjdEtpbmQsXG4gICAgaXNDb25zdHJ1Y3RvcixcbiAgICBhYmlcbiAgfSA9IGNvbnRleHQ7XG4gIHJldHVybiB7XG4gICAgY29udHJhY3ROYW1lLFxuICAgIGJpbmFyeSxcbiAgICBjb250cmFjdElkLFxuICAgIGNvbnRyYWN0S2luZCxcbiAgICBpc0NvbnN0cnVjdG9yLFxuICAgIGFiaTogRGVjb2RlVXRpbHMuQ29udGV4dHMuYWJpVG9GdW5jdGlvbkFiaVdpdGhTaWduYXR1cmVzKGFiaSlcbiAgfTtcbn1cblxuY29uc3QgZGF0YSA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5kYXRhLFxuXG4gIC8qKlxuICAgKiBkYXRhLnZpZXdzXG4gICAqL1xuICB2aWV3czoge1xuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy5hdExhc3RJbnN0cnVjdGlvbkZvclNvdXJjZVJhbmdlXG4gICAgICovXG4gICAgYXRMYXN0SW5zdHJ1Y3Rpb25Gb3JTb3VyY2VSYW5nZTogY3JlYXRlTGVhZihcbiAgICAgIFtzb2xpZGl0eS5jdXJyZW50LmlzU291cmNlUmFuZ2VGaW5hbF0sXG4gICAgICBmaW5hbCA9PiBmaW5hbFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLnNjb3BlcyAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIHNjb3Blczoge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLnZpZXdzLnNjb3Blcy5pbmxpbmVkIChuYW1lc3BhY2UpXG4gICAgICAgKi9cbiAgICAgIGlubGluZWQ6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQgKHNlbGVjdG9yKVxuICAgICAgICAgKiBzZWUgZGF0YS5pbmZvLnNjb3BlcyBmb3IgaG93IHRoaXMgZGlmZmVycyBmcm9tIHRoZSByYXcgdmVyc2lvblxuICAgICAgICAgKi9cbiAgICAgICAgXzogY3JlYXRlTGVhZihbXCIvaW5mby9zY29wZXNcIiwgXCIuL3Jhd1wiXSwgKHNjb3BlcywgaW5saW5lZCkgPT5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbmxpbmVkKS5tYXAoKFtpZCwgaW5mb10pID0+IHtcbiAgICAgICAgICAgICAgbGV0IG5ld0luZm8gPSB7IC4uLmluZm8gfTtcbiAgICAgICAgICAgICAgbmV3SW5mby52YXJpYWJsZXMgPSBzY29wZXNbaWRdLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgcmV0dXJuIHsgW2lkXTogbmV3SW5mbyB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQucmF3XG4gICAgICAgICAqL1xuICAgICAgICByYXc6IGNyZWF0ZUxlYWYoXG4gICAgICAgICAgW1wiL2luZm8vc2NvcGVzL3Jhd1wiLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLFxuXG4gICAgICAgICAgKHNjb3Blcywgc291cmNlcykgPT5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzY29wZXMpLm1hcCgoW2lkLCBlbnRyeV0pID0+ICh7XG4gICAgICAgICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgICAgICAgLi4uZW50cnksXG5cbiAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IGpzb25wb2ludGVyLmdldChcbiAgICAgICAgICAgICAgICAgICAgc291cmNlc1tlbnRyeS5zb3VyY2VJZF0uYXN0LFxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5wb2ludGVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGRhdGEudmlld3MudXNlckRlZmluZWRUeXBlc1xuICAgICAqL1xuICAgIHVzZXJEZWZpbmVkVHlwZXM6IHtcbiAgICAgIC8qXG4gICAgICAgKiBkYXRhLnZpZXdzLnVzZXJEZWZpbmVkVHlwZXMuY29udHJhY3REZWZpbml0aW9uc1xuICAgICAgICogcmVzdHJpY3QgdG8gY29udHJhY3RzIG9ubHksIGFuZCBnZXQgdGhlaXIgZGVmaW5pdGlvbnNcbiAgICAgICAqL1xuICAgICAgY29udHJhY3REZWZpbml0aW9uczogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL2luZm8vdXNlckRlZmluZWRUeXBlc1wiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiXSxcbiAgICAgICAgKHR5cGVJZHMsIHNjb3BlcykgPT5cbiAgICAgICAgICB0eXBlSWRzXG4gICAgICAgICAgICAubWFwKGlkID0+IHNjb3Blc1tpZF0uZGVmaW5pdGlvbilcbiAgICAgICAgICAgIC5maWx0ZXIobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGRhdGEudmlld3MucmVmZXJlbmNlRGVjbGFyYXRpb25zXG4gICAgICovXG4gICAgcmVmZXJlbmNlRGVjbGFyYXRpb25zOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9zY29wZXMvaW5saW5lZFwiLCBcIi9pbmZvL3VzZXJEZWZpbmVkVHlwZXNcIl0sXG4gICAgICAoc2NvcGVzLCB1c2VyRGVmaW5lZFR5cGVzKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLnVzZXJEZWZpbmVkVHlwZXMubWFwKGlkID0+ICh7IFtpZF06IHNjb3Blc1tpZF0uZGVmaW5pdGlvbiB9KSlcbiAgICAgICAgKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLm1hcHBpbmdLZXlzXG4gICAgICovXG4gICAgbWFwcGluZ0tleXM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvcHJvYy9tYXBwZWRQYXRoc1wiLCBcIi9jdXJyZW50L2FkZHJlc3NcIl0sXG4gICAgICAobWFwcGVkUGF0aHMsIGFkZHJlc3MpID0+XG4gICAgICAgIFtdXG4gICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgIC4uLk9iamVjdC52YWx1ZXMoXG4gICAgICAgICAgICAgIChtYXBwZWRQYXRocy5ieUFkZHJlc3NbYWRkcmVzc10gfHwgeyBieVR5cGU6IHt9IH0pLmJ5VHlwZVxuICAgICAgICAgICAgKS5tYXAoKHsgYnlTbG90QWRkcmVzcyB9KSA9PiBPYmplY3QudmFsdWVzKGJ5U2xvdEFkZHJlc3MpKVxuICAgICAgICAgIClcbiAgICAgICAgICAuZmlsdGVyKHNsb3QgPT4gc2xvdC5rZXkgIT09IHVuZGVmaW5lZClcbiAgICApLFxuXG4gICAgLypcbiAgICAgKiBkYXRhLnZpZXdzLmJsb2NrTnVtYmVyXG4gICAgICogcmV0dXJucyBibG9jayBudW1iZXIgYXMgc3RyaW5nXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI6IGNyZWF0ZUxlYWYoW2V2bS50cmFuc2FjdGlvbi5nbG9iYWxzLmJsb2NrXSwgYmxvY2sgPT5cbiAgICAgIGJsb2NrLm51bWJlci50b1N0cmluZygpXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy5pbnN0YW5jZXNcbiAgICAgKiBzYW1lIGFzIGV2bS5jdXJyZW50LmNvZGV4Lmluc3RhbmNlcywgYnV0IHdlIGp1c3QgbWFwIGFkZHJlc3MgPT4gYmluYXJ5LFxuICAgICAqIHdlIGRvbid0IGJvdGhlciB3aXRoIGNvbnRleHQsIGFuZCBhbHNvIHRoZSBjb2RlIGlzIGEgVWludDhBcnJheVxuICAgICAqL1xuICAgIGluc3RhbmNlczogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuY29kZXguaW5zdGFuY2VzXSwgaW5zdGFuY2VzID0+XG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoaW5zdGFuY2VzKS5tYXAoKFthZGRyZXNzLCB7IGJpbmFyeSB9XSkgPT4gKHtcbiAgICAgICAgICBbYWRkcmVzc106IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyhiaW5hcnkpXG4gICAgICAgIH0pKVxuICAgICAgKVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIGRhdGEudmlld3MuY29udGV4dHNcbiAgICAgKiBzYW1lIGFzIGV2bS5pbmZvLmNvbnRleHRzLCBidXQ6XG4gICAgICogMC4gd2Ugb25seSBpbmNsdWRlIG5vbi1jb25zdHJ1Y3RvciBjb250ZXh0c1xuICAgICAqIDEuIHdlIG5vdyBpbmRleCBieSBjb250cmFjdCBJRCByYXRoZXIgdGhhbiBoYXNoXG4gICAgICogMi4gd2Ugc3RyaXAgb3V0IGNvbnRleHQsIHNvdXJjZU1hcCwgcHJpbWFyeVNvdXJjZSwgYW5kIGNvbXBpbGVyXG4gICAgICogMy4gd2UgYWx0ZXIgYWJpIGluIHNldmVyYWwgd2F5czpcbiAgICAgKiAzYS4gd2Ugc3RyaXAgYWJpIGRvd24gdG8ganVzdCAob3JkaW5hcnkpIGZ1bmN0aW9uc1xuICAgICAqIDNiLiB3ZSBhdWdtZW50IHRoZXNlIGZ1bmN0aW9ucyB3aXRoIHNpZ25hdHVyZXMgKGhlcmUgbWVhbmluZyBzZWxlY3RvcnMpXG4gICAgICogM2MuIGFiaSBpcyBub3cgYW4gb2JqZWN0LCBub3QgYW4gYXJyYXksIGFuZCBpbmRleGVkIGJ5IHRoZXNlIHNpZ25hdHVyZXNcbiAgICAgKi9cbiAgICBjb250ZXh0czogY3JlYXRlTGVhZihbZXZtLmluZm8uY29udGV4dHNdLCBjb250ZXh0cyA9PlxuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIC4uLk9iamVjdC52YWx1ZXMoY29udGV4dHMpXG4gICAgICAgICAgLmZpbHRlcihjb250ZXh0ID0+ICFjb250ZXh0LmlzQ29uc3RydWN0b3IpXG4gICAgICAgICAgLm1hcChjb250ZXh0ID0+ICh7XG4gICAgICAgICAgICBbY29udGV4dC5jb250cmFjdElkXTogZGVidWdnZXJDb250ZXh0VG9EZWNvZGVyQ29udGV4dChjb250ZXh0KVxuICAgICAgICAgIH0pKVxuICAgICAgKVxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5pbmZvLnNjb3BlcyAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIHNjb3Blczoge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmluZm8uc2NvcGVzIChzZWxlY3RvcilcbiAgICAgICAqIHRoZSByYXcgdmVyc2lvbiBpcyBiZWxvdzsgdGhpcyB2ZXJzaW9uIGFjY291bnRzIGZvciBpbmhlcml0YW5jZVxuICAgICAgICogTk9URTogZG9lc24ndCB0aGlzIHNlbGVjdG9yIHJlYWxseSBiZWxvbmcgaW4gZGF0YS52aWV3cz8gIFllcy5cbiAgICAgICAqIEJ1dCwgc2luY2UgaXQncyByZXBsYWNpbmcgdGhlIG9sZCBkYXRhLmluZm8uc2NvcGVzICh3aGljaCBpcyBub3dcbiAgICAgICAqIGRhdGEuaW5mby5zY29wZXMucmF3KSwgSSBkaWRuJ3Qgd2FudCB0byBtb3ZlIGl0LlxuICAgICAgICovXG4gICAgICBfOiBjcmVhdGVMZWFmKFtcIi4vcmF3XCIsIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkL3Jhd1wiXSwgKHNjb3BlcywgaW5saW5lZCkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzY29wZXMpLm1hcCgoW2lkLCBzY29wZV0pID0+IHtcbiAgICAgICAgICAgIGxldCBkZWZpbml0aW9uID0gaW5saW5lZFtpZF0uZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLm5vZGVUeXBlICE9PSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IFtpZF06IHNjb3BlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIHdlJ3ZlIHJlYWNoZWQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGJlIGRlYWxpbmcgd2l0aCBhXG4gICAgICAgICAgICAvL2NvbnRyYWN0LCBhbmQgc3BlY2lmaWNhbGx5IGEgY29udHJhY3QgLS0gbm90IGFuIGludGVyZmFjZSBvclxuICAgICAgICAgICAgLy9saWJyYXJ5ICh0aG9zZSBkb24ndCBnZXQgXCJ2YXJpYWJsZXNcIiBlbnRyaWVzIGluIHRoZWlyIHNjb3BlcylcbiAgICAgICAgICAgIGRlYnVnKFwiY29udHJhY3QgaWQgJWRcIiwgaWQpO1xuICAgICAgICAgICAgbGV0IG5ld1Njb3BlID0geyAuLi5zY29wZSB9O1xuICAgICAgICAgICAgLy9ub3RlIHRoYXQgU29saWRpdHkgZ2l2ZXMgdXMgdGhlIGxpbmVhcml6YXRpb24gaW4gb3JkZXIgZnJvbSBtb3N0XG4gICAgICAgICAgICAvL2Rlcml2ZWQgdG8gbW9zdCBiYXNlLCBidXQgd2Ugd2FudCBtb3N0IGJhc2UgdG8gbW9zdCBkZXJpdmVkO1xuICAgICAgICAgICAgLy9hbm5veWluZ2x5LCByZXZlcnNlKCkgaXMgaW4tcGxhY2UsIHNvIHdlIGNsb25lIHdpdGggc2xpY2UoKSBmaXJzdFxuICAgICAgICAgICAgbGV0IGxpbmVhcml6ZWRCYXNlQ29udHJhY3RzRnJvbUJhc2UgPSBkZWZpbml0aW9uLmxpbmVhcml6ZWRCYXNlQ29udHJhY3RzXG4gICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAvL25vdywgd2UgcHV0IGl0IGFsbCB0b2dldGhlclxuICAgICAgICAgICAgbmV3U2NvcGUudmFyaWFibGVzID0gW11cbiAgICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgICAuLi5saW5lYXJpemVkQmFzZUNvbnRyYWN0c0Zyb21CYXNlLm1hcChcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0SWQgPT4gc2NvcGVzW2NvbnRyYWN0SWRdLnZhcmlhYmxlcyB8fCBbXVxuICAgICAgICAgICAgICAgICAgLy93ZSBuZWVkIHRoZSB8fCBbXSBiZWNhdXNlIGNvbnRyYWN0cyB3aXRoIG5vIHN0YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgLy9oYXZlIHZhcmlhYmxlcyB1bmRlZmluZWQgcmF0aGVyIHRoYW4gZW1wdHkgbGlrZSB5b3UnZCBleHBlY3RcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLmZpbHRlcih2YXJpYWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8uLi5leGNlcHQsIEhBQ0ssIGxldCdzIGZpbHRlciBvdXQgdGhvc2UgY29uc3RhbnRzIHdlIGRvbid0IGtub3dcbiAgICAgICAgICAgICAgICAvL2hvdyB0byByZWFkLiAgdGhleSdsbCBqdXN0IGNsdXR0ZXIgdGhpbmdzIHVwLlxuICAgICAgICAgICAgICAgIGRlYnVnKFwidmFyaWFibGUgJU9cIiwgdmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIGxldCBkZWZpbml0aW9uID0gaW5saW5lZFt2YXJpYWJsZS5pZF0uZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgIWRlZmluaXRpb24uY29uc3RhbnQgfHxcbiAgICAgICAgICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNTaW1wbGVDb25zdGFudChkZWZpbml0aW9uLnZhbHVlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4geyBbaWRdOiBuZXdTY29wZSB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICksXG5cbiAgICAgIC8qXG4gICAgICAgKiBkYXRhLmluZm8uc2NvcGVzLnJhd1xuICAgICAgICovXG4gICAgICByYXc6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5pbmZvLnNjb3Blcy5ieUlkKVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGRhdGEuaW5mby5hbGxvY2F0aW9uc1xuICAgICAqL1xuICAgIGFsbG9jYXRpb25zOiB7XG4gICAgICAvKlxuICAgICAgICogZGF0YS5pbmZvLmFsbG9jYXRpb25zLnN0b3JhZ2VcbiAgICAgICAqL1xuICAgICAgc3RvcmFnZTogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uYWxsb2NhdGlvbnMuc3RvcmFnZSksXG5cbiAgICAgIC8qXG4gICAgICAgKiBkYXRhLmluZm8uYWxsb2NhdGlvbnMubWVtb3J5XG4gICAgICAgKi9cbiAgICAgIG1lbW9yeTogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uYWxsb2NhdGlvbnMubWVtb3J5KSxcblxuICAgICAgLypcbiAgICAgICAqIGRhdGEuaW5mby5hbGxvY2F0aW9ucy5jYWxsZGF0YVxuICAgICAgICovXG4gICAgICBjYWxsZGF0YTogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uYWxsb2NhdGlvbnMuY2FsbGRhdGEpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuaW5mby51c2VyRGVmaW5lZFR5cGVzXG4gICAgICovXG4gICAgdXNlckRlZmluZWRUeXBlczogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9zdGF0ZVwiXSxcbiAgICAgIHN0YXRlID0+IHN0YXRlLmluZm8udXNlckRlZmluZWRUeXBlc1xuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5wcm9jXG4gICAqL1xuICBwcm9jOiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5wcm9jLmFzc2lnbm1lbnRzXG4gICAgICovXG4gICAgYXNzaWdubWVudHM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvc3RhdGVcIl0sXG4gICAgICBzdGF0ZSA9PiBzdGF0ZS5wcm9jLmFzc2lnbm1lbnRzXG4gICAgICAvL25vdGU6IHRoaXMgbm8gbG9uZ2VyIGZldGNoZXMganVzdCB0aGUgYnlJZCwgYnV0IHJhdGhlciB0aGUgd2hvbGVcbiAgICAgIC8vYXNzaWdubWVudHMgb2JqZWN0XG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZGF0YS5wcm9jLm1hcHBlZFBhdGhzXG4gICAgICovXG4gICAgbWFwcGVkUGF0aHM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5wcm9jLm1hcHBlZFBhdGhzKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEucHJvYy5kZWNvZGluZ0tleXNcbiAgICAgKlxuICAgICAqIG51bWJlciBvZiBrZXlzIHRoYXQgYXJlIHN0aWxsIGRlY29kaW5nXG4gICAgICovXG4gICAgZGVjb2RpbmdLZXlzOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9tYXBwZWRQYXRoc1wiXSxcbiAgICAgIG1hcHBlZFBhdGhzID0+IG1hcHBlZFBhdGhzLmRlY29kaW5nU3RhcnRlZFxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LnN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LnN0YXRlLnN0YWNrXG4gICAgICAgKi9cbiAgICAgIHN0YWNrOiBjcmVhdGVMZWFmKFxuICAgICAgICBbZXZtLmN1cnJlbnQuc3RhdGUuc3RhY2tdLFxuXG4gICAgICAgIHdvcmRzID0+ICh3b3JkcyB8fCBbXSkubWFwKHdvcmQgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuc3RhdGUubWVtb3J5XG4gICAgICAgKi9cbiAgICAgIG1lbW9yeTogY3JlYXRlTGVhZihcbiAgICAgICAgW2V2bS5jdXJyZW50LnN0YXRlLm1lbW9yeV0sXG5cbiAgICAgICAgd29yZHMgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmRzLmpvaW4oXCJcIikpXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZS5jYWxsZGF0YVxuICAgICAgICovXG4gICAgICBjYWxsZGF0YTogY3JlYXRlTGVhZihcbiAgICAgICAgW2V2bS5jdXJyZW50LmNhbGxdLFxuXG4gICAgICAgICh7IGRhdGEgfSkgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKGRhdGEpXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZS5zdG9yYWdlXG4gICAgICAgKi9cbiAgICAgIHN0b3JhZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtldm0uY3VycmVudC5jb2RleC5zdG9yYWdlXSxcblxuICAgICAgICBtYXBwaW5nID0+XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMobWFwcGluZykubWFwKChbYWRkcmVzcywgd29yZF0pID0+ICh7XG4gICAgICAgICAgICAgIFtgMHgke2FkZHJlc3N9YF06IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyh3b3JkKVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKVxuICAgICAgKSxcblxuICAgICAgLypcbiAgICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZS5zcGVjaWFsc1xuICAgICAgICogSSd2ZSBuYW1lZCB0aGVzZSBhZnRlciB0aGUgc29saWRpdHkgdmFyaWFibGVzIHRoZXkgY29ycmVzcG9uZCB0byxcbiAgICAgICAqIHdoaWNoIGFyZSAqbW9zdGx5KiB0aGUgc2FtZSBhcyB0aGUgY29ycmVzcG9uZGluZyBFVk0gb3Bjb2Rlc1xuICAgICAgICogKEZXSVc6IHRoaXMgPSBBRERSRVNTLCBzZW5kZXIgPSBDQUxMRVIsIHZhbHVlID0gQ0FMTFZBTFVFKVxuICAgICAgICovXG4gICAgICBzcGVjaWFsczogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL2N1cnJlbnQvYWRkcmVzc1wiLCBldm0uY3VycmVudC5jYWxsLCBldm0udHJhbnNhY3Rpb24uZ2xvYmFsc10sXG4gICAgICAgIChhZGRyZXNzLCB7IHNlbmRlciwgdmFsdWUgfSwgeyB0eCwgYmxvY2sgfSkgPT4gKHtcbiAgICAgICAgICB0aGlzOiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQnl0ZXMoYWRkcmVzcyksXG5cbiAgICAgICAgICBzZW5kZXI6IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyhzZW5kZXIpLFxuXG4gICAgICAgICAgdmFsdWU6IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyh2YWx1ZSksXG5cbiAgICAgICAgICAvL2xldCdzIGNyYWNrIG9wZW4gdGhhdCB0eCBhbmQgYmxvY2shXG4gICAgICAgICAgLi4uT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXModHgpLm1hcCgoW3ZhcmlhYmxlLCB2YWx1ZV0pID0+ICh7XG4gICAgICAgICAgICAgIFt2YXJpYWJsZV06IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyh2YWx1ZSlcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICksXG5cbiAgICAgICAgICAuLi5PYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhibG9jaykubWFwKChbdmFyaWFibGUsIHZhbHVlXSkgPT4gKHtcbiAgICAgICAgICAgICAgW3ZhcmlhYmxlXTogRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHZhbHVlKVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLmN1cnJlbnQubm9kZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQubm9kZV0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5zY29wZVxuICAgICAqIG9sZCBhbGlhcyBmb3IgZGF0YS5jdXJyZW50Lm5vZGUgKGRlcHJlY2F0ZWQpXG4gICAgICovXG4gICAgc2NvcGU6IGNyZWF0ZUxlYWYoW1wiLi9ub2RlXCJdLCBpZGVudGl0eSksXG5cbiAgICAvKlxuICAgICAqIGRhdGEuY3VycmVudC5jb250cmFjdFxuICAgICAqIHdhcm5pbmc6IG1heSByZXR1cm4gbnVsbCBvciBzaW1pbGFyLCBldmVuIHRob3VnaCBTb3VyY2VVbml0IGlzIGluY2x1ZGVkXG4gICAgICogYXMgZmFsbGJhY2tcbiAgICAgKi9cbiAgICBjb250cmFjdDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vbm9kZVwiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiXSxcbiAgICAgIChub2RlLCBzY29wZXMpID0+IHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXCJDb250cmFjdERlZmluaXRpb25cIiwgXCJTb3VyY2VVbml0XCJdO1xuICAgICAgICAvL1NvdXJjZVVuaXQgaW5jbHVkZWQgYXMgZmFsbGJhY2tcbiAgICAgICAgcmV0dXJuIGZpbmRBbmNlc3Rvck9mVHlwZShub2RlLCB0eXBlcywgc2NvcGVzKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uRGVwdGg6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aF0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5hZGRyZXNzXG4gICAgICogTk9URTogdGhpcyBpcyB0aGUgU1RPUkFHRSBhZGRyZXNzIGZvciB0aGUgY3VycmVudCBjYWxsLCBub3QgdGhlIENPREVcbiAgICAgKiBhZGRyZXNzXG4gICAgICovXG5cbiAgICBhZGRyZXNzOiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5jYWxsXSwgY2FsbCA9PiBjYWxsLnN0b3JhZ2VBZGRyZXNzKSxcblxuICAgIC8qXG4gICAgICogZGF0YS5jdXJyZW50LmZ1bmN0aW9uc0J5UHJvZ3JhbUNvdW50ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbnNCeVByb2dyYW1Db3VudGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW3NvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25zQnlQcm9ncmFtQ291bnRlcl0sXG4gICAgICBmdW5jdGlvbnMgPT4gZnVuY3Rpb25zXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZGF0YS5jdXJyZW50LmNvbnRleHRcbiAgICAgKi9cbiAgICBjb250ZXh0OiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5jb250ZXh0XSwgZGVidWdnZXJDb250ZXh0VG9EZWNvZGVyQ29udGV4dCksXG5cbiAgICAvKlxuICAgICAqIGRhdGEuY3VycmVudC5hYm91dFRvTW9kaWZ5XG4gICAgICogSEFDS1xuICAgICAqIFRoaXMgc2VsZWN0b3IgaXMgdXNlZCB0byBjYXRjaCB0aG9zZSB0aW1lcyB3aGVuIHdlIGdvIHN0cmFpZ2h0IGZyb20gYVxuICAgICAqIG1vZGlmaWVyIGludm9jYXRpb24gaW50byB0aGUgbW9kaWZpZXIgaXRzZWxmLCBza2lwcGluZyBvdmVyIHRoZVxuICAgICAqIGRlZmluaXRpb24gbm9kZSAodGhpcyBpbmNsdWRlcyBiYXNlIGNvbnN0cnVjdG9yIGNhbGxzKS4gIFNvIGl0IHNob3VsZFxuICAgICAqIHJldHVybiB0cnVlIHdoZW46XG4gICAgICogMS4gd2UncmUgb24gdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byBhbiBhcmd1bWVudCB0byBhIG1vZGlmaWVyXG4gICAgICogaW52b2NhdGlvbiBvciBiYXNlIGNvbnN0cnVjdG9yIGNhbGwsIG9yLCBpZiBzYWlkIGFyZ3VtZW50IGlzIGEgdHlwZVxuICAgICAqIGNvbnZlcnNpb24sIGl0cyBhcmd1bWVudCAob3IgbmVzdGVkIGFyZ3VtZW50KVxuICAgICAqIDIuIHRoZSBuZXh0IG5vZGUgaXMgbm90IGEgRnVuY3Rpb25EZWZpbml0aW9uLCBNb2RpZmllckRlZmluaXRpb24sIG9yXG4gICAgICogaW4gdGhlIHNhbWUgbW9kaWZpZXIgLyBiYXNlIGNvbnN0cnVjdG9yIGludm9jYXRpb25cbiAgICAgKi9cbiAgICBhYm91dFRvTW9kaWZ5OiBjcmVhdGVMZWFmKFxuICAgICAgW1xuICAgICAgICBcIi4vbm9kZVwiLFxuICAgICAgICBcIi4vbW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgIFwiLi9tb2RpZmllckFyZ3VtZW50SW5kZXhcIixcbiAgICAgICAgXCIvbmV4dC9ub2RlXCIsXG4gICAgICAgIFwiL25leHQvbW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgIGV2bS5jdXJyZW50LnN0ZXAuaXNDb250ZXh0Q2hhbmdlXG4gICAgICBdLFxuICAgICAgKG5vZGUsIGludm9jYXRpb24sIGluZGV4LCBuZXh0LCBuZXh0SW52b2NhdGlvbiwgaXNDb250ZXh0Q2hhbmdlKSA9PiB7XG4gICAgICAgIC8vZW5zdXJlOiBjdXJyZW50IGluc3RydWN0aW9uIGlzIG5vdCBhIGNvbnRleHQgY2hhbmdlIChiZWNhdXNlIGlmIGl0IGlzXG4gICAgICAgIC8vd2UgY2Fubm90IHJlbHkgb24gdGhlIGRhdGEubmV4dCBzZWxlY3RvcnMsIGJ1dCBhbHNvIGlmIGl0IGlzIHdlIGtub3dcbiAgICAgICAgLy93ZSdyZSBub3QgYWJvdXQgdG8gY2FsbCBhIG1vZGlmaWVyIG9yIGJhc2UgY29uc3RydWN0b3IhKVxuICAgICAgICAvL3dlIGFsc28gd2FudCB0byByZXR1cm4gZmFsc2UgaWYgd2UgY2FuJ3QgZmluZCB0aGluZ3MgZm9yIHdoYXRldmVyXG4gICAgICAgIC8vcmVhc29uXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0NvbnRleHRDaGFuZ2UgfHxcbiAgICAgICAgICAhbm9kZSB8fFxuICAgICAgICAgICFuZXh0IHx8XG4gICAgICAgICAgIWludm9jYXRpb24gfHxcbiAgICAgICAgICAhbmV4dEludm9jYXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbnN1cmU6IGN1cnJlbnQgcG9zaXRpb24gaXMgaW4gYSBNb2RpZmllckludm9jYXRpb24gb3JcbiAgICAgICAgLy9Jbmhlcml0YW5jZVNwZWNpZmllciAocmVjYWxsIHRoYXQgU291cmNlVW5pdCB3YXMgaW5jbHVkZWQgYXNcbiAgICAgICAgLy9mYWxsYmFjaylcbiAgICAgICAgaWYgKGludm9jYXRpb24ubm9kZVR5cGUgPT09IFwiU291cmNlVW5pdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbnN1cmU6IG5leHQgbm9kZSBpcyBub3QgYSBmdW5jdGlvbiBkZWZpbml0aW9uIG9yIG1vZGlmaWVyIGRlZmluaXRpb25cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5leHQubm9kZVR5cGUgPT09IFwiRnVuY3Rpb25EZWZpbml0aW9uXCIgfHxcbiAgICAgICAgICBuZXh0Lm5vZGVUeXBlID09PSBcIk1vZGlmaWVyRGVmaW5pdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZW5zdXJlOiBuZXh0IG5vZGUgaXMgbm90IGluIHRoZSBzYW1lIGludm9jYXRpb25cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5leHRJbnZvY2F0aW9uLm5vZGVUeXBlICE9PSBcIlNvdXJjZVVuaXRcIiAmJlxuICAgICAgICAgIG5leHRJbnZvY2F0aW9uLmlkID09PSBpbnZvY2F0aW9uLmlkXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm93OiBhcmUgd2Ugb24gdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byBhbiBhcmd1bWVudCwgb3IsIGlmXG4gICAgICAgIC8vaXQncyBhIHR5cGUgY29udmVyc2lvbiwgaXRzIG5lc3RlZCBhcmd1bWVudD9cbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3VtZW50ID0gaW52b2NhdGlvbi5hcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB3aGlsZSAoYXJndW1lbnQua2luZCA9PT0gXCJ0eXBlQ29udmVyc2lvblwiKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGFyZ3VtZW50LmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJndW1lbnQgPSBhcmd1bWVudC5hcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IGFyZ3VtZW50LmlkO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIGRhdGEuY3VycmVudC5tb2RpZmllckludm9jYXRpb25cbiAgICAgKi9cbiAgICBtb2RpZmllckludm9jYXRpb246IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL25vZGVcIiwgXCIvdmlld3Mvc2NvcGVzL2lubGluZWRcIl0sXG4gICAgICAobm9kZSwgc2NvcGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW1xuICAgICAgICAgIFwiTW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgICAgXCJJbmhlcml0YW5jZVNwZWNpZmllclwiLFxuICAgICAgICAgIFwiU291cmNlVW5pdFwiXG4gICAgICAgIF07XG4gICAgICAgIC8vYWdhaW4sIFNvdXJjZVVuaXQgaW5jbHVkZWQgYXMgZmFsbGJhY2tcbiAgICAgICAgcmV0dXJuIGZpbmRBbmNlc3Rvck9mVHlwZShub2RlLCB0eXBlcywgc2NvcGVzKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50Lm1vZGlmaWVyQXJndW1lbnRJbmRleFxuICAgICAqIGdldHMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IG1vZGlmaWVyIGFyZ3VtZW50IHRoYXQgeW91J3JlIGluXG4gICAgICogKHVuZGVmaW5lZCB3aGVuIG5vdCBpbiBhIG1vZGlmaWVyIGFyZ3VtZW50KVxuICAgICAqL1xuICAgIG1vZGlmaWVyQXJndW1lbnRJbmRleDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9pbmZvL3Njb3Blc1wiLCBcIi4vbm9kZVwiLCBcIi4vbW9kaWZpZXJJbnZvY2F0aW9uXCJdLFxuICAgICAgKHNjb3Blcywgbm9kZSwgaW52b2NhdGlvbikgPT4ge1xuICAgICAgICBpZiAoaW52b2NhdGlvbi5ub2RlVHlwZSA9PT0gXCJTb3VyY2VVbml0XCIpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBvaW50ZXIgPSBzY29wZXNbbm9kZS5pZF0ucG9pbnRlcjtcbiAgICAgICAgbGV0IGludm9jYXRpb25Qb2ludGVyID0gc2NvcGVzW2ludm9jYXRpb24uaWRdLnBvaW50ZXI7XG5cbiAgICAgICAgLy9zbGljZSB0aGUgaW52b2NhdGlvbiBwb2ludGVyIG9mZiB0aGUgYmVnaW5uaW5nXG4gICAgICAgIGxldCBkaWZmZXJlbmNlID0gcG9pbnRlci5yZXBsYWNlKGludm9jYXRpb25Qb2ludGVyLCBcIlwiKTtcbiAgICAgICAgZGVidWcoXCJkaWZmZXJlbmNlICVzXCIsIGRpZmZlcmVuY2UpO1xuICAgICAgICBsZXQgcmF3SW5kZXggPSBkaWZmZXJlbmNlLm1hdGNoKC9eXFwvYXJndW1lbnRzXFwvKFxcZCspLyk7XG4gICAgICAgIC8vbm90ZSB0aGF0IHRoYXQgXFxkKyBpcyBncmVlZHlcbiAgICAgICAgZGVidWcoXCJyYXdJbmRleCAlb1wiLCByYXdJbmRleCk7XG4gICAgICAgIGlmIChyYXdJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJhd0luZGV4WzFdKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLypcbiAgICAgKiBkYXRhLmN1cnJlbnQubW9kaWZpZXJCZWluZ0ludm9rZWRcbiAgICAgKiBnZXRzIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vZGlmaWVyIG9yIGJhc2UgY29uc3RydWN0b3JcbiAgICAgKiBiZWluZyBpbnZva2VkXG4gICAgICovXG4gICAgbW9kaWZpZXJCZWluZ0ludm9rZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL21vZGlmaWVySW52b2NhdGlvblwiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiXSxcbiAgICAgIChpbnZvY2F0aW9uLCBzY29wZXMpID0+IHtcbiAgICAgICAgaWYgKCFpbnZvY2F0aW9uIHx8IGludm9jYXRpb24ubm9kZVR5cGUgPT09IFwiU291cmNlVW5pdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RpZmllckZvckludm9jYXRpb24oaW52b2NhdGlvbiwgc2NvcGVzKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChuYW1lc3BhY2UpXG4gICAgICovXG4gICAgaWRlbnRpZmllcnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChzZWxlY3RvcilcbiAgICAgICAqXG4gICAgICAgKiByZXR1cm5zIGlkZW50aWZlcnMgYW5kIGNvcnJlc3BvbmRpbmcgZGVmaW5pdGlvbiBub2RlIElEIG9yIGJ1aWx0aW4gbmFtZVxuICAgICAgICogKG9iamVjdCBlbnRyaWVzIGxvb2sgbGlrZSBbbmFtZV06IHthc3RJZDogaWR9IG9yIGxpa2UgW25hbWVdOiB7YnVpbHRpbjogbmFtZX1cbiAgICAgICAqL1xuICAgICAgXzogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsIFwiL2N1cnJlbnQvbm9kZVwiXSxcblxuICAgICAgICAoc2NvcGVzLCBzY29wZSkgPT4ge1xuICAgICAgICAgIGxldCB2YXJpYWJsZXMgPSB7fTtcbiAgICAgICAgICBpZiAoc2NvcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHNjb3BlLmlkO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIC4uLihzY29wZXNbY3VyXS52YXJpYWJsZXMgfHwgW10pXG4gICAgICAgICAgICAgICAgICAuZmlsdGVyKHYgPT4gdi5uYW1lICE9PSBcIlwiKSAvL2V4Y2x1ZGUgYW5vbnltb3VzIG91dHB1dCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIodiA9PiB2YXJpYWJsZXNbdi5uYW1lXSA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAubWFwKHYgPT4gKHsgW3YubmFtZV06IHsgYXN0SWQ6IHYuaWQgfSB9KSlcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBjdXIgPSBzY29wZXNbY3VyXS5wYXJlbnRJZDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1ciAhPSBudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgYnVpbHRpbnMgPSB7XG4gICAgICAgICAgICBtc2c6IHsgYnVpbHRpbjogXCJtc2dcIiB9LFxuICAgICAgICAgICAgdHg6IHsgYnVpbHRpbjogXCJ0eFwiIH0sXG4gICAgICAgICAgICBibG9jazogeyBidWlsdGluOiBcImJsb2NrXCIgfSxcbiAgICAgICAgICAgIHRoaXM6IHsgYnVpbHRpbjogXCJ0aGlzXCIgfSxcbiAgICAgICAgICAgIG5vdzogeyBidWlsdGluOiBcIm5vd1wiIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIHsgLi4udmFyaWFibGVzLCAuLi5idWlsdGlucyB9O1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9ucyAobmFtZXNwYWNlKVxuICAgICAgICovXG4gICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAvKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMuZGVmaW5pdGlvbnMgKHNlbGVjdG9yKVxuICAgICAgICAgKiBkZWZpbml0aW9ucyBmb3IgY3VycmVudCB2YXJpYWJsZXMsIGJ5IGlkZW50aWZpZXJcbiAgICAgICAgICovXG4gICAgICAgIF86IGNyZWF0ZUxlYWYoXG4gICAgICAgICAgW1wiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsIFwiLi4vX1wiLCBcIi4vdGhpc1wiXSxcblxuICAgICAgICAgIChzY29wZXMsIGlkZW50aWZpZXJzLCB0aGlzRGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgICAgbGV0IHZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpZGVudGlmaWVycykubWFwKChbaWRlbnRpZmllciwgeyBhc3RJZCB9XSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhc3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvL3dpbGwgYmUgdW5kZWZpbmVkIGZvciBidWlsdGluc1xuICAgICAgICAgICAgICAgICAgbGV0IHsgZGVmaW5pdGlvbiB9ID0gc2NvcGVzW2FzdElkXTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IFtpZGVudGlmaWVyXTogZGVmaW5pdGlvbiB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge307IC8vc2tpcCBvdmVyIGJ1aWx0aW5zOyB3ZSdsbCBoYW5kbGUgdGhvc2Ugc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgYnVpbHRpbnMgPSB7XG4gICAgICAgICAgICAgIG1zZzogRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5NU0dfREVGSU5JVElPTixcbiAgICAgICAgICAgICAgdHg6IERlY29kZVV0aWxzLkRlZmluaXRpb24uVFhfREVGSU5JVElPTixcbiAgICAgICAgICAgICAgYmxvY2s6IERlY29kZVV0aWxzLkRlZmluaXRpb24uQkxPQ0tfREVGSU5JVElPTixcbiAgICAgICAgICAgICAgbm93OiBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnNwb29mVWludERlZmluaXRpb24oXCJub3dcIilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL29ubHkgaW5jbHVkZSB0aGlzIHdoZW4gaXQgaGFzIGEgcHJvcGVyIGRlZmluaXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICBidWlsdGlucy50aGlzID0gdGhpc0RlZmluaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi52YXJpYWJsZXMsIC4uLmJ1aWx0aW5zIH07XG4gICAgICAgICAgfVxuICAgICAgICApLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9ucy50aGlzXG4gICAgICAgICAqXG4gICAgICAgICAqIHJldHVybnMgYSBzcG9vZmVkIGRlZmluaXRpb24gZm9yIHRoZSB0aGlzIHZhcmlhYmxlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzOiBjcmVhdGVMZWFmKFxuICAgICAgICAgIFtcIi9jdXJyZW50L2NvbnRyYWN0XCJdLFxuICAgICAgICAgIGNvbnRyYWN0Tm9kZSA9PlxuICAgICAgICAgICAgY29udHJhY3ROb2RlICYmIGNvbnRyYWN0Tm9kZS5ub2RlVHlwZSA9PT0gXCJDb250cmFjdERlZmluaXRpb25cIlxuICAgICAgICAgICAgICA/IERlY29kZVV0aWxzLkRlZmluaXRpb24uc3Bvb2ZUaGlzRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0Tm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgY29udHJhY3ROb2RlLmlkXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMucmVmc1xuICAgICAgICpcbiAgICAgICAqIGN1cnJlbnQgdmFyaWFibGVzJyB2YWx1ZSByZWZzXG4gICAgICAgKi9cbiAgICAgIHJlZnM6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi9wcm9jL2Fzc2lnbm1lbnRzXCIsXG4gICAgICAgICAgXCIuL19cIixcbiAgICAgICAgICBcIi9jdXJyZW50L2Z1bmN0aW9uRGVwdGhcIiwgLy9mb3IgcHJ1bmluZyB0aGluZ3MgdG9vIGRlZXAgb24gc3RhY2tcbiAgICAgICAgICBcIi9jdXJyZW50L2FkZHJlc3NcIiAvL2ZvciBjb250cmFjdCB2YXJpYWJsZXNcbiAgICAgICAgXSxcblxuICAgICAgICAoYXNzaWdubWVudHMsIGlkZW50aWZpZXJzLCBjdXJyZW50RGVwdGgsIGFkZHJlc3MpID0+XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoaWRlbnRpZmllcnMpLm1hcChcbiAgICAgICAgICAgICAgKFtpZGVudGlmaWVyLCB7IGFzdElkLCBidWlsdGluIH1dKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlkO1xuXG4gICAgICAgICAgICAgICAgLy9pcyB0aGlzIGFuIG9yZGluYXJ5IHZhcmlhYmxlIG9yIGEgYnVpbHRpbj9cbiAgICAgICAgICAgICAgICBpZiAoYXN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgLy9pZiBub3QgYSBidWlsdGluLCBmaXJzdCBjaGVjayBpZiBpdCdzIGEgY29udHJhY3QgdmFyXG4gICAgICAgICAgICAgICAgICBsZXQgbWF0Y2hJZHMgPSAoYXNzaWdubWVudHMuYnlBc3RJZFthc3RJZF0gfHwgW10pLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgaWRIYXNoID0+IGFzc2lnbm1lbnRzLmJ5SWRbaWRIYXNoXS5hZGRyZXNzID09PSBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBtYXRjaElkc1swXTsgLy90aGVyZSBzaG91bGQgb25seSBiZSBvbmUhXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vaWYgbm90IGNvbnRyYWN0LCBpdCdzIGxvY2FsLCBzbyBmaW5kIHRoZSBpbm5lcm1vc3RcbiAgICAgICAgICAgICAgICAgIC8vKGJ1dCBub3QgYmV5b25kIGN1cnJlbnQgZGVwdGgpXG4gICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2hGcmFtZXMgPSAoYXNzaWdubWVudHMuYnlBc3RJZFthc3RJZF0gfHwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChpZCA9PiBhc3NpZ25tZW50cy5ieUlkW2lkXS5zdGFja2ZyYW1lKVxuICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoc3RhY2tmcmFtZSA9PiBzdGFja2ZyYW1lICE9PSB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEZyYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy90aGlzIGNoZWNrIGlzbid0ICpyZWFsbHkqXG4gICAgICAgICAgICAgICAgICAgICAgLy9uZWNlc3NhcnksIGJ1dCBtYXkgYXMgd2VsbCBwcmV2ZW50IHN0dXBpZCBzdHVmZlxuICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXhNYXRjaCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoLi4ubWF0Y2hGcmFtZXMpXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZCA9IHN0YWJsZUtlY2NhazI1Nih7IGFzdElkLCBzdGFja2ZyYW1lOiBtYXhNYXRjaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvL290aGVyd2lzZSwgaXQncyBhIGJ1aWx0aW5cbiAgICAgICAgICAgICAgICAgIC8vTk9URTogZm9yIG5vdyB3ZSBhc3N1bWUgdGhlcmUgaXMgb25seSBvbmUgYXNzaWdubWVudCBwZXJcbiAgICAgICAgICAgICAgICAgIC8vYnVpbHRpbiwgYnV0IHRoaXMgd2lsbCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgICAgICAgICAgaWQgPSBhc3NpZ25tZW50cy5ieUJ1aWx0aW5bYnVpbHRpbl1bMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSBzdGlsbCBkaWRuJ3QgZmluZCBpdCwgb2ggd2VsbFxuXG4gICAgICAgICAgICAgICAgbGV0IHsgcmVmIH0gPSBhc3NpZ25tZW50cy5ieUlkW2lkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiByZWZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5uZXh0XG4gICAqL1xuICBuZXh0OiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5uZXh0LnN0YXRlXG4gICAgICogWWVzLCBJJ20ganVzdCByZXBlYXRpbmcgdGhlIGNvZGUgZm9yIGRhdGEuY3VycmVudC5zdGF0ZS5zdGFjayBoZXJlO1xuICAgICAqIG5vdCB3b3J0aCB0aGUgdHJvdWJsZSB0byBmYWN0b3Igb3V0XG4gICAgICovXG4gICAgc3RhdGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5uZXh0LnN0YXRlLnN0YWNrXG4gICAgICAgKi9cbiAgICAgIHN0YWNrOiBjcmVhdGVMZWFmKFxuICAgICAgICBbZXZtLm5leHQuc3RhdGUuc3RhY2tdLFxuXG4gICAgICAgIHdvcmRzID0+ICh3b3JkcyB8fCBbXSkubWFwKHdvcmQgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvL0hBQ0sgV0FSTklOR1xuICAgIC8vdGhlIGZvbGxvd2luZyBzZWxlY3RvcnMgZGVwZW5kIG9uIHNvbGlkaXR5Lm5leHRcbiAgICAvL2RvIG5vdCB1c2UgdGhlbSB3aGVuIHRoZSBjdXJyZW50IGluc3RydWN0aW9uIGlzIGEgY29udGV4dCBjaGFuZ2UhXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLm5leHQubm9kZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5Lm5leHQubm9kZV0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEubmV4dC5tb2RpZmllckludm9jYXRpb25cbiAgICAgKiBOb3RlOiB5ZXMsIEknbSBqdXN0IHJlcGVhdGluZyB0aGUgY29kZSBmcm9tIGRhdGEuY3VycmVudCBoZXJlIGJ1dCB3aXRoXG4gICAgICogaW52YWxpZCBhZGRlZFxuICAgICAqL1xuICAgIG1vZGlmaWVySW52b2NhdGlvbjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vbm9kZVwiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiLCBldm0uY3VycmVudC5zdGVwLmlzQ29udGV4dENoYW5nZV0sXG4gICAgICAobm9kZSwgc2NvcGVzLCBpbnZhbGlkKSA9PiB7XG4gICAgICAgIC8vZG9uJ3QgYXR0ZW1wdCB0aGlzIGF0IGEgY29udGV4dCBjaGFuZ2UhXG4gICAgICAgIC8vKGFsc28gZG9uJ3QgYXR0ZW1wdCB0aGlzIGlmIHdlIGNhbid0IGZpbmQgdGhlIG5vZGUgZm9yIHdoYXRldmVyXG4gICAgICAgIC8vcmVhc29uKVxuICAgICAgICBpZiAoaW52YWxpZCB8fCAhbm9kZSkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXG4gICAgICAgICAgXCJNb2RpZmllckludm9jYXRpb25cIixcbiAgICAgICAgICBcIkluaGVyaXRhbmNlU3BlY2lmaWVyXCIsXG4gICAgICAgICAgXCJTb3VyY2VVbml0XCJcbiAgICAgICAgXTtcbiAgICAgICAgLy9hZ2FpbiwgU291cmNlVW5pdCBpbmNsdWRlZCBhcyBmYWxsYmFja1xuICAgICAgICByZXR1cm4gZmluZEFuY2VzdG9yT2ZUeXBlKG5vZGUsIHR5cGVzLCBzY29wZXMpO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIGRhdGEubmV4dC5tb2RpZmllckJlaW5nSW52b2tlZFxuICAgICAqL1xuICAgIG1vZGlmaWVyQmVpbmdJbnZva2VkOiBjcmVhdGVMZWFmKFxuICAgICAgW1xuICAgICAgICBcIi4vbW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsXG4gICAgICAgIGV2bS5jdXJyZW50LnN0ZXAuaXNDb250ZXh0Q2hhbmdlXG4gICAgICBdLFxuICAgICAgKGludm9jYXRpb24sIHNjb3BlcywgaW52YWxpZCkgPT4ge1xuICAgICAgICBpZiAoaW52YWxpZCB8fCAhaW52b2NhdGlvbiB8fCBpbnZvY2F0aW9uLm5vZGVUeXBlID09PSBcIlNvdXJjZVVuaXRcIikge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kaWZpZXJGb3JJbnZvY2F0aW9uKGludm9jYXRpb24sIHNjb3Blcyk7XG4gICAgICB9XG4gICAgKVxuICAgIC8vRU5EIEhBQ0sgV0FSTklOR1xuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLm5leHRNYXBwZWRcbiAgICovXG4gIG5leHRNYXBwZWQ6IHtcbiAgICAvKipcbiAgICAgKiBkYXRhLm5leHRNYXBwZWQuc3RhdGVcbiAgICAgKiBZZXMsIEknbSBqdXN0IHJlcGVhdGluZyB0aGUgY29kZSBmb3IgZGF0YS5jdXJyZW50LnN0YXRlLnN0YWNrIGhlcmU7XG4gICAgICogbm90IHdvcnRoIHRoZSB0cm91YmxlIHRvIGZhY3RvciBvdXRcbiAgICAgKiBIQUNLOiB0aGlzIGFzc3VtZXMgd2UncmUgbm90IGFib3V0IHRvIGNoYW5nZSBjb250ZXh0ISBkb24ndCB1c2UgdGhpcyBpZiB3ZVxuICAgICAqIGFyZSFcbiAgICAgKi9cbiAgICBzdGF0ZToge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLm5leHRNYXBwZWQuc3RhdGUuc3RhY2tcbiAgICAgICAqL1xuICAgICAgc3RhY2s6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtzb2xpZGl0eS5jdXJyZW50Lm5leHRNYXBwZWRdLFxuXG4gICAgICAgIHN0ZXAgPT5cbiAgICAgICAgICAoKHN0ZXAgfHwge30pLnN0YWNrIHx8IFtdKS5tYXAod29yZCA9PlxuICAgICAgICAgICAgRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpXG4gICAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRhdGE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvc2VsZWN0b3JzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwianNvbi1wb2ludGVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwianNvbi1wb2ludGVyXCJcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpldm06c2FnYXNcIik7XG5cbmltcG9ydCB7IHB1dCwgdGFrZUV2ZXJ5LCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lLCBrZWNjYWsyNTYgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuaW1wb3J0ICogYXMgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zYWdhc1wiO1xuXG4vKipcbiAqIEFkZHMgRVZNIGJ5dGVjb2RlIGNvbnRleHRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEICgweC1wcmVmaXhlZCBrZWNjYWsgb2YgYmluYXJ5KVxuICovXG5leHBvcnQgZnVuY3Rpb24qIGFkZENvbnRleHQoY29udGV4dCkge1xuICBjb25zdCBjb250ZXh0SGFzaCA9IGtlY2NhazI1Nih7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiBjb250ZXh0LmJpbmFyeSB9KTtcbiAgLy9OT1RFOiB3ZSB0YWtlIGhhc2ggYXMgKnN0cmluZyosIG5vdCBhcyBieXRlcywgYmVjYXVzZSB0aGUgYmluYXJ5IG1heVxuICAvL2NvbnRhaW4gbGluayByZWZlcmVuY2VzIVxuXG4gIGRlYnVnKFwiY29udGV4dCAlT1wiLCBjb250ZXh0KTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuYWRkQ29udGV4dChjb250ZXh0KSk7XG5cbiAgcmV0dXJuIGNvbnRleHRIYXNoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIG5vcm1hbGl6ZUNvbnRleHRzKCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5ub3JtYWxpemVDb250ZXh0cygpKTtcbn1cblxuLyoqXG4gKiBBZGRzIGtub3duIGRlcGxveWVkIGluc3RhbmNlIG9mIGJpbmFyeSBhdCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeSAtIG1heSBiZSB1bmRlZmluZWQgKGUuZy4gcHJlY29tcGlsZXMpXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEICgweC1wcmVmaXhlZCBrZWNjYWsgb2YgYmluYXJ5KVxuICovXG5leHBvcnQgZnVuY3Rpb24qIGFkZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSkge1xuICBsZXQgc2VhcmNoID0geWllbGQgc2VsZWN0KGV2bS5pbmZvLmJpbmFyaWVzLnNlYXJjaCk7XG4gIGxldCBjb250ZXh0ID0gc2VhcmNoKGJpbmFyeSk7XG5cbiAgLy9ub3csIHdoZXRoZXIgd2UgbmVlZGVkIGEgbmV3IGNvbnRleHQgb3Igbm90LCBhZGQgdGhlIGluc3RhbmNlXG4gIHlpZWxkIHB1dChhY3Rpb25zLmFkZEluc3RhbmNlKGFkZHJlc3MsIGNvbnRleHQsIGJpbmFyeSkpO1xuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGJlZ2luKHtcbiAgYWRkcmVzcyxcbiAgYmluYXJ5LFxuICBkYXRhLFxuICBzdG9yYWdlQWRkcmVzcyxcbiAgc3RhdHVzLFxuICBzZW5kZXIsXG4gIHZhbHVlLFxuICBnYXNwcmljZSxcbiAgYmxvY2tcbn0pIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZUdsb2JhbHMoc2VuZGVyLCBnYXNwcmljZSwgYmxvY2spKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZVN0YXR1cyhzdGF0dXMpKTtcbiAgZGVidWcoXCJjb2RleDogJU9cIiwgeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LmNvZGV4KSk7XG4gIGlmIChhZGRyZXNzKSB7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuY2FsbChhZGRyZXNzLCBkYXRhLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmNyZWF0ZShiaW5hcnksIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24qIHRpY2tTYWdhKCkge1xuICBkZWJ1ZyhcImdvdCBUSUNLXCIpO1xuXG4gIHlpZWxkKiBjYWxsc3RhY2tBbmRDb2RleFNhZ2EoKTtcbiAgeWllbGQqIHRyYWNlLnNpZ25hbFRpY2tTYWdhQ29tcGxldGlvbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGNhbGxzdGFja0FuZENvZGV4U2FnYSgpIHtcbiAgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzRXhjZXB0aW9uYWxIYWx0aW5nKSkge1xuICAgIC8vbGV0J3MgaGFuZGxlIHRoaXMgY2FzZSBmaXJzdCBzbyB3ZSBjYW4gYmUgc3VyZSBldmVyeXRoaW5nIGVsc2UgaXMgKm5vdCpcbiAgICAvL2FuIGV4Y2VwdGlvbmFsIGhhbHRcbiAgICBkZWJ1ZyhcImV4Y2VwdGlvbmFsIGhhbHQhXCIpO1xuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZmFpbCgpKTtcbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5pc0NhbGwpKSB7XG4gICAgZGVidWcoXCJnb3QgY2FsbFwiKTtcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBiaW5hcnkgKGUuZy4gaW4gdGhlIGNhc2Ugb2YgcHJlY29tcGlsZWQgY29udHJhY3RzIG9yXG4gICAgLy8gZXh0ZXJuYWxseSBvd25lZCBhY2NvdW50cyksIHRoZW4gdGhlcmUgd2lsbCBiZSBubyB0cmFjZSBzdGVwcyBmb3IgdGhlXG4gICAgLy8gY2FsbGVkIGNvZGUsIGFuZCBzbyB3ZSBzaG91bGRuJ3QgdGVsbCB0aGUgZGVidWdnZXIgdGhhdCB3ZSdyZSBlbnRlcmluZ1xuICAgIC8vIGFub3RoZXIgZXhlY3V0aW9uIGNvbnRleHRcbiAgICBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY2FsbHNQcmVjb21waWxlT3JFeHRlcm5hbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgYWRkcmVzcyA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNhbGxBZGRyZXNzKTtcbiAgICBsZXQgZGF0YSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNhbGxEYXRhKTtcblxuICAgIGRlYnVnKFwiY2FsbGluZyBhZGRyZXNzICVzXCIsIGFkZHJlc3MpO1xuXG4gICAgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzRGVsZWdhdGVDYWxsU3RyaWN0KSkge1xuICAgICAgLy9pZiBkZWxlZ2F0aW5nLCBsZWF2ZSBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCBhbmQgdmFsdWUgdGhlIHNhbWVcbiAgICAgIGxldCB7IHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlIH0gPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuY2FsbCk7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5jYWxsKGFkZHJlc3MsIGRhdGEsIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vdGhpcyBicmFuY2ggY292ZXJzIENBTEwsIENBTExDT0RFLCBhbmQgU1RBVElDQ0FMTFxuICAgICAgbGV0IGN1cnJlbnRDYWxsID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LmNhbGwpO1xuICAgICAgbGV0IHN0b3JhZ2VBZGRyZXNzID0gKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzRGVsZWdhdGVDYWxsQnJvYWQpKVxuICAgICAgICA/IGN1cnJlbnRDYWxsLnN0b3JhZ2VBZGRyZXNzIC8vZm9yIENBTExDT0RFXG4gICAgICAgIDogYWRkcmVzcztcbiAgICAgIGxldCBzZW5kZXIgPSBjdXJyZW50Q2FsbC5zdG9yYWdlQWRkcmVzczsgLy9ub3QgdGhlIGNvZGUgYWRkcmVzcyFcbiAgICAgIGxldCB2YWx1ZSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNhbGxWYWx1ZSk7IC8vMCBpZiBzdGF0aWNcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmNhbGwoYWRkcmVzcywgZGF0YSwgc3RvcmFnZUFkZHJlc3MsIHNlbmRlciwgdmFsdWUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNDcmVhdGUpKSB7XG4gICAgZGVidWcoXCJnb3QgY3JlYXRlXCIpO1xuICAgIGxldCBiaW5hcnkgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jcmVhdGVCaW5hcnkpO1xuICAgIGxldCBjcmVhdGVkQWRkcmVzcyA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNyZWF0ZWRBZGRyZXNzKTtcbiAgICBsZXQgdmFsdWUgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jcmVhdGVWYWx1ZSk7XG4gICAgbGV0IHNlbmRlciA9ICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuY2FsbCkpLnN0b3JhZ2VBZGRyZXNzO1xuICAgIC8vbm90IHRoZSBjb2RlIGFkZHJlc3MhXG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5jcmVhdGUoYmluYXJ5LCBjcmVhdGVkQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkpO1xuICAgIC8vYXMgYWJvdmUsIHN0b3JhZ2VBZGRyZXNzIGhhbmRsZXMgd2hlbiBjYWxsaW5nIGZyb20gYSBjcmVhdGlvbiBjYWxsXG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNIYWx0aW5nKSkge1xuICAgIGRlYnVnKFwiZ290IHJldHVyblwiKTtcblxuICAgIGxldCB7IGJpbmFyeSwgc3RvcmFnZUFkZHJlc3MgfSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5jYWxsKTtcblxuICAgIGlmIChiaW5hcnkpIHtcbiAgICAgIC8vaWYgd2UncmUgcmV0dXJuaW5nIGZyb20gYSBzdWNjZXNzZnVsIGNyZWF0aW9uIGNhbGwsIGxldCdzIGxvZyB0aGVcbiAgICAgIC8vcmVzdWx0XG4gICAgICBsZXQgcmV0dXJuZWRCaW5hcnkgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5yZXR1cm5WYWx1ZSk7XG4gICAgICBsZXQgc2VhcmNoID0geWllbGQgc2VsZWN0KGV2bS5pbmZvLmJpbmFyaWVzLnNlYXJjaCk7XG4gICAgICBsZXQgcmV0dXJuZWRDb250ZXh0ID0gc2VhcmNoKHJldHVybmVkQmluYXJ5KTtcbiAgICAgIHlpZWxkIHB1dChcbiAgICAgICAgYWN0aW9ucy5yZXR1cm5DcmVhdGUoc3RvcmFnZUFkZHJlc3MsIHJldHVybmVkQmluYXJ5LCByZXR1cm5lZENvbnRleHQpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZXR1cm5DYWxsKCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC50b3VjaGVzU3RvcmFnZSkpIHtcbiAgICBsZXQgc3RvcmFnZUFkZHJlc3MgPSAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LmNhbGwpKS5zdG9yYWdlQWRkcmVzcztcbiAgICBsZXQgc2xvdCA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLnN0b3JhZ2VBZmZlY3RlZCk7XG4gICAgLy9ub3RlIHdlIGdldCBuZXh0IHN0b3JhZ2UsIHNpbmNlIHdlJ3JlIHVwZGF0aW5nIHRvIHRoYXRcbiAgICBsZXQgc3RvcmFnZSA9IHlpZWxkIHNlbGVjdChldm0ubmV4dC5zdGF0ZS5zdG9yYWdlKTtcbiAgICAvL25vcm1hbGx5IHdlJ2QgbmVlZCBhIDAgZmFsbGJhY2sgZm9yIHRoaXMgbmV4dCBsaW5lLCBidXQgaW4gdGhpcyBjYXNlIHdlXG4gICAgLy9jYW4gYmUgc3VyZSB0aGUgdmFsdWUgd2lsbCBiZSB0aGVyZSwgc2luY2Ugd2UncmUgdG91Y2hpbmcgdGhhdCBzdG9yYWdlXG4gICAgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzU3RvcmUpKSB7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5zdG9yZShzdG9yYWdlQWRkcmVzcywgc2xvdCwgc3RvcmFnZVtzbG90XSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL290aGVyd2lzZSwgaXQncyBhIGxvYWRcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmxvYWQoc3RvcmFnZUFkZHJlc3MsIHNsb3QsIHN0b3JhZ2Vbc2xvdF0pKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZXNldCgpIHtcbiAgbGV0IGluaXRpYWxDYWxsID0geWllbGQgc2VsZWN0KGV2bS50cmFuc2FjdGlvbi5pbml0aWFsQ2FsbCk7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlc2V0KCkpO1xuICB5aWVsZCBwdXQoaW5pdGlhbENhbGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHVubG9hZCgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMudW5sb2FkVHJhbnNhY3Rpb24oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgeWllbGQgdGFrZUV2ZXJ5KFRJQ0ssIHRpY2tTYWdhKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcImV2bVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmNvbnRyb2xsZXI6c2VsZWN0b3JzXCIpOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCB7IGFueU5vblNraXBwZWRJblJhbmdlIH0gZnJvbSBcImxpYi9hc3QvbWFwXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaWRlbnRpdHkgPSB4ID0+IHg7XG5cbi8qKlxuICogY29udHJvbGxlclxuICovXG5jb25zdCBjb250cm9sbGVyID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGNvbnRyb2xsZXIuc3RhdGVcbiAgICovXG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5jb250cm9sbGVyLFxuICAvKipcbiAgICogY29udHJvbGxlci5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQuZXhlY3V0aW9uQ29udGV4dFxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkNvbnRleHQ6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LmNhbGxdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb25cbiAgICAgKi9cbiAgICBsb2NhdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2VcbiAgICAgICAqL1xuICAgICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlLCBcIi9jdXJyZW50L3RyYWNlL2xvYWRlZFwiXSxcbiAgICAgICAgKHJhbmdlLCBsb2FkZWQpID0+IChsb2FkZWQgPyByYW5nZSA6IG51bGwpXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VcbiAgICAgICAqL1xuICAgICAgc291cmNlOiBjcmVhdGVMZWFmKFxuICAgICAgICBbc29saWRpdHkuY3VycmVudC5zb3VyY2UsIFwiL2N1cnJlbnQvdHJhY2UvbG9hZGVkXCJdLFxuICAgICAgICAoc291cmNlLCBsb2FkZWQpID0+IChsb2FkZWQgPyBzb3VyY2UgOiBudWxsKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24ubm9kZVxuICAgICAgICovXG4gICAgICBub2RlOiBjcmVhdGVMZWFmKFxuICAgICAgICBbc29saWRpdHkuY3VycmVudC5ub2RlLCBcIi9jdXJyZW50L3RyYWNlL2xvYWRlZFwiXSxcbiAgICAgICAgKG5vZGUsIGxvYWRlZCkgPT4gKGxvYWRlZCA/IG5vZGUgOiBudWxsKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmVcbiAgICAgICAqL1xuICAgICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtzb2xpZGl0eS5jdXJyZW50LmlzTXVsdGlsaW5lLCBcIi9jdXJyZW50L3RyYWNlL2xvYWRlZFwiXSxcbiAgICAgICAgKHJhdywgbG9hZGVkKSA9PiAobG9hZGVkID8gcmF3IDogZmFsc2UpXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LnRyYWNlXG4gICAgICovXG4gICAgdHJhY2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LnRyYWNlLmZpbmlzaGVkXG4gICAgICAgKi9cbiAgICAgIGZpbmlzaGVkOiBjcmVhdGVMZWFmKFt0cmFjZS5maW5pc2hlZF0sIGlkZW50aXR5KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQudHJhY2UubG9hZGVkXG4gICAgICAgKi9cbiAgICAgIGxvYWRlZDogY3JlYXRlTGVhZihbdHJhY2UubG9hZGVkXSwgaWRlbnRpdHkpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb250cm9sbGVyLmJyZWFrcG9pbnRzIChuYW1lc3BhY2UpXG4gICAqL1xuICBicmVha3BvaW50czoge1xuICAgIC8qKlxuICAgICAqIGNvbnRyb2xsZXIuYnJlYWtwb2ludHMgKHNlbGVjdG9yKVxuICAgICAqL1xuICAgIF86IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5icmVha3BvaW50cyksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmJyZWFrcG9pbnRzLnJlc29sdmVyIChzZWxlY3RvcilcbiAgICAgKiB0aGlzIHNlbGVjdG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFkanVzdHMgYSBnaXZlbiBsaW5lLWJhc2VkXG4gICAgICogYnJlYWtwb2ludCAob24gbm9kZS1iYXNlZCBicmVha3BvaW50cyBpdCBzaW1wbHkgcmV0dXJucyB0aGUgaW5wdXQpIGJ5XG4gICAgICogcmVwZWF0ZWRseSBtb3ZpbmcgaXQgZG93biBhIGxpbmUgdW50aWwgaXQgbGFuZHMgb24gYSBsaW5lIHdoZXJlIHRoZXJlJ3NcbiAgICAgKiBhY3R1YWxseSBzb21ld2hlcmUgdG8gYnJlYWsuICBpZiBubyBzdWNoIGxpbmUgZXhpc3RzIGJleW9uZCB0aGF0IHBvaW50LCBpdFxuICAgICAqIHJldHVybnMgbnVsbCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHJlc29sdmVyOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLCBzb3VyY2VzID0+IGJyZWFrcG9pbnQgPT4ge1xuICAgICAgbGV0IGFkanVzdGVkQnJlYWtwb2ludDtcbiAgICAgIGlmIChicmVha3BvaW50Lm5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgbGluZSA9IGJyZWFrcG9pbnQubGluZTtcbiAgICAgICAgbGV0IHsgc291cmNlLCBhc3QgfSA9IHNvdXJjZXNbYnJlYWtwb2ludC5zb3VyY2VJZF07XG4gICAgICAgIGxldCBsaW5lTGVuZ3RocyA9IHNvdXJjZS5zcGxpdChcIlxcblwiKS5tYXAobGluZSA9PiBsaW5lLmxlbmd0aCk7XG4gICAgICAgIC8vd2h5IGRvZXMgbmVpdGhlciBKUyBub3IgbG9kYXNoIGhhdmUgYSBzY2FuIGZ1bmN0aW9uIGxpa2UgSGFza2VsbD8/XG4gICAgICAgIC8vZ3Vlc3Mgd2UnbGwgaGF2ZSB0byBkbyBvdXIgc2NhbiBtYW51YWxseVxuICAgICAgICBsZXQgbGluZVN0YXJ0cyA9IFswXTtcbiAgICAgICAgZm9yIChsZXQgbGVuZ3RoIG9mIGxpbmVMZW5ndGhzKSB7XG4gICAgICAgICAgbGluZVN0YXJ0cy5wdXNoKGxpbmVTdGFydHNbbGluZVN0YXJ0cy5sZW5ndGggLSAxXSArIGxlbmd0aCArIDEpO1xuICAgICAgICAgIC8vKzEgZm9yIHRoZSAvbiBpdHNlbGZcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBcImxpbmU6ICVzXCIsXG4gICAgICAgICAgc291cmNlLnNsaWNlKGxpbmVTdGFydHNbbGluZV0sIGxpbmVTdGFydHNbbGluZV0gKyBsaW5lTGVuZ3Roc1tsaW5lXSlcbiAgICAgICAgKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIGxpbmUgPCBsaW5lTGVuZ3Rocy5sZW5ndGggJiZcbiAgICAgICAgICAhYW55Tm9uU2tpcHBlZEluUmFuZ2UoYXN0LCBsaW5lU3RhcnRzW2xpbmVdLCBsaW5lTGVuZ3Roc1tsaW5lXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVidWcoXCJpbmNyZW1lbnRpbmdcIik7XG4gICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lID49IGxpbmVMZW5ndGhzLmxlbmd0aCkge1xuICAgICAgICAgIGFkanVzdGVkQnJlYWtwb2ludCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRqdXN0ZWRCcmVha3BvaW50ID0geyAuLi5icmVha3BvaW50LCBsaW5lIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKFwibm9kZS1iYXNlZCBicmVha3BvaW50XCIpO1xuICAgICAgICBhZGp1c3RlZEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkanVzdGVkQnJlYWtwb2ludDtcbiAgICB9KVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb250cm9sbGVyLmZpbmlzaGVkXG4gICAqIGRlcHJlY2F0ZWQgYWxpYXMgZm9yIGNvbnRyb2xsZXIuY3VycmVudC50cmFjZS5maW5pc2hlZFxuICAgKi9cbiAgZmluaXNoZWQ6IGNyZWF0ZUxlYWYoW1wiL2N1cnJlbnQvZmluaXNoZWRcIl0sIGZpbmlzaGVkID0+IGZpbmlzaGVkKSxcblxuICAvKipcbiAgICogY29udHJvbGxlci5pc1N0ZXBwaW5nXG4gICAqL1xuICBpc1N0ZXBwaW5nOiBjcmVhdGVMZWFmKFtcIi4vc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmlzU3RlcHBpbmcpXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29udHJvbGxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9zZWxlY3RvcnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0Om1hcFwiKTtcblxuaW1wb3J0IEludGVydmFsVHJlZSBmcm9tIFwibm9kZS1pbnRlcnZhbC10cmVlXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuaW1wb3J0IHsgaXNTa2lwcGVkTm9kZVR5cGUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZ2Uobm9kZSkge1xuICAvLyBzcmM6IFwiPHN0YXJ0Pjo8bGVuZ3RoPjo8Xz5cIlxuICAvLyByZXR1cm5zIFtzdGFydCwgZW5kXVxuICBsZXQgW3N0YXJ0LCBsZW5ndGhdID0gbm9kZS5zcmNcbiAgICAuc3BsaXQoXCI6XCIpXG4gICAgLnNsaWNlKDAsIDIpXG4gICAgLm1hcChpID0+IHBhcnNlSW50KGkpKTtcblxuICByZXR1cm4gW3N0YXJ0LCBzdGFydCArIGxlbmd0aF07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlTm9kZXMobm9kZSwgcG9pbnRlciA9IFwiXCIpIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5ub2RlLm1hcCgoc3ViLCBpKSA9PiByYW5nZU5vZGVzKHN1YiwgYCR7cG9pbnRlcn0vJHtpfWApKVxuICAgICk7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICBpZiAobm9kZS5zcmMgIT09IHVuZGVmaW5lZCAmJiBub2RlLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vdGhlcmUgYXJlIHNvbWUgXCJwc2V1ZG8tbm9kZXNcIiB3aXRoIGEgc3JjIGJ1dCBubyBpZC5cbiAgICAgIC8vdGhlc2Ugd2lsbCBjYXVzZSBwcm9ibGVtcywgc28gd2Ugd2FudCB0byBleGNsdWRlIHRoZW0uXG4gICAgICAvLyh0byBteSBrbm93bGVkZ2UgdGhpcyBvbmx5IGhhcHBlbnMgd2l0aCB0aGUgZXh0ZXJuYWxSZWZlcmVuY2VzXG4gICAgICAvL3RvIGFuIElubGluZUFzc2VtYmx5IG5vZGUsIHNvIGV4Y2x1ZGluZyB0aGVtIGp1c3QgbWVhbnMgd2UgZmluZFxuICAgICAgLy90aGUgSW5saW5lQXNzZW1ibHkgbm9kZSBpbnN0ZWFkLCB3aGljaCBpcyBmaW5lKVxuICAgICAgcmVzdWx0cy5wdXNoKHsgcG9pbnRlciwgcmFuZ2U6IGdldFJhbmdlKG5vZGUpIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzLmNvbmNhdChcbiAgICAgIC4uLk9iamVjdC5rZXlzKG5vZGUpLm1hcChrZXkgPT5cbiAgICAgICAgcmFuZ2VOb2Rlcyhub2RlW2tleV0sIGAke3BvaW50ZXJ9LyR7a2V5fWApXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE92ZXJsYXBwaW5nUmFuZ2Uobm9kZSwgc291cmNlU3RhcnQsIHNvdXJjZUxlbmd0aCkge1xuICBsZXQgcmFuZ2VzID0gcmFuZ2VOb2Rlcyhub2RlKTtcbiAgbGV0IHRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XG5cbiAgZm9yIChsZXQgeyByYW5nZSwgcG9pbnRlciB9IG9mIHJhbmdlcykge1xuICAgIGxldCBbc3RhcnQsIGVuZF0gPSByYW5nZTtcbiAgICB0cmVlLmluc2VydChzdGFydCwgZW5kLCB7IHJhbmdlLCBwb2ludGVyIH0pO1xuICB9XG5cbiAgbGV0IHNvdXJjZUVuZCA9IHNvdXJjZVN0YXJ0ICsgc291cmNlTGVuZ3RoO1xuXG4gIHJldHVybiB0cmVlLnNlYXJjaChzb3VyY2VTdGFydCwgc291cmNlRW5kKTtcbiAgLy9yZXR1cm5zIGV2ZXJ5dGhpbmcgb3ZlcmxhcHBpbmcgdGhlIGdpdmVuIHJhbmdlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSYW5nZShub2RlLCBzb3VyY2VTdGFydCwgc291cmNlTGVuZ3RoKSB7XG4gIC8vIGZpbmQgbm9kZXMgdGhhdCBmdWxseSBjb250YWluIHJlcXVlc3RlZCByYW5nZSxcbiAgLy8gcmV0dXJuIGxvbmdlc3QgcG9pbnRlclxuICBsZXQgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyBzb3VyY2VMZW5ndGg7XG4gIHJldHVybiBmaW5kT3ZlcmxhcHBpbmdSYW5nZShub2RlLCBzb3VyY2VTdGFydCwgc291cmNlTGVuZ3RoKVxuICAgIC5maWx0ZXIoKHsgcmFuZ2UgfSkgPT4gc291cmNlU3RhcnQgPj0gcmFuZ2VbMF0gJiYgc291cmNlRW5kIDw9IHJhbmdlWzFdKVxuICAgIC5tYXAoKHsgcG9pbnRlciB9KSA9PiBwb2ludGVyKVxuICAgIC5yZWR1Y2UoKGEsIGIpID0+IChhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGIpLCBcIlwiKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYW55Tm9uU2tpcHBlZEluUmFuZ2Uobm9kZSwgc291cmNlU3RhcnQsIHNvdXJjZUxlbmd0aCkge1xuICBsZXQgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyBzb3VyY2VMZW5ndGg7XG4gIHJldHVybiBmaW5kT3ZlcmxhcHBpbmdSYW5nZShub2RlLCBzb3VyY2VTdGFydCwgc291cmNlTGVuZ3RoKS5zb21lKFxuICAgICh7IHJhbmdlLCBwb2ludGVyIH0pID0+XG4gICAgICBzb3VyY2VTdGFydCA8PSByYW5nZVswXSAmJiAvL3dlIHdhbnQgdG8gZ28gYnkgc3RhcnRpbmcgbGluZVxuICAgICAgcmFuZ2VbMF0gPCBzb3VyY2VFbmQgJiZcbiAgICAgICFpc1NraXBwZWROb2RlVHlwZShqc29ucG9pbnRlci5nZXQobm9kZSwgcG9pbnRlcikpXG4gICAgLy9OT1RFOiB0aGlzIGRvZXNuJ3QgYWN0dWFsbHkgY2F0Y2ggZXZlcnl0aGluZyBza2lwcGVkISAgQnV0IGRvaW5nIGJldHRlclxuICAgIC8vaXMgaGFyZFxuICApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3QvbWFwLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb246c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuY29uc3Qgc2Vzc2lvbiA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qXG4gICAqIHNlc3Npb24uc3RhdGVcbiAgICovXG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5zZXNzaW9uLFxuXG4gIC8qKlxuICAgKiBzZXNzaW9uLmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLmluZm8uYWZmZWN0ZWRJbnN0YW5jZXNcbiAgICAgKi9cbiAgICBhZmZlY3RlZEluc3RhbmNlczogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uY3VycmVudC5jb2RleC5pbnN0YW5jZXMsIGV2bS5pbmZvLmNvbnRleHRzLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLFxuXG4gICAgICAoaW5zdGFuY2VzLCBjb250ZXh0cywgc291cmNlcykgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbnN0YW5jZXMpLm1hcChcbiAgICAgICAgICAgIChbYWRkcmVzcywgeyBjb250ZXh0OiBjb250ZXh0SWQsIGJpbmFyeSB9XSkgPT4ge1xuICAgICAgICAgICAgICBkZWJ1ZyhcImluc3RhbmNlcyAlT1wiLCBpbnN0YW5jZXMpO1xuICAgICAgICAgICAgICBkZWJ1ZyhcImNvbnRleHRzICVPXCIsIGNvbnRleHRzKTtcbiAgICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBjb250ZXh0c1tjb250ZXh0SWRdO1xuICAgICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBbYWRkcmVzc106IHsgYmluYXJ5IH0gfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgeyBjb250cmFjdE5hbWUsIHByaW1hcnlTb3VyY2UgfSA9IGNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgbGV0IHNvdXJjZSA9XG4gICAgICAgICAgICAgICAgcHJpbWFyeVNvdXJjZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICA/IHNvdXJjZXNbcHJpbWFyeVNvdXJjZV1cbiAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW2FkZHJlc3NdOiB7XG4gICAgICAgICAgICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICBiaW5hcnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgKVxuICB9LFxuXG4gIC8qKlxuICAgKiBzZXNzaW9uLnRyYW5zYWN0aW9uIChuYW1lc3BhY2UpXG4gICAqL1xuICB0cmFuc2FjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24gKHNlbGVjdG9yKVxuICAgICAqIGNvbnRhaW5zIHRoZSB3ZWIzIHRyYW5zYWN0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIF86IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS50cmFuc2FjdGlvbiksXG5cbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLnRyYW5zYWN0aW9uLnJlY2VpcHRcbiAgICAgKiBjb250YWlucyB0aGUgd2ViMyByZWNlaXB0IG9iamVjdFxuICAgICAqL1xuICAgIHJlY2VpcHQ6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5yZWNlaXB0KSxcblxuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24uYmxvY2tcbiAgICAgKiBjb250YWlucyB0aGUgd2ViMyBibG9jayBvYmplY3RcbiAgICAgKi9cbiAgICBibG9jazogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmJsb2NrKVxuICB9LFxuXG4gIC8qXG4gICAqIHNlc3Npb24uc3RhdHVzIChuYW1lc3BhY2UpXG4gICAqL1xuICBzdGF0dXM6IHtcbiAgICAvKlxuICAgICAqIHNlc3Npb24uc3RhdHVzLnJlYWR5T3JFcnJvclxuICAgICAqL1xuICAgIHJlYWR5T3JFcnJvcjogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLnJlYWR5KSxcblxuICAgIC8qXG4gICAgICogc2Vzc2lvbi5zdGF0dXMucmVhZHlcbiAgICAgKi9cbiAgICByZWFkeTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vcmVhZHlPckVycm9yXCIsIFwiLi9pc0Vycm9yXCJdLFxuICAgICAgKHJlYWR5T3JFcnJvciwgZXJyb3IpID0+IHJlYWR5T3JFcnJvciAmJiAhZXJyb3JcbiAgICApLFxuXG4gICAgLypcbiAgICAgKiBzZXNzaW9uLnN0YXR1cy53YWl0aW5nXG4gICAgICovXG4gICAgd2FpdGluZzogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+ICFzdGF0ZS5yZWFkeSksXG5cbiAgICAvKlxuICAgICAqIHNlc3Npb24uc3RhdHVzLmVycm9yXG4gICAgICovXG4gICAgZXJyb3I6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5sYXN0TG9hZGluZ0Vycm9yKSxcblxuICAgIC8qXG4gICAgICogc2Vzc2lvbi5zdGF0dXMuaXNFcnJvclxuICAgICAqL1xuICAgIGlzRXJyb3I6IGNyZWF0ZUxlYWYoW1wiLi9lcnJvclwiXSwgZXJyb3IgPT4gZXJyb3IgIT09IG51bGwpLFxuXG4gICAgLypcbiAgICAgKiBzZXNzaW9uLnN0YXR1cy5zdWNjZXNzXG4gICAgICovXG4gICAgc3VjY2VzczogY3JlYXRlTGVhZihbXCIuL2Vycm9yXCJdLCBlcnJvciA9PiBlcnJvciA9PT0gbnVsbCksXG5cbiAgICAvKlxuICAgICAqIHNlc3Npb24uc3RhdHVzLmVycm9yZWRcbiAgICAgKi9cbiAgICBlcnJvcmVkOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9yZWFkeU9yRXJyb3JcIiwgXCIuL2lzRXJyb3JcIl0sXG4gICAgICAocmVhZHlPckVycm9yLCBlcnJvcikgPT4gcmVhZHlPckVycm9yICYmIGVycm9yXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogc2Vzc2lvbi5zdGF0dXMubG9hZGVkXG4gICAgICovXG4gICAgbG9hZGVkOiBjcmVhdGVMZWFmKFt0cmFjZS5sb2FkZWRdLCBsb2FkZWQgPT4gbG9hZGVkKSxcblxuICAgIC8qXG4gICAgICogc2Vzc2lvbi5zdGF0dXMucHJvamVjdEluZm9Db21wdXRlZFxuICAgICAqL1xuICAgIHByb2plY3RJbmZvQ29tcHV0ZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvc3RhdGVcIl0sXG4gICAgICBzdGF0ZSA9PiBzdGF0ZS5wcm9qZWN0SW5mb0NvbXB1dGVkXG4gICAgKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc2Vzc2lvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9zZWxlY3RvcnMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgU0NPUEUgPSBcIlNDT1BFXCI7XG5leHBvcnQgZnVuY3Rpb24gc2NvcGUoaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNDT1BFLFxuICAgIGlkLFxuICAgIHBvaW50ZXIsXG4gICAgcGFyZW50SWQsXG4gICAgc291cmNlSWRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IERFQ0xBUkUgPSBcIkRFQ0xBUkVfVkFSSUFCTEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWNsYXJlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBERUNMQVJFLFxuICAgIG5vZGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFTU0lHTiA9IFwiQVNTSUdOXCI7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKGFzc2lnbm1lbnRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVNTSUdOLFxuICAgIGFzc2lnbm1lbnRzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBNQVBfUEFUSF9BTkRfQVNTSUdOID0gXCJNQVBfUEFUSF9BTkRfQVNTSUdOXCI7XG5leHBvcnQgZnVuY3Rpb24gbWFwUGF0aEFuZEFzc2lnbihcbiAgYWRkcmVzcyxcbiAgc2xvdCxcbiAgYXNzaWdubWVudHMsXG4gIHR5cGVJZGVudGlmaWVyLFxuICBwYXJlbnRUeXBlXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBNQVBfUEFUSF9BTkRfQVNTSUdOLFxuICAgIGFkZHJlc3MsXG4gICAgc2xvdCxcbiAgICBhc3NpZ25tZW50cyxcbiAgICB0eXBlSWRlbnRpZmllcixcbiAgICBwYXJlbnRUeXBlXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVNFVCA9IFwiREFUQV9SRVNFVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KCkge1xuICByZXR1cm4geyB0eXBlOiBSRVNFVCB9O1xufVxuXG5leHBvcnQgY29uc3QgREVGSU5FX1RZUEUgPSBcIkRFRklORV9UWVBFXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lVHlwZShub2RlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogREVGSU5FX1RZUEUsXG4gICAgbm9kZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQUxMT0NBVEUgPSBcIkFMTE9DQVRFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWxsb2NhdGUoc3RvcmFnZSwgbWVtb3J5LCBjYWxsZGF0YSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFMTE9DQVRFLFxuICAgIHN0b3JhZ2UsXG4gICAgbWVtb3J5LFxuICAgIGNhbGxkYXRhXG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvYWN0aW9ucy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXRcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0XCJcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBBRERfQ09OVEVYVCA9IFwiRVZNX0FERF9DT05URVhUXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkQ29udGV4dCh7XG4gIGNvbnRyYWN0TmFtZSxcbiAgYmluYXJ5LFxuICBzb3VyY2VNYXAsXG4gIGNvbXBpbGVyLFxuICBhYmksXG4gIGNvbnRyYWN0SWQsXG4gIGNvbnRyYWN0S2luZCxcbiAgaXNDb25zdHJ1Y3RvclxufSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9DT05URVhULFxuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBiaW5hcnksXG4gICAgc291cmNlTWFwLFxuICAgIGNvbXBpbGVyLFxuICAgIGFiaSxcbiAgICBjb250cmFjdElkLFxuICAgIGNvbnRyYWN0S2luZCxcbiAgICBpc0NvbnN0cnVjdG9yXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBOT1JNQUxJWkVfQ09OVEVYVFMgPSBcIkVWTV9OT1JNQUxJWkVfQ09OVEVYVFNcIjtcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVDb250ZXh0cygpIHtcbiAgcmV0dXJuIHsgdHlwZTogTk9STUFMSVpFX0NPTlRFWFRTIH07XG59XG5cbmV4cG9ydCBjb25zdCBBRERfSU5TVEFOQ0UgPSBcIkVWTV9BRERfSU5TVEFOQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRJbnN0YW5jZShhZGRyZXNzLCBjb250ZXh0LCBiaW5hcnkpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBRERfSU5TVEFOQ0UsXG4gICAgYWRkcmVzcyxcbiAgICBjb250ZXh0LFxuICAgIGJpbmFyeVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgU0FWRV9HTE9CQUxTID0gXCJTQVZFX0dMT0JBTFNcIjtcbmV4cG9ydCBmdW5jdGlvbiBzYXZlR2xvYmFscyhvcmlnaW4sIGdhc3ByaWNlLCBibG9jaykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNBVkVfR0xPQkFMUyxcbiAgICBvcmlnaW4sXG4gICAgZ2FzcHJpY2UsXG4gICAgYmxvY2tcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNBVkVfU1RBVFVTID0gXCJTQVZFX1NUQVRVU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9TVEFUVVMsXG4gICAgc3RhdHVzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBDQUxMID0gXCJDQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gY2FsbChhZGRyZXNzLCBkYXRhLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENBTEwsXG4gICAgYWRkcmVzcyxcbiAgICBkYXRhLFxuICAgIHN0b3JhZ2VBZGRyZXNzLFxuICAgIHNlbmRlcixcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQ1JFQVRFID0gXCJDUkVBVEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoYmluYXJ5LCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENSRUFURSxcbiAgICBiaW5hcnksXG4gICAgc3RvcmFnZUFkZHJlc3MsXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVRVUk5fQ0FMTCA9IFwiUkVUVVJOX0NBTExcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5DYWxsKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFVFVSTl9DQUxMXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVRVUk5fQ1JFQVRFID0gXCJSRVRVUk5fQ1JFQVRFXCI7XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuQ3JlYXRlKGFkZHJlc3MsIGNvZGUsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRVRVUk5fQ1JFQVRFLFxuICAgIGFkZHJlc3MsXG4gICAgY29kZSxcbiAgICBjb250ZXh0XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBGQUlMID0gXCJGQUlMXCI7XG5leHBvcnQgZnVuY3Rpb24gZmFpbCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBGQUlMXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVE9SRSA9IFwiU1RPUkVcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdG9yZShhZGRyZXNzLCBzbG90LCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNUT1JFLFxuICAgIGFkZHJlc3MsXG4gICAgc2xvdCxcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgTE9BRCA9IFwiTE9BRFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWQoYWRkcmVzcywgc2xvdCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBMT0FELFxuICAgIGFkZHJlc3MsXG4gICAgc2xvdCxcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIkVWTV9SRVNFVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHN0b3JhZ2VBZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVTRVQsXG4gICAgc3RvcmFnZUFkZHJlc3NcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFVOTE9BRF9UUkFOU0FDVElPTiA9IFwiRVZNX1VOTE9BRF9UUkFOU0FDVElPTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIHVubG9hZFRyYW5zYWN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFVOTE9BRF9UUkFOU0FDVElPTlxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9ldm0vYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp3ZWIzOnNhZ2FzXCIpO1xuXG5pbXBvcnQge1xuICBhbGwsXG4gIHRha2VFdmVyeSxcbiAgYXBwbHksXG4gIGZvcmssXG4gIGpvaW4sXG4gIHRha2UsXG4gIHB1dFxufSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIHNlc3Npb24gZnJvbSBcImxpYi9zZXNzaW9uL2FjdGlvbnNcIjtcblxuaW1wb3J0IEJOIGZyb20gXCJibi5qc1wiO1xuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjsgLy9qdXN0IGZvciB1dGlscyFcbmltcG9ydCAqIGFzIERlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuXG5pbXBvcnQgV2ViM0FkYXB0ZXIgZnJvbSBcIi4uL2FkYXB0ZXJcIjtcblxuZnVuY3Rpb24qIGZldGNoVHJhbnNhY3Rpb25JbmZvKGFkYXB0ZXIsIHsgdHhIYXNoIH0pIHtcbiAgZGVidWcoXCJpbnNwZWN0aW5nIHRyYW5zYWN0aW9uXCIpO1xuICB2YXIgdHJhY2U7XG4gIHRyeSB7XG4gICAgdHJhY2UgPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldFRyYWNlLCBbdHhIYXNoXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgZXJyb3JcIik7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZXJyb3IoZSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlYnVnKFwiZ290IHRyYWNlXCIpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlVHJhY2UodHJhY2UpKTtcblxuICBsZXQgdHggPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldFRyYW5zYWN0aW9uLCBbdHhIYXNoXSk7XG4gIGRlYnVnKFwidHggJU9cIiwgdHgpO1xuICBsZXQgcmVjZWlwdCA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0UmVjZWlwdCwgW3R4SGFzaF0pO1xuICBkZWJ1ZyhcInJlY2VpcHQgJU9cIiwgcmVjZWlwdCk7XG4gIGxldCBibG9jayA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0QmxvY2ssIFt0eC5ibG9ja051bWJlcl0pO1xuICBkZWJ1ZyhcImJsb2NrICVPXCIsIGJsb2NrKTtcblxuICB5aWVsZCBwdXQoc2Vzc2lvbi5zYXZlVHJhbnNhY3Rpb24odHgpKTtcbiAgeWllbGQgcHV0KHNlc3Npb24uc2F2ZVJlY2VpcHQocmVjZWlwdCkpO1xuICB5aWVsZCBwdXQoc2Vzc2lvbi5zYXZlQmxvY2soYmxvY2spKTtcblxuICAvL3RoZXNlIG9uZXMgZ2V0IGdyb3VwZWQgdG9nZXRoZXIgZm9yIGNvbnZlbmllbmNlXG4gIGxldCBzb2xpZGl0eUJsb2NrID0ge1xuICAgIGNvaW5iYXNlOiBibG9jay5taW5lcixcbiAgICBkaWZmaWN1bHR5OiBuZXcgQk4oYmxvY2suZGlmZmljdWx0eSksXG4gICAgZ2FzbGltaXQ6IG5ldyBCTihibG9jay5nYXNMaW1pdCksXG4gICAgbnVtYmVyOiBuZXcgQk4oYmxvY2subnVtYmVyKSxcbiAgICB0aW1lc3RhbXA6IG5ldyBCTihibG9jay50aW1lc3RhbXApXG4gIH07XG5cbiAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICB5aWVsZCBwdXQoXG4gICAgICBhY3Rpb25zLnJlY2VpdmVDYWxsKHtcbiAgICAgICAgYWRkcmVzczogdHgudG8sXG4gICAgICAgIGRhdGE6IHR4LmlucHV0LFxuICAgICAgICBzdG9yYWdlQWRkcmVzczogdHgudG8sXG4gICAgICAgIHN0YXR1czogcmVjZWlwdC5zdGF0dXMsXG4gICAgICAgIHNlbmRlcjogdHguZnJvbSxcbiAgICAgICAgdmFsdWU6IG5ldyBCTih0eC52YWx1ZSksXG4gICAgICAgIGdhc3ByaWNlOiBuZXcgQk4odHguZ2FzUHJpY2UpLFxuICAgICAgICBibG9jazogc29saWRpdHlCbG9ja1xuICAgICAgfSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCBzdG9yYWdlQWRkcmVzcyA9IFdlYjMudXRpbHMuaXNBZGRyZXNzKHJlY2VpcHQuY29udHJhY3RBZGRyZXNzKVxuICAgICAgPyByZWNlaXB0LmNvbnRyYWN0QWRkcmVzc1xuICAgICAgOiBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTO1xuICAgIHlpZWxkIHB1dChcbiAgICAgIGFjdGlvbnMucmVjZWl2ZUNhbGwoe1xuICAgICAgICBiaW5hcnk6IHR4LmlucHV0LFxuICAgICAgICBzdG9yYWdlQWRkcmVzcyxcbiAgICAgICAgc3RhdHVzOiByZWNlaXB0LnN0YXR1cyxcbiAgICAgICAgc2VuZGVyOiB0eC5mcm9tLFxuICAgICAgICB2YWx1ZTogbmV3IEJOKHR4LnZhbHVlKSxcbiAgICAgICAgZ2FzcHJpY2U6IG5ldyBCTih0eC5nYXNQcmljZSksXG4gICAgICAgIGJsb2NrOiBzb2xpZGl0eUJsb2NrXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24qIGZldGNoQmluYXJ5KGFkYXB0ZXIsIHsgYWRkcmVzcywgYmxvY2sgfSkge1xuICBkZWJ1ZyhcImZldGNoaW5nIGJpbmFyeSBmb3IgJXNcIiwgYWRkcmVzcyk7XG4gIGxldCBiaW5hcnkgPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldERlcGxveWVkQ29kZSwgW2FkZHJlc3MsIGJsb2NrXSk7XG5cbiAgZGVidWcoXCJyZWNlaXZlZCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5zcGVjdCh0eEhhc2gpKTtcblxuICBsZXQgYWN0aW9uID0geWllbGQgdGFrZShbYWN0aW9ucy5SRUNFSVZFX1RSQUNFLCBhY3Rpb25zLkVSUk9SX1dFQjNdKTtcbiAgZGVidWcoXCJhY3Rpb24gJW9cIiwgYWN0aW9uKTtcblxuICB2YXIgdHJhY2U7XG4gIGlmIChhY3Rpb24udHlwZSA9PSBhY3Rpb25zLlJFQ0VJVkVfVFJBQ0UpIHtcbiAgICB0cmFjZSA9IGFjdGlvbi50cmFjZTtcbiAgICBkZWJ1ZyhcInJlY2VpdmVkIHRyYWNlXCIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGVycm9yOiBhY3Rpb24uZXJyb3IgfTtcbiAgfVxuXG4gIGxldCB7XG4gICAgYWRkcmVzcyxcbiAgICBiaW5hcnksXG4gICAgZGF0YSxcbiAgICBzdG9yYWdlQWRkcmVzcyxcbiAgICBzdGF0dXMsXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlLFxuICAgIGdhc3ByaWNlLFxuICAgIGJsb2NrXG4gIH0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuUkVDRUlWRV9DQUxMKTtcbiAgZGVidWcoXCJyZWNlaXZlZCBjYWxsXCIpO1xuXG4gIHJldHVybiB7XG4gICAgdHJhY2UsXG4gICAgYWRkcmVzcyxcbiAgICBiaW5hcnksXG4gICAgZGF0YSxcbiAgICBzdG9yYWdlQWRkcmVzcyxcbiAgICBzdGF0dXMsXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlLFxuICAgIGdhc3ByaWNlLFxuICAgIGJsb2NrXG4gIH07XG59XG5cbi8vTk9URTogdGhlIGJsb2NrIGFyZ3VtZW50IGlzIG9wdGlvbmFsXG5leHBvcnQgZnVuY3Rpb24qIG9idGFpbkJpbmFyaWVzKGFkZHJlc3NlcywgYmxvY2spIHtcbiAgbGV0IHRhc2tzID0geWllbGQgYWxsKGFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiBmb3JrKHJlY2VpdmVCaW5hcnksIGFkZHJlc3MpKSk7XG5cbiAgZGVidWcoXCJyZXF1ZXN0aW5nIGJpbmFyaWVzXCIpO1xuICB5aWVsZCBhbGwoYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IHB1dChhY3Rpb25zLmZldGNoQmluYXJ5KGFkZHJlc3MsIGJsb2NrKSkpKTtcblxuICBsZXQgYmluYXJpZXMgPSBbXTtcbiAgYmluYXJpZXMgPSB5aWVsZCBqb2luKHRhc2tzKTtcblxuICBkZWJ1ZyhcImJpbmFyaWVzICVvXCIsIGJpbmFyaWVzKTtcblxuICByZXR1cm4gYmluYXJpZXM7XG59XG5cbmZ1bmN0aW9uKiByZWNlaXZlQmluYXJ5KGFkZHJlc3MpIHtcbiAgbGV0IHsgYmluYXJ5IH0gPSB5aWVsZCB0YWtlKFxuICAgIGFjdGlvbiA9PiBhY3Rpb24udHlwZSA9PSBhY3Rpb25zLlJFQ0VJVkVfQklOQVJZICYmIGFjdGlvbi5hZGRyZXNzID09IGFkZHJlc3NcbiAgKTtcbiAgZGVidWcoXCJnb3QgYmluYXJ5IGZvciAlc1wiLCBhZGRyZXNzKTtcblxuICByZXR1cm4gYmluYXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGluaXQocHJvdmlkZXIpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5pdChwcm92aWRlcikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIC8vIHdhaXQgZm9yIHdlYjMgaW5pdCBzaWduYWxcbiAgbGV0IHsgcHJvdmlkZXIgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5JTklUX1dFQjMpO1xuICBsZXQgYWRhcHRlciA9IG5ldyBXZWIzQWRhcHRlcihwcm92aWRlcik7XG5cbiAgeWllbGQgdGFrZUV2ZXJ5KGFjdGlvbnMuSU5TUEVDVCwgZmV0Y2hUcmFuc2FjdGlvbkluZm8sIGFkYXB0ZXIpO1xuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5GRVRDSF9CSU5BUlksIGZldGNoQmluYXJ5LCBhZGFwdGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcIndlYjNcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvc2FnYXMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ3ZWIzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2ViM1wiXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWRlY29kZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlY29kZXJcIlxuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmNvbnRyb2xsZXI6c2FnYXNcIik7XG5cbmltcG9ydCB7IHB1dCwgY2FsbCwgcmFjZSwgdGFrZSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuXG5pbXBvcnQgeyBwcmVmaXhOYW1lLCBpc0RlbGliZXJhdGVseVNraXBwZWROb2RlVHlwZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBkYXRhIGZyb20gXCJsaWIvZGF0YS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZXZtIGZyb20gXCJsaWIvZXZtL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NhZ2FzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGNvbnRyb2xsZXIgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5jb25zdCBTVEVQX1NBR0FTID0ge1xuICBbYWN0aW9ucy5BRFZBTkNFXTogYWR2YW5jZSxcbiAgW2FjdGlvbnMuU1RFUF9ORVhUXTogc3RlcE5leHQsXG4gIFthY3Rpb25zLlNURVBfT1ZFUl06IHN0ZXBPdmVyLFxuICBbYWN0aW9ucy5TVEVQX0lOVE9dOiBzdGVwSW50byxcbiAgW2FjdGlvbnMuU1RFUF9PVVRdOiBzdGVwT3V0LFxuICBbYWN0aW9ucy5DT05USU5VRV06IGNvbnRpbnVlVW50aWxCcmVha3BvaW50XG59O1xuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cm9sIGFjdGlvblwiKTtcbiAgICBsZXQgYWN0aW9uID0geWllbGQgdGFrZShPYmplY3Qua2V5cyhTVEVQX1NBR0FTKSk7XG4gICAgaWYgKCEoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC50cmFjZS5sb2FkZWQpKSkge1xuICAgICAgY29udGludWU7IC8vd2hpbGUgbm8gdHJhY2UgaXMgbG9hZGVkLCBzdGVwIGFjdGlvbnMgYXJlIGlnbm9yZWRcbiAgICB9XG4gICAgZGVidWcoXCJnb3QgY29udHJvbCBhY3Rpb25cIik7XG4gICAgbGV0IHNhZ2EgPSBTVEVQX1NBR0FTW2FjdGlvbi50eXBlXTtcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnN0YXJ0U3RlcHBpbmcoKSk7XG4gICAgeWllbGQgcmFjZSh7XG4gICAgICBleGVjOiBjYWxsKHNhZ2EsIGFjdGlvbiksIC8vbm90IGFsbCB3aWxsIHVzZSB0aGlzXG4gICAgICBpbnRlcnJ1cHQ6IHRha2UoYWN0aW9ucy5JTlRFUlJVUFQpXG4gICAgfSk7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZG9uZVN0ZXBwaW5nKCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJjb250cm9sbGVyXCIsIHNhZ2EpO1xuXG4vKlxuICogQWR2YW5jZSB0aGUgc3RhdGUgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBpbnN0cnVjdGlvbnMgKGJ1dCBub3QgcGFzdCB0aGUgZW5kKVxuICogKGlmIG5vIGNvdW50IGdpdmVuLCBhZHZhbmNlIDEpXG4gKi9cbmZ1bmN0aW9uKiBhZHZhbmNlKGFjdGlvbikge1xuICBsZXQgY291bnQgPVxuICAgIGFjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGFjdGlvbi5jb3VudCAhPT0gdW5kZWZpbmVkID8gYWN0aW9uLmNvdW50IDogMTtcbiAgLy9kZWZhdWx0IGlzLCBhcyBtZW50aW9uZWQsIHRvIGFkdmFuY2UgMVxuICBmb3IgKFxuICAgIGxldCBpID0gMDtcbiAgICBpIDwgY291bnQgJiYgISh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LnRyYWNlLmZpbmlzaGVkKSk7XG4gICAgaSsrXG4gICkge1xuICAgIHlpZWxkKiB0cmFjZS5hZHZhbmNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBzdGVwTmV4dCAtIHN0ZXAgdG8gdGhlIG5leHQgbG9naWNhbCBjb2RlIHNlZ21lbnRcbiAqXG4gKiBOb3RlOiBJdCBtaWdodCB0YWtlIG11bHRpcGxlIGluc3RydWN0aW9ucyB0byBleHByZXNzIHRoZSBzYW1lIHNlY3Rpb24gb2YgY29kZS5cbiAqIFwiU3RlcHBpbmdcIiwgdGhlbiwgaXMgc3RlcHBpbmcgdG8gdGhlIG5leHQgbG9naWNhbCBpdGVtLCBub3Qgc3RlcHBpbmcgdG8gdGhlIG5leHRcbiAqIGluc3RydWN0aW9uLiBTZWUgYWR2YW5jZSgpIGlmIHlvdSdkIGxpa2UgdG8gYWR2YW5jZSBieSBvbmUgaW5zdHJ1Y3Rpb24uXG4gKi9cbmZ1bmN0aW9uKiBzdGVwTmV4dCgpIHtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuXG4gIHZhciB1cGNvbWluZywgZmluaXNoZWQ7XG5cbiAgZG8ge1xuICAgIC8vIGFkdmFuY2UgYXQgbGVhc3Qgb25jZSBzdGVwXG4gICAgeWllbGQqIGFkdmFuY2UoKTtcblxuICAgIC8vIGFuZCBjaGVjayB0aGUgbmV4dCBzb3VyY2UgcmFuZ2VcbiAgICB0cnkge1xuICAgICAgdXBjb21pbmcgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1cGNvbWluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgZmluaXNoZWQgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LnRyYWNlLmZpbmlzaGVkKTtcblxuICAgIC8vIGlmIHRoZSBuZXh0IHN0ZXAncyBzb3VyY2UgcmFuZ2UgaXMgc3RpbGwgdGhlIHNhbWUsIGtlZXAgZ29pbmdcbiAgfSB3aGlsZSAoXG4gICAgIWZpbmlzaGVkICYmXG4gICAgKCF1cGNvbWluZyB8fFxuICAgICAgIXVwY29taW5nLm5vZGUgfHxcbiAgICAgIGlzRGVsaWJlcmF0ZWx5U2tpcHBlZE5vZGVUeXBlKHVwY29taW5nLm5vZGUpIHx8XG4gICAgICAodXBjb21pbmcuc291cmNlUmFuZ2Uuc3RhcnQgPT0gc3RhcnRpbmdSYW5nZS5zdGFydCAmJlxuICAgICAgICB1cGNvbWluZy5zb3VyY2VSYW5nZS5sZW5ndGggPT0gc3RhcnRpbmdSYW5nZS5sZW5ndGgpKVxuICApO1xufVxuXG4vKipcbiAqIHN0ZXBJbnRvIC0gc3RlcCBpbnRvIHRoZSBjdXJyZW50IGZ1bmN0aW9uXG4gKlxuICogQ29uY2VwdHVhbGx5IHRoaXMgaXMgZWFzeSwgYnV0IGZyb20gYSBwcm9ncmFtbWluZyBzdGFuZHBvaW50IGl0J3MgaGFyZC5cbiAqIENvZGUgbGlrZSBgZ2V0QmFsYW5jZShtc2cuc2VuZGVyKWAgbWlnaHQgYmUgaGlnaGxpZ2h0ZWQsIGJ1dCB0aGVyZSBjb3VsZFxuICogYmUgYSBudW1iZXIgb2YgZGlmZmVyZW50IGludGVybWVkaWF0ZSBzdGVwcyAobGlrZSBldmFsdWF0aW5nIGBtc2cuc2VuZGVyYClcbiAqIGJlZm9yZSBgZ2V0QmFsYW5jZWAgaXMgc3RlcHBlZCBpbnRvLiBUaGlzIGZ1bmN0aW9uIHdpbGwgc3RlcCBpbnRvIHRoZSBmaXJzdFxuICogZnVuY3Rpb24gYXZhaWxhYmxlICh3aGVyZSBpbnN0cnVjdGlvbi5qdW1wID09IFwiaVwiKSwgaWdub3JpbmcgYW55IGludGVybWVkaWF0ZVxuICogc3RlcHMgdGhhdCBmYWxsIHdpdGhpbiB0aGUgc2FtZSBjb2RlIHJhbmdlLiBJZiB0aGVyZSdzIGEgc3RlcCBlbmNvdW50ZXJlZFxuICogdGhhdCBleGlzdHMgb3V0c2lkZSBvZiB0aGUgcmFuZ2UsIHRoZW4gc3RlcEludG8gd2lsbCBvbmx5IGV4ZWN1dGUgdW50aWwgdGhhdFxuICogc3RlcC5cbiAqL1xuZnVuY3Rpb24qIHN0ZXBJbnRvKCkge1xuICBpZiAoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC53aWxsSnVtcCkpIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5pc011bHRpbGluZSkpIHtcbiAgICB5aWVsZCogc3RlcE92ZXIoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB2YXIgY3VycmVudERlcHRoO1xuICB2YXIgY3VycmVudFJhbmdlO1xuICB2YXIgZmluaXNoZWQ7XG5cbiAgZG8ge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgY3VycmVudERlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgICBjdXJyZW50UmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcbiAgICBmaW5pc2hlZCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQudHJhY2UuZmluaXNoZWQpO1xuICB9IHdoaWxlIChcbiAgICAvL3dlIGFyZW4ndCBmaW5pc2hlZCxcbiAgICAhZmluaXNoZWQgJiZcbiAgICAvLyB0aGUgZnVuY3Rpb24gc3RhY2sgaGFzIG5vdCBpbmNyZWFzZWQsXG4gICAgY3VycmVudERlcHRoIDw9IHN0YXJ0aW5nRGVwdGggJiZcbiAgICAvLyB0aGUgY3VycmVudCBzb3VyY2UgcmFuZ2UgYmVnaW5zIG9uIG9yIGFmdGVyIHRoZSBzdGFydGluZyByYW5nZSxcbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnQgPj0gc3RhcnRpbmdSYW5nZS5zdGFydCAmJlxuICAgIC8vIGFuZCB0aGUgY3VycmVudCByYW5nZSBlbmRzIG9uIG9yIGJlZm9yZSB0aGUgc3RhcnRpbmcgcmFuZ2UgZW5kc1xuICAgIGN1cnJlbnRSYW5nZS5zdGFydCArIGN1cnJlbnRSYW5nZS5sZW5ndGggPD1cbiAgICAgIHN0YXJ0aW5nUmFuZ2Uuc3RhcnQgKyBzdGFydGluZ1JhbmdlLmxlbmd0aFxuICApO1xufVxuXG4vKipcbiAqIFN0ZXAgb3V0IG9mIHRoZSBjdXJyZW50IGZ1bmN0aW9uXG4gKlxuICogVGhpcyB3aWxsIHJ1biB1bnRpbCB0aGUgZGVidWdnZXIgZW5jb3VudGVycyBhIGRlY3JlYXNlIGluIGZ1bmN0aW9uIGRlcHRoXG4gKiAob3IgZmluaXNoZXMpXG4gKi9cbmZ1bmN0aW9uKiBzdGVwT3V0KCkge1xuICBpZiAoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5pc011bHRpbGluZSkpIHtcbiAgICB5aWVsZCogc3RlcE92ZXIoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgdmFyIGN1cnJlbnREZXB0aDtcbiAgdmFyIGZpbmlzaGVkO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gICAgZmluaXNoZWQgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LnRyYWNlLmZpbmlzaGVkKTtcbiAgfSB3aGlsZSAoIWZpbmlzaGVkICYmIGN1cnJlbnREZXB0aCA+PSBzdGFydGluZ0RlcHRoKTtcbn1cblxuLyoqXG4gKiBzdGVwT3ZlciAtIHN0ZXAgb3ZlciB0aGUgY3VycmVudCBsaW5lXG4gKlxuICogU3RlcCBvdmVyIHRoZSBjdXJyZW50IGxpbmUuIFRoaXMgd2lsbCBzdGVwIHRvIHRoZSBuZXh0IGluc3RydWN0aW9uIHRoYXRcbiAqIGV4aXN0cyBvbiBhIGRpZmZlcmVudCBsaW5lIG9mIGNvZGUgd2l0aGluIHRoZSBzYW1lIGZ1bmN0aW9uIGRlcHRoLlxuICovXG5mdW5jdGlvbiogc3RlcE92ZXIoKSB7XG4gIGNvbnN0IHN0YXJ0aW5nRGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICBjb25zdCBzdGFydGluZ1JhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG4gIHZhciBjdXJyZW50RGVwdGg7XG4gIHZhciBjdXJyZW50UmFuZ2U7XG4gIHZhciBmaW5pc2hlZDtcblxuICBkbyB7XG4gICAgeWllbGQqIHN0ZXBOZXh0KCk7XG5cbiAgICBjdXJyZW50RGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICAgIGN1cnJlbnRSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICAgIGZpbmlzaGVkID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC50cmFjZS5maW5pc2hlZCk7XG4gIH0gd2hpbGUgKFxuICAgIC8vIGtlZXAgc3RlcHBpbmcgcHJvdmlkZWQ6XG4gICAgLy9cbiAgICAvLyB3ZSBoYXZlbid0IGZpbmlzaGVkXG4gICAgIWZpbmlzaGVkICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBqdW1wZWQgb3V0XG4gICAgIShjdXJyZW50RGVwdGggPCBzdGFydGluZ0RlcHRoKSAmJlxuICAgIC8vIGVpdGhlcjogZnVuY3Rpb24gZGVwdGggaXMgZ3JlYXRlciB0aGFuIHN0YXJ0aW5nIChpZ25vcmUgZnVuY3Rpb24gY2FsbHMpXG4gICAgLy8gb3IsIGlmIHdlJ3JlIGF0IHRoZSBzYW1lIGRlcHRoLCBrZWVwIHN0ZXBwaW5nIHVudGlsIHdlJ3JlIG9uIGEgbmV3XG4gICAgLy8gbGluZS5cbiAgICAoY3VycmVudERlcHRoID4gc3RhcnRpbmdEZXB0aCB8fFxuICAgICAgY3VycmVudFJhbmdlLmxpbmVzLnN0YXJ0LmxpbmUgPT0gc3RhcnRpbmdSYW5nZS5saW5lcy5zdGFydC5saW5lKVxuICApO1xufVxuXG4vKipcbiAqIGNvbnRpbnVlVW50aWxCcmVha3BvaW50IC0gc3RlcCB0aHJvdWdoIGV4ZWN1dGlvbiB1bnRpbCBhIGJyZWFrcG9pbnRcbiAqL1xuZnVuY3Rpb24qIGNvbnRpbnVlVW50aWxCcmVha3BvaW50KGFjdGlvbikge1xuICAvL2lmIGJyZWFrcG9pbnRzIHdhcyBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIHN0b3JlZCBsaXN0IGZyb20gdGhlIHN0YXRlLlxuICAvL2lmIGl0IHdhcywgb3ZlcnJpZGUgdGhhdCB3aXRoIHRoZSBzcGVjaWZpZWQgbGlzdC5cbiAgLy9ub3RlIHRoYXQgZXhwbGljaXRseSBzcGVjaWZ5aW5nIGFuIGVtcHR5IGxpc3Qgd2lsbCBhZHZhbmNlIHRvIHRoZSBlbmQuXG4gIGxldCBicmVha3BvaW50cyA9XG4gICAgYWN0aW9uICE9PSB1bmRlZmluZWQgJiYgYWN0aW9uLmJyZWFrcG9pbnRzICE9PSB1bmRlZmluZWRcbiAgICAgID8gYWN0aW9uLmJyZWFrcG9pbnRzXG4gICAgICA6IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmJyZWFrcG9pbnRzKTtcblxuICBsZXQgYnJlYWtwb2ludEhpdCA9IGZhbHNlO1xuXG4gIGxldCBjdXJyZW50TG9jYXRpb24gPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcbiAgbGV0IGN1cnJlbnRMaW5lID0gY3VycmVudExvY2F0aW9uLnNvdXJjZVJhbmdlLmxpbmVzLnN0YXJ0LmxpbmU7XG4gIGxldCBjdXJyZW50U291cmNlSWQgPSBjdXJyZW50TG9jYXRpb24uc291cmNlLmlkO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIC8vbm90ZSB0aGVzZSB0d28gaGF2ZSBub3QgYmVlbiB1cGRhdGVkIHlldDsgdGhleSdsbCBiZSB1cGRhdGVkIGFcbiAgICAvL2ZldyBsaW5lcyBkb3duLiAgYnV0IGF0IHRoaXMgcG9pbnQgdGhlc2UgYXJlIHN0aWxsIHRoZSBwcmV2aW91c1xuICAgIC8vdmFsdWVzLlxuICAgIGxldCBwcmV2aW91c0xpbmUgPSBjdXJyZW50TGluZTtcbiAgICBsZXQgcHJldmlvdXNTb3VyY2VJZCA9IGN1cnJlbnRTb3VyY2VJZDtcblxuICAgIGN1cnJlbnRMb2NhdGlvbiA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24pO1xuICAgIGRlYnVnKFwiY3VycmVudExvY2F0aW9uOiAlT1wiLCBjdXJyZW50TG9jYXRpb24pO1xuICAgIGxldCBmaW5pc2hlZCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQudHJhY2UuZmluaXNoZWQpO1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgYnJlYWs7IC8vY2FuIGJyZWFrIGltbWVkaWF0ZWx5IGlmIGZpbmlzaGVkXG4gICAgfVxuXG4gICAgY3VycmVudFNvdXJjZUlkID0gY3VycmVudExvY2F0aW9uLnNvdXJjZS5pZDtcbiAgICBpZiAoY3VycmVudFNvdXJjZUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlOyAvL25ldmVyIHN0b3Agb24gYW4gdW5tYXBwZWQgaW5zdHJ1Y3Rpb25cbiAgICB9XG4gICAgbGV0IGN1cnJlbnROb2RlID0gY3VycmVudExvY2F0aW9uLm5vZGUuaWQ7XG4gICAgY3VycmVudExpbmUgPSBjdXJyZW50TG9jYXRpb24uc291cmNlUmFuZ2UubGluZXMuc3RhcnQubGluZTtcblxuICAgIGJyZWFrcG9pbnRIaXQgPVxuICAgICAgYnJlYWtwb2ludHMuZmlsdGVyKCh7IHNvdXJjZUlkLCBsaW5lLCBub2RlIH0pID0+IHtcbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBzb3VyY2VJZCA9PT0gY3VycmVudFNvdXJjZUlkICYmIG5vZGUgPT09IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vb3RoZXJ3aXNlLCB3ZSBoYXZlIGEgbGluZS1zdHlsZSBicmVha3BvaW50OyB3ZSB3YW50IHRvIHN0b3AgYXQgdGhlXG4gICAgICAgIC8vKmZpcnN0KiBwb2ludCBvbiB0aGUgbGluZVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNvdXJjZUlkID09PSBjdXJyZW50U291cmNlSWQgJiZcbiAgICAgICAgICBsaW5lID09PSBjdXJyZW50TGluZSAmJlxuICAgICAgICAgIChjdXJyZW50U291cmNlSWQgIT09IHByZXZpb3VzU291cmNlSWQgfHwgY3VycmVudExpbmUgIT09IHByZXZpb3VzTGluZSlcbiAgICAgICAgKTtcbiAgICAgIH0pLmxlbmd0aCA+IDA7XG4gIH0gd2hpbGUgKCFicmVha3BvaW50SGl0KTtcbn1cblxuLyoqXG4gKiByZXNldCAtLSByZXNldCB0aGUgc3RhdGUgb2YgdGhlIGRlYnVnZ2VyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogcmVzZXQoKSB7XG4gIHlpZWxkKiBkYXRhLnJlc2V0KCk7XG4gIHlpZWxkKiBldm0ucmVzZXQoKTtcbiAgeWllbGQqIHNvbGlkaXR5LnJlc2V0KCk7XG4gIHlpZWxkKiB0cmFjZS5yZXNldCgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9jb250cm9sbGVyL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNvbGlkaXR5OnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBwdXQsIHRha2VFdmVyeSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5pbXBvcnQgeyBUSUNLIH0gZnJvbSBcImxpYi90cmFjZS9hY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NhZ2FzXCI7XG5cbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiogYWRkU291cmNlKHNvdXJjZSwgc291cmNlUGF0aCwgYXN0LCBjb21waWxlcikge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRTb3VyY2Uoc291cmNlLCBzb3VyY2VQYXRoLCBhc3QsIGNvbXBpbGVyKSk7XG59XG5cbmZ1bmN0aW9uKiB0aWNrU2FnYSgpIHtcbiAgZGVidWcoXCJnb3QgVElDS1wiKTtcblxuICB5aWVsZCogZnVuY3Rpb25EZXB0aFNhZ2EoKTtcbiAgZGVidWcoXCJpbnN0cnVjdGlvbjogJU9cIiwgeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb24pKTtcbiAgeWllbGQqIHRyYWNlLnNpZ25hbFRpY2tTYWdhQ29tcGxldGlvbigpO1xufVxuXG5mdW5jdGlvbiogZnVuY3Rpb25EZXB0aFNhZ2EoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC53aWxsRmFpbCkpIHtcbiAgICAvL3dlIGRvIHRoaXMgY2FzZSBmaXJzdCBzbyB3ZSBjYW4gYmUgc3VyZSB3ZSdyZSBub3QgZmFpbGluZyBpbiBhbnkgb2YgdGhlXG4gICAgLy9vdGhlciBjYXNlcyBiZWxvdyFcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5leHRlcm5hbFJldHVybigpKTtcbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC53aWxsSnVtcCkpIHtcbiAgICBsZXQganVtcERpcmVjdGlvbiA9IHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50Lmp1bXBEaXJlY3Rpb24pO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmp1bXAoanVtcERpcmVjdGlvbikpO1xuICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LndpbGxDYWxsKSkge1xuICAgIGRlYnVnKFwiYWJvdXQgdG8gY2FsbFwiKTtcbiAgICBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQuY2FsbHNQcmVjb21waWxlT3JFeHRlcm5hbCkpIHtcbiAgICAgIC8vY2FsbCB0byBwcmVjb21waWxlIG9yIGV4dGVybmFsbHktb3duZWQgYWNjb3VudDsgZG8gbm90aGluZ1xuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5leHRlcm5hbENhbGwoKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LndpbGxDcmVhdGUpKSB7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZXh0ZXJuYWxDYWxsKCkpO1xuICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LndpbGxSZXR1cm4pKSB7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZXh0ZXJuYWxSZXR1cm4oKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZXNldCgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVzZXQoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgeWllbGQgdGFrZUV2ZXJ5KFRJQ0ssIHRpY2tTYWdhKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInNvbGlkaXR5XCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zb2xpZGl0eS9zYWdhcy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBBRERfU09VUkNFID0gXCJTT0xJRElUWV9BRERfU09VUkNFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkU291cmNlKHNvdXJjZSwgc291cmNlUGF0aCwgYXN0LCBjb21waWxlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9TT1VSQ0UsXG4gICAgc291cmNlLFxuICAgIHNvdXJjZVBhdGgsXG4gICAgYXN0LFxuICAgIGNvbXBpbGVyXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBKVU1QID0gXCJKVU1QXCI7XG5leHBvcnQgZnVuY3Rpb24ganVtcChqdW1wRGlyZWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSlVNUCxcbiAgICBqdW1wRGlyZWN0aW9uXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBFWFRFUk5BTF9DQUxMID0gXCJFWFRFUk5BTF9DQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gZXh0ZXJuYWxDYWxsKCkge1xuICByZXR1cm4geyB0eXBlOiBFWFRFUk5BTF9DQUxMIH07XG59XG5cbmV4cG9ydCBjb25zdCBFWFRFUk5BTF9SRVRVUk4gPSBcIkVYVEVSTkFMX1JFVFVSTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVybmFsUmV0dXJuKCkge1xuICByZXR1cm4geyB0eXBlOiBFWFRFUk5BTF9SRVRVUk4gfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFU0VUID0gXCJTT0xJRElUWV9SRVNFVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KCkge1xuICByZXR1cm4geyB0eXBlOiBSRVNFVCB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zb2xpZGl0eS9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDpzZWxlY3RvcnNcIik7XG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5cbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuXG4vKipcbiAqIGFzdFxuICovXG5jb25zdCBhc3QgPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogYXN0LnZpZXdzXG4gICAqL1xuICB2aWV3czoge1xuICAgIC8qKlxuICAgICAqIGFzdC52aWV3cy5zb3VyY2VzXG4gICAgICovXG4gICAgc291cmNlczogY3JlYXRlTGVhZihbc29saWRpdHkuaW5mby5zb3VyY2VzXSwgc291cmNlcyA9PiBzb3VyY2VzKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3Qvc2VsZWN0b3JzL2luZGV4LmpzIiwidmFyIERlYnVnZ2VyID0gcmVxdWlyZShcIi4vbGliL2RlYnVnZ2VyXCIpLmRlZmF1bHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRGVidWdnZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGVidWdnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlclwiKTtcbmltcG9ydCBleHBlY3QgZnJvbSBcIkB0cnVmZmxlL2V4cGVjdFwiO1xuXG5pbXBvcnQgU2Vzc2lvbiBmcm9tIFwiLi9zZXNzaW9uXCI7XG5cbmltcG9ydCB7IGNyZWF0ZU5lc3RlZFNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGRhdGFTZWxlY3RvciBmcm9tIFwiLi9kYXRhL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGFzdFNlbGVjdG9yIGZyb20gXCIuL2FzdC9zZWxlY3RvcnNcIjtcbmltcG9ydCB0cmFjZVNlbGVjdG9yIGZyb20gXCIuL3RyYWNlL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGV2bVNlbGVjdG9yIGZyb20gXCIuL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eVNlbGVjdG9yIGZyb20gXCIuL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNlc3Npb25TZWxlY3RvciBmcm9tIFwiLi9zZXNzaW9uL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGNvbnRyb2xsZXJTZWxlY3RvciBmcm9tIFwiLi9jb250cm9sbGVyL3NlbGVjdG9yc1wiO1xuXG4vKipcbiAqIEBleGFtcGxlXG4gKiBsZXQgc2Vzc2lvbiA9IERlYnVnZ2VyXG4gKiAgIC5mb3JUeCg8dHhIYXNoPiwge1xuICogICAgIGNvbnRyYWN0czogWzxjb250cmFjdCBvYmo+LCAuLi5dLFxuICogICAgIHByb3ZpZGVyOiA8cHJvdmlkZXIgaW5zdGFuY2U+XG4gKiAgIH0pXG4gKiAgIC5jb25uZWN0KCk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnZ2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2Vzc2lvbn0gc2Vzc2lvbiAtIGRlYnVnZ2VyIHNlc3Npb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBhIERlYnVnZ2VyIGZvciBhIGdpdmVuIHRyYW5zYWN0aW9uIGhhc2guXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eEhhc2ggLSB0cmFuc2FjdGlvbiBoYXNoIHdpdGggbGVhZGluZyBcIjB4XCJcbiAgICogQHBhcmFtIHt7Y29udHJhY3RzOiBBcnJheTxDb250cmFjdD4sIGZpbGVzOiBBcnJheTxTdHJpbmc+LCBwcm92aWRlcjogV2ViM1Byb3ZpZGVyfX0gb3B0aW9ucyAtXG4gICAqIEByZXR1cm4ge0RlYnVnZ2VyfSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZvclR4KHR4SGFzaCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZXhwZWN0Lm9wdGlvbnMob3B0aW9ucywgW1wiY29udHJhY3RzXCIsIFwicHJvdmlkZXJcIl0pO1xuXG4gICAgbGV0IHNlc3Npb24gPSBuZXcgU2Vzc2lvbihcbiAgICAgIG9wdGlvbnMuY29udHJhY3RzLFxuICAgICAgb3B0aW9ucy5maWxlcyxcbiAgICAgIG9wdGlvbnMucHJvdmlkZXIsXG4gICAgICB0eEhhc2hcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHNlc3Npb24ucmVhZHkoKTtcbiAgICAgIGRlYnVnKFwic2Vzc2lvbiByZWFkeVwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhcImVycm9yIG9jY3VycmVkLCB1bmxvYWRlZFwiKTtcbiAgICAgIHNlc3Npb24udW5sb2FkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHNlc3Npb24pO1xuICB9XG5cbiAgLypcbiAgICogSW5zdGFudGlhdGVzIGEgRGVidWdnZXIgZm9yIGEgZ2l2ZW4gcHJvamVjdCAod2l0aCBubyB0cmFuc2FjdGlvbiBsb2FkZWQpXG4gICAqXG4gICAqIEBwYXJhbSB7e2NvbnRyYWN0czogQXJyYXk8Q29udHJhY3Q+LCBmaWxlczogQXJyYXk8U3RyaW5nPiwgcHJvdmlkZXI6IFdlYjNQcm92aWRlcn19IG9wdGlvbnMgLVxuICAgKiBAcmV0dXJuIHtEZWJ1Z2dlcn0gaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmb3JQcm9qZWN0KG9wdGlvbnMgPSB7fSkge1xuICAgIGV4cGVjdC5vcHRpb25zKG9wdGlvbnMsIFtcImNvbnRyYWN0c1wiLCBcInByb3ZpZGVyXCJdKTtcblxuICAgIGxldCBzZXNzaW9uID0gbmV3IFNlc3Npb24oXG4gICAgICBvcHRpb25zLmNvbnRyYWN0cyxcbiAgICAgIG9wdGlvbnMuZmlsZXMsXG4gICAgICBvcHRpb25zLnByb3ZpZGVyXG4gICAgKTtcblxuICAgIGF3YWl0IHNlc3Npb24ucmVhZHkoKTtcblxuICAgIHJldHVybiBuZXcgdGhpcyhzZXNzaW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgaW5zdGFudGlhdGVkIERlYnVnZ2VyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTZXNzaW9ufSBzZXNzaW9uIGluc3RhbmNlXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9zZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydGVkIHNlbGVjdG9yc1xuICAgKlxuICAgKiBTZWUgaW5kaXZpZHVhbCBzZWxlY3RvciBkb2NzIGZvciBmdWxsIGxpc3RpbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogRGVidWdnZXIuc2VsZWN0b3JzLmFzdC5jdXJyZW50LnRyZWVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogRGVidWdnZXIuc2VsZWN0b3JzLnNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogRGVidWdnZXIuc2VsZWN0b3JzLnRyYWNlLnN0ZXBzXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICByZXR1cm4gY3JlYXRlTmVzdGVkU2VsZWN0b3Ioe1xuICAgICAgYXN0OiBhc3RTZWxlY3RvcixcbiAgICAgIGRhdGE6IGRhdGFTZWxlY3RvcixcbiAgICAgIHRyYWNlOiB0cmFjZVNlbGVjdG9yLFxuICAgICAgZXZtOiBldm1TZWxlY3RvcixcbiAgICAgIHNvbGlkaXR5OiBzb2xpZGl0eVNlbGVjdG9yLFxuICAgICAgc2Vzc2lvbjogc2Vzc2lvblNlbGVjdG9yLFxuICAgICAgY29udHJvbGxlcjogY29udHJvbGxlclNlbGVjdG9yXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb250cmFjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRyYWN0TmFtZSBjb250cmFjdCBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIHNvbGlkaXR5IHNvdXJjZSBjb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlUGF0aCBwYXRoIHRvIHNvdXJjZSBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmluYXJ5IDB4LXByZWZpeGVkIGhleCBzdHJpbmcgd2l0aCBjcmVhdGUgYnl0ZWNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2VNYXAgc29saWRpdHkgc291cmNlIG1hcCBmb3IgY3JlYXRlIGJ5dGVjb2RlXG4gKiBAcHJvcGVydHkge09iamVjdH0gYXN0IEFic3RyYWN0IFN5bnRheCBUcmVlIGZyb20gU29saWRpdHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXBsb3llZEJpbmFyeSAweC1wcmVmaXhlZCBjb21waWxlZCBiaW5hcnkgKG9uIGNoYWluKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlcGxveWVkU291cmNlTWFwIHNvbGlkaXR5IHNvdXJjZSBtYXAgZm9yIG9uLWNoYWluIGJ5dGVjb2RlXG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGVidWdnZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAdHJ1ZmZsZS9leHBlY3RcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJAdHJ1ZmZsZS9leHBlY3RcIlxuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb25cIik7XG5cbmltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tIFwibGliL3N0b3JlXCI7XG5cbmltcG9ydCAqIGFzIGNvbnRyb2xsZXIgZnJvbSBcImxpYi9jb250cm9sbGVyL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuaW1wb3J0IGRhdGEgZnJvbSBcImxpYi9kYXRhL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNlc3Npb24gZnJvbSBcImxpYi9zZXNzaW9uL3NlbGVjdG9yc1wiO1xuaW1wb3J0ICogYXMgZGF0YVNhZ2FzIGZyb20gXCJsaWIvZGF0YS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgY29udHJvbGxlclNhZ2FzIGZyb20gXCJsaWIvY29udHJvbGxlci9zYWdhc1wiO1xuaW1wb3J0ICogYXMgc2FnYXMgZnJvbSBcIi4vc2FnYXNcIjtcbmltcG9ydCBjb250cm9sbGVyU2VsZWN0b3IgZnJvbSBcImxpYi9jb250cm9sbGVyL3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQgcm9vdFNhZ2EgZnJvbSBcIi4vc2FnYXNcIjtcbmltcG9ydCByZWR1Y2VyIGZyb20gXCIuL3JlZHVjZXJzXCI7XG5cbi8qKlxuICogRGVidWdnZXIgU2Vzc2lvblxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8Q29udHJhY3Q+fSBjb250cmFjdHMgLSBjb250cmFjdCBkZWZpbml0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IGZpbGVzIC0gYXJyYXkgb2YgZmlsZW5hbWVzIGZvciBzb3VyY2VNYXAgaW5kZXhlc1xuICAgKiBAcGFyYW0ge1dlYjNQcm92aWRlcn0gcHJvdmlkZXIgLSB3ZWIzIHByb3ZpZGVyXG4gICAqIHR4SGFzaCBwYXJhbWV0ZXIgaXMgbm93IG9wdGlvbmFsIVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udHJhY3RzLCBmaWxlcywgcHJvdmlkZXIsIHR4SGFzaCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbGV0IHsgc3RvcmUsIHNhZ2FNaWRkbGV3YXJlIH0gPSBjb25maWd1cmVTdG9yZShyZWR1Y2VyLCByb290U2FnYSk7XG4gICAgdGhpcy5fc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLl9zYWdhTWlkZGxld2FyZSA9IHNhZ2FNaWRkbGV3YXJlO1xuXG4gICAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IFNlc3Npb24ubm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMpO1xuXG4gICAgLy8gcmVjb3JkIGNvbnRyYWN0c1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMucmVjb3JkQ29udHJhY3RzKGNvbnRleHRzLCBzb3VyY2VzKSk7XG5cbiAgICAvL3NldCB1cCB0aGUgcmVhZHkgbGlzdGVuZXJcbiAgICB0aGlzLl9yZWFkeSA9IG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLl9zdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy52aWV3KHNlc3Npb24uc3RhdHVzLnJlYWR5KSkge1xuICAgICAgICAgIGRlYnVnKFwicmVhZHkhXCIpO1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgYWNjZXB0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy52aWV3KHNlc3Npb24uc3RhdHVzLmVycm9yZWQpKSB7XG4gICAgICAgICAgZGVidWcoXCJlcnJvciFcIik7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZWplY3QodGhpcy52aWV3KHNlc3Npb24uc3RhdHVzLmVycm9yKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy9ub3RlIHRoYXQgdHhIYXNoIGlzIG5vdyBvcHRpb25hbFxuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMuc3RhcnQocHJvdmlkZXIsIHR4SGFzaCkpO1xuICB9XG5cbiAgYXN5bmMgcmVhZHkoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZHk7XG4gIH1cblxuICBhc3luYyByZWFkeUFnYWluQWZ0ZXJMb2FkaW5nKHNlc3Npb25BY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgaGFzU3RhcnRlZFdhaXRpbmcgPSBmYWxzZTtcbiAgICAgIGRlYnVnKFwicmVyZWFkeSBsaXN0ZW5lciBzZXQgdXBcIik7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuX3N0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGRlYnVnKFwicmVyZWFkeT9cIik7XG4gICAgICAgIGlmIChoYXNTdGFydGVkV2FpdGluZykge1xuICAgICAgICAgIGlmICh0aGlzLnZpZXcoc2Vzc2lvbi5zdGF0dXMucmVhZHkpKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJlcmVhZHkhXCIpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGFjY2VwdCh0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlldyhzZXNzaW9uLnN0YXR1cy5lcnJvcmVkKSkge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGRlYnVnKFwiZXJyb3IhXCIpO1xuICAgICAgICAgICAgcmVqZWN0KHRoaXMudmlldyhzZXNzaW9uLnN0YXR1cy5lcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy52aWV3KHNlc3Npb24uc3RhdHVzLndhaXRpbmcpKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInN0YXJ0ZWQgd2FpdGluZ1wiKTtcbiAgICAgICAgICAgIGhhc1N0YXJ0ZWRXYWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2goc2Vzc2lvbkFjdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdXAgYXJ0aWZhY3RzIGludG8gXCJjb250ZXh0c1wiIGFuZCBcInNvdXJjZXNcIiwgZGl2aWRpbmcgYXJ0aWZhY3RcbiAgICogZGF0YSBpbnRvIGFwcHJvcHJpYXRlIGJ1Y2tldHMuXG4gICAqXG4gICAqIE11bHRpcGxlIGNvbnRyYWN0cyBjYW4gYmUgZGVmaW5lZCBpbiB0aGUgc2FtZSBzb3VyY2UgZmlsZSwgYnV0IGhhdmVcbiAgICogZGlmZmVyZW50IGJ5dGVjb2Rlcy5cbiAgICpcbiAgICogVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBjb250cmFjdHMgYW5kIGNvbGxlY3RzIGJpbmFyaWVzIHNlcGFyYXRlbHlcbiAgICogZnJvbSBzb3VyY2VzLCB1c2luZyB0aGUgb3B0aW9uYWwgYGZpbGVzYCBhcmd1bWVudCB0byBmb3JjZVxuICAgKiBzb3VyY2Ugb3JkZXJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplKGNvbnRyYWN0cywgZmlsZXMgPSBudWxsKSB7XG4gICAgbGV0IHNvdXJjZXNCeVBhdGggPSB7fTtcbiAgICBsZXQgY29udGV4dHMgPSBbXTtcbiAgICBsZXQgc291cmNlcztcblxuICAgIGZvciAobGV0IGNvbnRyYWN0IG9mIGNvbnRyYWN0cykge1xuICAgICAgbGV0IHtcbiAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICBiaW5hcnksXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgZGVwbG95ZWRCaW5hcnksXG4gICAgICAgIGRlcGxveWVkU291cmNlTWFwLFxuICAgICAgICBzb3VyY2VQYXRoLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGFzdCxcbiAgICAgICAgYWJpLFxuICAgICAgICBjb21waWxlclxuICAgICAgfSA9IGNvbnRyYWN0O1xuXG4gICAgICBsZXQgY29udHJhY3ROb2RlID0gYXN0Lm5vZGVzLmZpbmQoXG4gICAgICAgIG5vZGUgPT5cbiAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiICYmIG5vZGUubmFtZSA9PT0gY29udHJhY3ROYW1lXG4gICAgICApOyAvL2lkZWFsbHkgd2UnZCBob2xkIHRoaXMgb2ZmIHRpbGwgbGF0ZXIsIGJ1dCB0aGF0IHdvdWxkIGJyZWFrIHRoZVxuICAgICAgLy9kaXJlY3Rpb24gb2YgdGhlIGV2bS9zb2xpZGl0eSBkZXBlbmRlbmNlLCBzbyB3ZSBkbyBpdCBub3dcblxuICAgICAgbGV0IGNvbnRyYWN0SWQgPSBjb250cmFjdE5vZGUuaWQ7XG4gICAgICBsZXQgY29udHJhY3RLaW5kID0gY29udHJhY3ROb2RlLmNvbnRyYWN0S2luZDtcblxuICAgICAgZGVidWcoXCJjb250cmFjdE5hbWUgJXNcIiwgY29udHJhY3ROYW1lKTtcbiAgICAgIGRlYnVnKFwic291cmNlTWFwICVvXCIsIHNvdXJjZU1hcCk7XG4gICAgICBkZWJ1ZyhcImNvbXBpbGVyICVvXCIsIGNvbXBpbGVyKTtcbiAgICAgIGRlYnVnKFwiYWJpICVPXCIsIGFiaSk7XG5cbiAgICAgIHNvdXJjZXNCeVBhdGhbc291cmNlUGF0aF0gPSB7IHNvdXJjZVBhdGgsIHNvdXJjZSwgYXN0LCBjb21waWxlciB9O1xuXG4gICAgICBpZiAoYmluYXJ5ICYmIGJpbmFyeSAhPSBcIjB4XCIpIHtcbiAgICAgICAgY29udGV4dHMucHVzaCh7XG4gICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgIGJpbmFyeSxcbiAgICAgICAgICBzb3VyY2VNYXAsXG4gICAgICAgICAgYWJpLFxuICAgICAgICAgIGNvbXBpbGVyLFxuICAgICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgICAgY29udHJhY3RLaW5kLFxuICAgICAgICAgIGlzQ29uc3RydWN0b3I6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXBsb3llZEJpbmFyeSAmJiBkZXBsb3llZEJpbmFyeSAhPSBcIjB4XCIpIHtcbiAgICAgICAgY29udGV4dHMucHVzaCh7XG4gICAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICAgIGJpbmFyeTogZGVwbG95ZWRCaW5hcnksXG4gICAgICAgICAgc291cmNlTWFwOiBkZXBsb3llZFNvdXJjZU1hcCxcbiAgICAgICAgICBhYmksXG4gICAgICAgICAgY29tcGlsZXIsXG4gICAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgICBjb250cmFjdEtpbmQsXG4gICAgICAgICAgaXNDb25zdHJ1Y3RvcjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmaWxlcykge1xuICAgICAgc291cmNlcyA9IE9iamVjdC52YWx1ZXMoc291cmNlc0J5UGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZXMgPSBmaWxlcy5tYXAoZmlsZSA9PiBzb3VyY2VzQnlQYXRoW2ZpbGVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBjb250ZXh0cywgc291cmNlcyB9O1xuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgdmlldyhzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3Rvcih0aGlzLnN0YXRlKTtcbiAgfVxuXG4gIGFzeW5jIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBBbGxvd3MgcnVubmluZyBhbnkgc2FnYSAtLSBmb3IgaW50ZXJuYWwgdXNlIG9ubHkhXG4gICAqIFVzaW5nIHRoaXMgY291bGQgc2VyaW91c2x5IHNjcmV3IHVwIHRoZSBkZWJ1Z2dlciBzdGF0ZSBpZiB5b3VcbiAgICogZG9uJ3Qga25vdyB3aGF0IHlvdSdyZSBkb2luZyFcbiAgICovXG4gIGFzeW5jIF9ydW5TYWdhKHNhZ2EsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2FnYU1pZGRsZXdhcmUucnVuKHNhZ2EsIC4uLmFyZ3MpLnRvUHJvbWlzZSgpO1xuICB9XG5cbiAgYXN5bmMgaW50ZXJydXB0KCkge1xuICAgIGF3YWl0IHRoaXMuZGlzcGF0Y2goYWN0aW9ucy5pbnRlcnJ1cHQoKSk7XG4gICAgYXdhaXQgdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLmludGVycnVwdCgpKTtcbiAgfVxuXG4gIGFzeW5jIGRvbmVTdGVwcGluZyhzdGVwcGVyQWN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IGhhc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5fc3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgY29uc3QgaXNTdGVwcGluZyA9IHRoaXMudmlldyhjb250cm9sbGVyU2VsZWN0b3IuaXNTdGVwcGluZyk7XG5cbiAgICAgICAgaWYgKGlzU3RlcHBpbmcgJiYgIWhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICBoYXNTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBkZWJ1ZyhcImhlYXJkIHN0ZXAgc3RhcnRcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0ZXBwaW5nICYmIGhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICBkZWJ1ZyhcImhlYXJkIHN0ZXAgc3RvcFwiKTtcbiAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5kaXNwYXRjaChzdGVwcGVyQWN0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vcmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGFscmVhZHkgbG9hZGVkLCBlcnJvciBvYmplY3Qgb24gZmFpbHVyZVxuICBhc3luYyBsb2FkKHR4SGFzaCkge1xuICAgIGlmICh0aGlzLnZpZXcoc2Vzc2lvbi5zdGF0dXMubG9hZGVkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVhZHlBZ2FpbkFmdGVyTG9hZGluZyhhY3Rpb25zLmxvYWRUcmFuc2FjdGlvbih0eEhhc2gpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLl9ydW5TYWdhKHNhZ2FzLnVubG9hZCk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gIH1cblxuICAvL3JldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBhbHJlYWR5IHVubG9hZGVkXG4gIGFzeW5jIHVubG9hZCgpIHtcbiAgICBpZiAoIXRoaXMudmlldyhzZXNzaW9uLnN0YXR1cy5sb2FkZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYnVnKFwidW5sb2FkaW5nXCIpO1xuICAgIGF3YWl0IHRoaXMuX3J1blNhZ2Eoc2FnYXMudW5sb2FkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vTm90ZTogY291bnQgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQ7IGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gYWR2YW5jZSAxXG4gIGFzeW5jIGFkdmFuY2UoY291bnQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kb25lU3RlcHBpbmcoY29udHJvbGxlci5hZHZhbmNlKGNvdW50KSk7XG4gIH1cblxuICBhc3luYyBzdGVwTmV4dCgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kb25lU3RlcHBpbmcoY29udHJvbGxlci5zdGVwTmV4dCgpKTtcbiAgfVxuXG4gIGFzeW5jIHN0ZXBPdmVyKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvbmVTdGVwcGluZyhjb250cm9sbGVyLnN0ZXBPdmVyKCkpO1xuICB9XG5cbiAgYXN5bmMgc3RlcEludG8oKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZG9uZVN0ZXBwaW5nKGNvbnRyb2xsZXIuc3RlcEludG8oKSk7XG4gIH1cblxuICBhc3luYyBzdGVwT3V0KCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvbmVTdGVwcGluZyhjb250cm9sbGVyLnN0ZXBPdXQoKSk7XG4gIH1cblxuICBhc3luYyByZXNldCgpIHtcbiAgICBsZXQgbG9hZGVkID0gdGhpcy52aWV3KHNlc3Npb24uc3RhdHVzLmxvYWRlZCk7XG4gICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3J1blNhZ2EoY29udHJvbGxlclNhZ2FzLnJlc2V0KTtcbiAgfVxuXG4gIC8vTk9URTogYnJlYWtwb2ludHMgaXMgYW4gT1BUSU9OQUwgYXJndW1lbnQgZm9yIGlmIHlvdSB3YW50IHRvIHN1cHBseSB5b3VyXG4gIC8vb3duIGxpc3Qgb2YgYnJlYWtwb2ludHM7IGxlYXZlIGl0IG91dCB0byB1c2UgdGhlIGludGVybmFsIG9uZSAoYXNcbiAgLy9jb250cm9sbGVkIGJ5IHRoZSBmdW5jdGlvbnMgYmVsb3cpXG4gIGFzeW5jIGNvbnRpbnVlVW50aWxCcmVha3BvaW50KGJyZWFrcG9pbnRzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZG9uZVN0ZXBwaW5nKFxuICAgICAgY29udHJvbGxlci5jb250aW51ZVVudGlsQnJlYWtwb2ludChicmVha3BvaW50cylcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgYWRkQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5hZGRCcmVha3BvaW50KGJyZWFrcG9pbnQpKTtcbiAgfVxuXG4gIGFzeW5jIHJlbW92ZUJyZWFrcG9pbnQoYnJlYWtwb2ludCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIucmVtb3ZlQnJlYWtwb2ludChicmVha3BvaW50KSk7XG4gIH1cblxuICBhc3luYyByZW1vdmVBbGxCcmVha3BvaW50cygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnJlbW92ZUFsbEJyZWFrcG9pbnRzKCkpO1xuICB9XG5cbiAgLy9kZXByZWNhdGVkIC0tIGRlY29kZSBpcyBub3cgKmFsd2F5cyogcmVhZHkhXG4gIGFzeW5jIGRlY29kZVJlYWR5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgYXN5bmMgdmFyaWFibGUobmFtZSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25zID0gdGhpcy52aWV3KGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9ucyk7XG4gICAgY29uc3QgcmVmcyA9IHRoaXMudmlldyhkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMucmVmcyk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcnVuU2FnYShkYXRhU2FnYXMuZGVjb2RlLCBkZWZpbml0aW9uc1tuYW1lXSwgcmVmc1tuYW1lXSk7XG4gIH1cblxuICBhc3luYyB2YXJpYWJsZXMoKSB7XG4gICAgaWYgKCF0aGlzLnZpZXcoc2Vzc2lvbi5zdGF0dXMubG9hZGVkKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgZGVmaW5pdGlvbnMgPSB0aGlzLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLmRlZmluaXRpb25zKTtcbiAgICBsZXQgcmVmcyA9IHRoaXMudmlldyhkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMucmVmcyk7XG4gICAgbGV0IGRlY29kZWQgPSB7fTtcbiAgICBmb3IgKGxldCBbaWRlbnRpZmllciwgcmVmXSBvZiBPYmplY3QuZW50cmllcyhyZWZzKSkge1xuICAgICAgaWYgKGlkZW50aWZpZXIgaW4gZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgZGVjb2RlZFtpZGVudGlmaWVyXSA9IGF3YWl0IHRoaXMuX3J1blNhZ2EoXG4gICAgICAgICAgZGF0YVNhZ2FzLmRlY29kZSxcbiAgICAgICAgICBkZWZpbml0aW9uc1tpZGVudGlmaWVyXSxcbiAgICAgICAgICByZWZcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIlxuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3Byb2R1Y3Rpb25cIik7XG59IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3Rlc3RcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2RldmVsb3BtZW50XCIpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zdG9yZS9pbmRleC5qcyIsImltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tIFwiLi9jb21tb25cIjtcbmV4cG9ydCBkZWZhdWx0IGNvbmZpZ3VyZVN0b3JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zdG9yZS9wcm9kdWN0aW9uLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnN0b3JlOmNvbW1vblwiKTtcbmNvbnN0IHJlZHV4RGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnJlZHV4XCIpO1xuXG5pbXBvcnQgeyBjb21wb3NlLCBjcmVhdGVTdG9yZSwgYXBwbHlNaWRkbGV3YXJlIH0gZnJvbSBcInJlZHV4XCI7XG5pbXBvcnQgY3JlYXRlU2FnYU1pZGRsZXdhcmUgZnJvbSBcInJlZHV4LXNhZ2FcIjtcbmltcG9ydCBjcmVhdGVMb2dnZXIgZnJvbSBcInJlZHV4LWNsaS1sb2dnZXJcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFiYnJldmlhdGVWYWx1ZXModmFsdWUsIG9wdGlvbnMgPSB7fSwgZGVwdGggPSAwKSB7XG4gIG9wdGlvbnMuc3RyaW5nTGltaXQgPSBvcHRpb25zLnN0cmluZ0xpbWl0IHx8IDY2O1xuICBvcHRpb25zLmFycmF5TGltaXQgPSBvcHRpb25zLmFycmF5TGltaXQgfHwgODtcbiAgb3B0aW9ucy5yZWN1cnNlTGltaXQgPSBvcHRpb25zLnJlY3Vyc2VMaW1pdCB8fCA0O1xuXG4gIGlmIChkZXB0aCA+IG9wdGlvbnMucmVjdXJzZUxpbWl0KSB7XG4gICAgcmV0dXJuIFwiLi4uXCI7XG4gIH1cblxuICBjb25zdCByZWN1cnNlID0gY2hpbGQgPT4gYWJicmV2aWF0ZVZhbHVlcyhjaGlsZCwgb3B0aW9ucywgZGVwdGggKyAxKTtcblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBvcHRpb25zLmFycmF5TGltaXQpIHtcbiAgICAgIHZhbHVlID0gW1xuICAgICAgICAuLi52YWx1ZS5zbGljZSgwLCBvcHRpb25zLmFycmF5TGltaXQgLyAyKSxcbiAgICAgICAgXCIuLi5cIixcbiAgICAgICAgLi4udmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gb3B0aW9ucy5hcnJheUxpbWl0IC8gMiArIDEpXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5tYXAocmVjdXJzZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgLi4uT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiAoeyBbcmVjdXJzZShrKV06IHJlY3Vyc2UodikgfSkpXG4gICAgKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoID4gb3B0aW9ucy5zdHJpbmdMaW1pdCkge1xuICAgIGxldCBpbm5lciA9IFwiLi4uXCI7XG4gICAgbGV0IGV4dHJhY3RBbW91bnQgPSAob3B0aW9ucy5zdHJpbmdMaW1pdCAtIGlubmVyLmxlbmd0aCkgLyAyO1xuICAgIGxldCBsZWFkaW5nID0gdmFsdWUuc2xpY2UoMCwgTWF0aC5jZWlsKGV4dHJhY3RBbW91bnQpKTtcbiAgICBsZXQgdHJhaWxpbmcgPSB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBNYXRoLmZsb29yKGV4dHJhY3RBbW91bnQpKTtcbiAgICByZXR1cm4gYCR7bGVhZGluZ30ke2lubmVyfSR7dHJhaWxpbmd9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uZmlndXJlU3RvcmUoXG4gIHJlZHVjZXIsXG4gIHNhZ2EsXG4gIGluaXRpYWxTdGF0ZSxcbiAgY29tcG9zZUVuaGFuY2Vyc1xuKSB7XG4gIGNvbnN0IHNhZ2FNaWRkbGV3YXJlID0gY3JlYXRlU2FnYU1pZGRsZXdhcmUoKTtcblxuICBpZiAoIWNvbXBvc2VFbmhhbmNlcnMpIHtcbiAgICBjb21wb3NlRW5oYW5jZXJzID0gY29tcG9zZTtcbiAgfVxuXG4gIGNvbnN0IGxvZ2dlck1pZGRsZXdhcmUgPSBjcmVhdGVMb2dnZXIoe1xuICAgIGxvZzogcmVkdXhEZWJ1ZyxcbiAgICBzdGF0ZVRyYW5zZm9ybWVyOiBzdGF0ZSA9PlxuICAgICAgYWJicmV2aWF0ZVZhbHVlcyhzdGF0ZSwge1xuICAgICAgICBhcnJheUxpbWl0OiA0LFxuICAgICAgICByZWN1cnNlTGltaXQ6IDNcbiAgICAgIH0pLFxuICAgIGFjdGlvblRyYW5zZm9ybWVyOiBhYmJyZXZpYXRlVmFsdWVzXG4gIH0pO1xuXG4gIGxldCBzdG9yZSA9IGNyZWF0ZVN0b3JlKFxuICAgIHJlZHVjZXIsXG4gICAgaW5pdGlhbFN0YXRlLFxuXG4gICAgY29tcG9zZUVuaGFuY2VycyhhcHBseU1pZGRsZXdhcmUoc2FnYU1pZGRsZXdhcmUsIGxvZ2dlck1pZGRsZXdhcmUpKVxuICApO1xuXG4gIHNhZ2FNaWRkbGV3YXJlLnJ1bihzYWdhKTtcblxuICByZXR1cm4geyBzdG9yZSwgc2FnYU1pZGRsZXdhcmUgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc3RvcmUvY29tbW9uLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtc2FnYVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlZHV4LXNhZ2FcIlxuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtY2xpLWxvZ2dlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlZHV4LWNsaS1sb2dnZXJcIlxuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGpzb24gPSB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgPyBKU09OIDogcmVxdWlyZSgnanNvbmlmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBzcGFjZSA9IG9wdHMuc3BhY2UgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHNwYWNlID0gQXJyYXkoc3BhY2UrMSkuam9pbignICcpO1xuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcbiAgICB2YXIgcmVwbGFjZXIgPSBvcHRzLnJlcGxhY2VyIHx8IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XG4gICAgICAgICAgICAgICAgdmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkob3B0cy5jbXApO1xuXG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeSAocGFyZW50LCBrZXksIG5vZGUsIGxldmVsKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSBzcGFjZSA/ICgnXFxuJyArIG5ldyBBcnJheShsZXZlbCArIDEpLmpvaW4oc3BhY2UpKSA6ICcnO1xuICAgICAgICB2YXIgY29sb25TZXBhcmF0b3IgPSBzcGFjZSA/ICc6ICcgOiAnOic7XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSByZXBsYWNlci5jYWxsKHBhcmVudCwga2V5LCBub2RlKTtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbi5zdHJpbmdpZnkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RyaW5naWZ5KG5vZGUsIGksIG5vZGVbaV0sIGxldmVsKzEpIHx8IGpzb24uc3RyaW5naWZ5KG51bGwpO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICddJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIGpzb24uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHNlZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKG5vZGUpLnNvcnQoY21wICYmIGNtcChub2RlKSk7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZSwga2V5LCBub2RlW2tleV0sIGxldmVsKzEpO1xuXG4gICAgICAgICAgICAgICAgaWYoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGpzb24uc3RyaW5naWZ5KGtleSlcbiAgICAgICAgICAgICAgICAgICAgKyBjb2xvblNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICArIHZhbHVlO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGtleVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uc3BsaWNlKHNlZW4uaW5kZXhPZihub2RlKSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICd9JztcbiAgICAgICAgfVxuICAgIH0pKHsgJyc6IG9iaiB9LCAnJywgb2JqLCAwKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2NydXptb2xpbmEvQ29kZS90cnVmZmxlLXByb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlJyk7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vbGliL3N0cmluZ2lmeScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2NydXptb2xpbmEvQ29kZS90cnVmZmxlLXByb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBlc2NhcGVlID0ge1xuICAgICAgICAnXCInOiAgJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogICcvJyxcbiAgICAgICAgYjogICAgJ1xcYicsXG4gICAgICAgIGY6ICAgICdcXGYnLFxuICAgICAgICBuOiAgICAnXFxuJyxcbiAgICAgICAgcjogICAgJ1xccicsXG4gICAgICAgIHQ6ICAgICdcXHQnXG4gICAgfSxcbiAgICB0ZXh0LFxuXG4gICAgZXJyb3IgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAvLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBuYW1lOiAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogbSxcbiAgICAgICAgICAgIGF0OiAgICAgIGF0LFxuICAgICAgICAgICAgdGV4dDogICAgdGV4dFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgXG4gICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBjICsgXCInIGluc3RlYWQgb2YgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgIFxuICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgZXJyb3IoXCJCYWQgbnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICBcbiAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIHN0cmluZ1wiKTtcbiAgICB9LFxuXG4gICAgd2hpdGUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgd2hpdGVzcGFjZS5cblxuICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG5cbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfSxcblxuICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG5cbiAgICBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG5cbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7ICAgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgYXJyYXlcIik7XG4gICAgfSxcblxuICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIG9iamVjdFwiKTtcbiAgICB9O1xuXG52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZywgYSBudW1iZXIsXG4vLyBvciBhIHdvcmQuXG5cbiAgICB3aGl0ZSgpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgIGNhc2UgJ1snOlxuICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICBjYXNlICdcIic6XG4gICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICBjYXNlICctJzpcbiAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgfVxufTtcblxuLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGUgYWJvdmVcbi8vIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIFxuICAgIHRleHQgPSBzb3VyY2U7XG4gICAgYXQgPSAwO1xuICAgIGNoID0gJyAnO1xuICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgd2hpdGUoKTtcbiAgICBpZiAoY2gpIHtcbiAgICAgICAgZXJyb3IoXCJTeW50YXggZXJyb3JcIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgcmVzdWx0XG4gICAgLy8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuICAgIC8vIHJlc3VsdC5cblxuICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IChmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG4gICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH0oeycnOiByZXN1bHR9LCAnJykpIDogcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9jcnV6bW9saW5hL0NvZGUvdHJ1ZmZsZS1wcm9qZWN0cy90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBnYXAsXG4gICAgaW5kZW50LFxuICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICB9LFxuICAgIHJlcDtcblxuZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG4gICAgLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuICAgIC8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4gICAgLy8gc2VxdWVuY2VzLlxuICAgIFxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG4gICAgLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBtaW5kID0gZ2FwLFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgIFxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuICAgIC8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB3cmFwIHRoZW0gaW4gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlXG4gICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfScgOlxuICAgICAgICAgICAgJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHZhciBpO1xuICAgIGdhcCA9ICcnO1xuICAgIGluZGVudCA9ICcnO1xuICAgIFxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbiAgICAvLyBtYW55IHNwYWNlcy5cbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG4gICAgZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4gICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXAgPSByZXBsYWNlcjtcbiAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nXG4gICAgJiYgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvY3J1em1vbGluYS9Db2RlL3RydWZmbGUtcHJvamVjdHMvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJAdHJ1ZmZsZS9zb2xpZGl0eS11dGlsc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIkB0cnVmZmxlL3NvbGlkaXR5LXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkB0cnVmZmxlL2NvZGUtdXRpbHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJAdHJ1ZmZsZS9jb2RlLXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyBBbiBhdWdtZW50ZWQgQVZMIFRyZWUgd2hlcmUgZWFjaCBub2RlIG1haW50YWlucyBhIGxpc3Qgb2YgcmVjb3JkcyBhbmQgdGhlaXIgc2VhcmNoIGludGVydmFscy5cclxuLy8gUmVjb3JkIGlzIGNvbXBvc2VkIG9mIGFuIGludGVydmFsIGFuZCBpdHMgdW5kZXJseWluZyBkYXRhLCBzZW50IGJ5IGEgY2xpZW50LiBUaGlzIGFsbG93cyB0aGVcclxuLy8gaW50ZXJ2YWwgdHJlZSB0byBoYXZlIHRoZSBzYW1lIGludGVydmFsIGluc2VydGVkIG11bHRpcGxlIHRpbWVzLCBhcyBsb25nIGl0cyBkYXRhIGlzIGRpZmZlcmVudC5cclxuLy8gQm90aCBpbnNlcnRpb24gYW5kIGRlbGV0aW9uIHJlcXVpcmUgTyhsb2cgbikgdGltZS4gU2VhcmNoaW5nIHJlcXVpcmVzIE8oaypsb2duKSB0aW1lLCB3aGVyZSBga2BcclxuLy8gaXMgdGhlIG51bWJlciBvZiBpbnRlcnZhbHMgaW4gdGhlIG91dHB1dCBsaXN0LlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBpc1NhbWUgPSByZXF1aXJlKFwic2hhbGxvd2VxdWFsXCIpO1xyXG5mdW5jdGlvbiBoZWlnaHQobm9kZSkge1xyXG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBub2RlLmhlaWdodDtcclxuICAgIH1cclxufVxyXG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGUoaW50ZXJ2YWxUcmVlLCByZWNvcmQpIHtcclxuICAgICAgICB0aGlzLmludGVydmFsVHJlZSA9IGludGVydmFsVHJlZTtcclxuICAgICAgICB0aGlzLnJlY29yZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5rZXkgPSByZWNvcmQubG93O1xyXG4gICAgICAgIHRoaXMubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgYXJyYXkgb2YgYWxsIHJlY29yZHMgd2l0aCB0aGUgc2FtZSBrZXkgZm9yIHRoaXMgbm9kZVxyXG4gICAgICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XHJcbiAgICB9XHJcbiAgICAvLyBHZXRzIHRoZSBoaWdoZXN0IHJlY29yZC5oaWdoIHZhbHVlIGZvciB0aGlzIG5vZGVcclxuICAgIE5vZGUucHJvdG90eXBlLmdldE5vZGVIaWdoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5yZWNvcmRzWzBdLmhpZ2g7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVjb3Jkc1tpXS5oaWdoID4gaGlnaCkge1xyXG4gICAgICAgICAgICAgICAgaGlnaCA9IHRoaXMucmVjb3Jkc1tpXS5oaWdoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoaWdoO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgaGVpZ2h0IHZhbHVlIG9mIHRoZSBub2RlLiBDYWxsZWQgZHVyaW5nIGluc2VydGlvbiwgcmViYWxhbmNlLCByZW1vdmFsXHJcbiAgICBOb2RlLnByb3RvdHlwZS51cGRhdGVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heChoZWlnaHQodGhpcy5sZWZ0KSwgaGVpZ2h0KHRoaXMucmlnaHQpKSArIDE7XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyB0aGUgbWF4IHZhbHVlIG9mIGFsbCB0aGUgcGFyZW50cyBhZnRlciBpbnNlcnRpbmcgaW50byBhbHJlYWR5IGV4aXN0aW5nIG5vZGUsIGFzIHdlbGwgYXNcclxuICAgIC8vIHJlbW92aW5nIHRoZSBub2RlIGNvbXBsZXRlbHkgb3IgcmVtb3ZpbmcgdGhlIHJlY29yZCBvZiBhbiBhbHJlYWR5IGV4aXN0aW5nIG5vZGUuIFN0YXJ0cyB3aXRoXHJcbiAgICAvLyB0aGUgcGFyZW50IG9mIGFuIGFmZmVjdGVkIG5vZGUgYW5kIGJ1YmJsZXMgdXAgdG8gcm9vdFxyXG4gICAgTm9kZS5wcm90b3R5cGUudXBkYXRlTWF4T2ZQYXJlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMucmlnaHQubWF4LCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBMZWZ0LUxlZnQgY2FzZTpcclxuICBcclxuICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICAgICAgeSAgIFQ0ICAgICAgUmlnaHQgUm90YXRlICh6KSAgICAgICAgICB4ICAgICB6XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgICAgLyBcXCAgIC8gXFxcclxuICAgICAgIHggICBUMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgLyBcXFxyXG4gICAgVDEgICBUMlxyXG4gIFxyXG4gICAgTGVmdC1SaWdodCBjYXNlOlxyXG4gIFxyXG4gICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgICAgeSAgIFQ0ICBMZWZ0IFJvdGF0ZSAoeSkgICAgICAgICB4ICBUNCAgUmlnaHQgUm90YXRlKHopICAgICB5ICAgICB6XHJcbiAgICAgIC8gXFwgICAgICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgIC8gXFwgICAgICAtIC0gLSAtIC0gLSAtIC0+ICAvIFxcICAgLyBcXFxyXG4gICAgVDEgICB4ICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAgVDMgICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFxcclxuICAgICAgVDIgICBUMyAgICAgICAgICAgICAgICAgICAgICBUMSBUMlxyXG4gICAgKi9cclxuICAgIC8vIEhhbmRsZXMgTGVmdC1MZWZ0IGNhc2UgYW5kIExlZnQtUmlnaHQgY2FzZSBhZnRlciByZWJhbGFuY2luZyBBVkwgdHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3VwZGF0ZU1heEFmdGVyUmlnaHRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciBsZWZ0ID0gcGFyZW50LmxlZnQ7XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBsZWZ0IHNpYmxpbmcgKHggaW4gZmlyc3QgY2FzZSwgeSBpbiBzZWNvbmQpXHJcbiAgICAgICAgdmFyIHRoaXNQYXJlbnRMZWZ0SGlnaCA9IGxlZnQuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAobGVmdC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgbGVmdC5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudExlZnRIaWdoLCBsZWZ0LnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlZnQubGVmdCAhPT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRMZWZ0SGlnaCwgbGVmdC5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlZnQubGVmdCA9PT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IHRoaXNQYXJlbnRMZWZ0SGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgobGVmdC5sZWZ0Lm1heCwgbGVmdC5yaWdodC5tYXgpLCB0aGlzUGFyZW50TGVmdEhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGl0c2VsZiAoeilcclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHBhcmVudCAoeSBpbiBmaXJzdCBjYXNlLCB4IGluIHNlY29uZClcclxuICAgICAgICBwYXJlbnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocGFyZW50LmxlZnQubWF4LCBwYXJlbnQucmlnaHQubWF4KSwgcGFyZW50LmdldE5vZGVIaWdoKCkpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBSaWdodC1SaWdodCBjYXNlOlxyXG4gIFxyXG4gICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlcclxuICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgVDEgIHkgICAgIExlZnQgUm90YXRlKHopICAgICAgIHogICAgIHhcclxuICAgICAgIC8gXFwgICAtIC0gLSAtIC0gLSAtIC0+ICAgICAvIFxcICAgLyBcXFxyXG4gICAgICBUMiAgeCAgICAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAgICAvIFxcXHJcbiAgICAgICAgVDMgVDRcclxuICBcclxuICAgIFJpZ2h0LUxlZnQgY2FzZTpcclxuICBcclxuICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgVDEgIHkgICBSaWdodCBSb3RhdGUgKHkpICAgICBUMSAgeCAgICAgIExlZnQgUm90YXRlKHopICAgeiAgICAgeVxyXG4gICAgICAgIC8gXFwgIC0gLSAtIC0gLSAtIC0gLSAtPiAgICAgIC8gXFwgICAtIC0gLSAtIC0gLSAtIC0+ICAvIFxcICAgLyBcXFxyXG4gICAgICAgeCAgVDQgICAgICAgICAgICAgICAgICAgICAgICBUMiAgeSAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXFxyXG4gICAgVDIgICBUMyAgICAgICAgICAgICAgICAgICAgICAgICAgIFQzIFQ0XHJcbiAgICAqL1xyXG4gICAgLy8gSGFuZGxlcyBSaWdodC1SaWdodCBjYXNlIGFuZCBSaWdodC1MZWZ0IGNhc2UgaW4gcmViYWxhbmNpbmcgQVZMIHRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciByaWdodCA9IHBhcmVudC5yaWdodDtcclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHJpZ2h0IHNpYmxpbmcgKHggaW4gZmlyc3QgY2FzZSwgeSBpbiBzZWNvbmQpXHJcbiAgICAgICAgdmFyIHRoaXNQYXJlbnRSaWdodEhpZ2ggPSByaWdodC5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmIChyaWdodC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50UmlnaHRIaWdoLCByaWdodC5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodC5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50UmlnaHRIaWdoLCByaWdodC5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IHRoaXNQYXJlbnRSaWdodEhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heChNYXRoLm1heChyaWdodC5sZWZ0Lm1heCwgcmlnaHQucmlnaHQubWF4KSwgdGhpc1BhcmVudFJpZ2h0SGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgaXRzZWxmICh6KVxyXG4gICAgICAgIHZhciB0aGlzSGlnaCA9IHRoaXMuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpcy5yaWdodC5tYXgpLCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgcGFyZW50ICh5IGluIGZpcnN0IGNhc2UsIHggaW4gc2Vjb25kKVxyXG4gICAgICAgIHBhcmVudC5tYXggPSBNYXRoLm1heChNYXRoLm1heChwYXJlbnQubGVmdC5tYXgsIHJpZ2h0Lm1heCksIHBhcmVudC5nZXROb2RlSGlnaCgpKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fbGVmdFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmlnaHRDaGlsZCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocmlnaHRDaGlsZC5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsVHJlZS5yb290ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodENoaWxkLnBhcmVudC5sZWZ0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodENoaWxkLnBhcmVudC5sZWZ0ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyaWdodENoaWxkLnBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQucmlnaHQgPSByaWdodENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodENoaWxkLmxlZnQ7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJpZ2h0Q2hpbGQubGVmdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSByaWdodENoaWxkO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgcmlnaHRDaGlsZC51cGRhdGVIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fcmlnaHRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnRDaGlsZCA9IHRoaXMubGVmdDtcclxuICAgICAgICBsZWZ0Q2hpbGQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKGxlZnRDaGlsZC5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsVHJlZS5yb290ID0gbGVmdENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxlZnRDaGlsZC5wYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgbGVmdENoaWxkLnBhcmVudC5sZWZ0ID0gbGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRDaGlsZC5wYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRDaGlsZC5wYXJlbnQucmlnaHQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdENoaWxkLnJpZ2h0O1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVmdENoaWxkLnJpZ2h0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIGxlZnRDaGlsZC51cGRhdGVIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBSZWJhbGFuY2VzIHRoZSB0cmVlIGlmIHRoZSBoZWlnaHQgdmFsdWUgYmV0d2VlbiB0d28gbm9kZXMgb2YgdGhlIHNhbWUgcGFyZW50IGlzIGdyZWF0ZXIgdGhhblxyXG4gICAgLy8gdHdvLiBUaGVyZSBhcmUgNCBjYXNlcyB0aGF0IGNhbiBoYXBwZW4gd2hpY2ggYXJlIG91dGxpbmVkIGluIHRoZSBncmFwaGljcyBhYm92ZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3JlYmFsYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoaGVpZ2h0KHRoaXMubGVmdCkgPj0gMiArIGhlaWdodCh0aGlzLnJpZ2h0KSkge1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMubGVmdDtcclxuICAgICAgICAgICAgaWYgKGhlaWdodChsZWZ0LmxlZnQpID49IGhlaWdodChsZWZ0LnJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdC1MZWZ0IGNhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0LVJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIGxlZnQuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGVpZ2h0KHRoaXMucmlnaHQpID49IDIgKyBoZWlnaHQodGhpcy5sZWZ0KSkge1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0KHJpZ2h0LnJpZ2h0KSA+PSBoZWlnaHQocmlnaHQubGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0LVJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQtTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICByaWdodC5fcmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAocmVjb3JkLmxvdyA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIGxlZnQgc3VidHJlZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IG5ldyBOb2RlKHRoaXMuaW50ZXJ2YWxUcmVlLCByZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHJpZ2h0IHN1YnRyZWVcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCA9IG5ldyBOb2RlKHRoaXMuaW50ZXJ2YWxUcmVlLCByZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5pbnNlcnQocmVjb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1heCB2YWx1ZSBvZiB0aGlzIGFuY2VzdG9yIGlmIG5lZWRlZFxyXG4gICAgICAgIGlmICh0aGlzLm1heCA8IHJlY29yZC5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBoZWlnaHQgb2YgZWFjaCBub2RlXHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAvLyBSZWJhbGFuY2UgdGhlIHRyZWUgdG8gZW5zdXJlIGFsbCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZCBpbiBPKGxvZ24pIHRpbWUuIFRoaXMgaXMgZXNwZWNpYWxseVxyXG4gICAgICAgIC8vIGltcG9ydGFudCBpbiBzZWFyY2hpbmcsIGFzIHRoZSB0cmVlIGhhcyBhIGhpZ2ggY2hhbmNlIG9mIGRlZ2VuZXJhdGluZyB3aXRob3V0IHRoZSByZWJhbGFuY2luZ1xyXG4gICAgICAgIHRoaXMuX3JlYmFsYW5jZSgpO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLl9nZXRPdmVybGFwcGluZ1JlY29yZHMgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUsIGxvdywgaGlnaCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5rZXkgPD0gaGlnaCAmJiBsb3cgPD0gY3VycmVudE5vZGUuZ2V0Tm9kZUhpZ2goKSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlcyBhcmUgb3ZlcmxhcHBpbmcsIGNoZWNrIGlmIGluZGl2aWR1YWwgcmVjb3JkcyBpbiB0aGUgbm9kZSBhcmUgb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgdmFyIHRlbXBSZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudE5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJlY29yZHNbaV0uaGlnaCA+PSBsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wUmVzdWx0cy5wdXNoKGN1cnJlbnROb2RlLnJlY29yZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wUmVzdWx0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICAvLyBEb24ndCBzZWFyY2ggbm9kZXMgdGhhdCBkb24ndCBleGlzdFxyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVmdFNlYXJjaCA9IFtdO1xyXG4gICAgICAgIHZhciBvd25TZWFyY2ggPSBbXTtcclxuICAgICAgICB2YXIgcmlnaHRTZWFyY2ggPSBbXTtcclxuICAgICAgICAvLyBJZiBpbnRlcnZhbCBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCBwb2ludCBvZiBhbnkgaW50ZXJ2YWwgaW4gdGhpcyBub2RlIGFuZCBhbGwgaXRzXHJcbiAgICAgICAgLy8gY2hpbGRyZW4sIHRoZXJlIHdvbid0IGJlIGFueSBtYXRjaGVzXHJcbiAgICAgICAgaWYgKGxvdyA+IHRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VhcmNoIGxlZnQgY2hpbGRyZW5cclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sZWZ0Lm1heCA+PSBsb3cpIHtcclxuICAgICAgICAgICAgbGVmdFNlYXJjaCA9IHRoaXMubGVmdC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhpcyBub2RlXHJcbiAgICAgICAgb3duU2VhcmNoID0gdGhpcy5fZ2V0T3ZlcmxhcHBpbmdSZWNvcmRzKHRoaXMsIGxvdywgaGlnaCk7XHJcbiAgICAgICAgLy8gSWYgaW50ZXJ2YWwgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIHN0YXJ0IG9mIHRoaXMgaW50ZXJ2YWwsIHRoZW4gaXQgY2FuJ3QgYmUgaW4gYW55IGNoaWxkIHRvXHJcbiAgICAgICAgLy8gdGhlIHJpZ2h0XHJcbiAgICAgICAgaWYgKGhpZ2ggPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFNlYXJjaC5jb25jYXQob3duU2VhcmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZWFyY2ggcmlnaHQgY2hpbGRyZW5cclxuICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0U2VhcmNoID0gdGhpcy5yaWdodC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV0dXJuIGFjY3VtdWxhdGVkIHJlc3VsdHMsIGlmIGFueVxyXG4gICAgICAgIHJldHVybiBsZWZ0U2VhcmNoLmNvbmNhdChvd25TZWFyY2gsIHJpZ2h0U2VhcmNoKTtcclxuICAgIH07XHJcbiAgICAvLyBTZWFyY2hlcyBmb3IgYSBub2RlIGJ5IGEgYGtleWAgdmFsdWVcclxuICAgIE5vZGUucHJvdG90eXBlLnNlYXJjaEV4aXN0aW5nID0gZnVuY3Rpb24gKGxvdykge1xyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMua2V5ID09PSBsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxvdyA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5zZWFyY2hFeGlzdGluZyhsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5zZWFyY2hFeGlzdGluZyhsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyB0aGUgc21hbGxlc3Qgbm9kZSBvZiB0aGUgc3VidHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX21pblZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuX21pblZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChub2RlLmtleSA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBvbiB0aGUgbGVmdCBzaWRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUua2V5ID4gdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZSB0byBiZSByZW1vdmVkIGlzIG9uIHRoZSByaWdodCBzaWRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgaGFzIHR3byBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgdmFyIG1pblZhbHVlID0gdGhpcy5yaWdodC5fbWluVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5ID0gbWluVmFsdWUua2V5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzID0gbWluVmFsdWUucmVjb3JkcztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy8gT25lIGNoaWxkIG9yIG5vIGNoaWxkIGNhc2Ugb24gbGVmdCBzaWRlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9yZWJhbGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy8gT25lIGNoaWxkIG9yIG5vIGNoaWxkIGNhc2Ugb24gcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9yZWJhbGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOb2RlO1xyXG59KCkpO1xyXG5leHBvcnRzLk5vZGUgPSBOb2RlO1xyXG52YXIgSW50ZXJ2YWxUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW50ZXJ2YWxUcmVlKCkge1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgfVxyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHJlY29yZC5sb3cgPiByZWNvcmQuaGlnaCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bsb3dgIHZhbHVlIG11c3QgYmUgbG93ZXIgb3IgZXF1YWwgdG8gYGhpZ2hgIHZhbHVlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBCYXNlIGNhc2U6IFRyZWUgaXMgZW1wdHksIG5ldyBub2RlIGJlY29tZXMgcm9vdFxyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTm9kZSh0aGlzLCByZWNvcmQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBpZiBub2RlIGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUga2V5XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5yb290LnNlYXJjaEV4aXN0aW5nKHJlY29yZC5sb3cpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmVjb3JkcyBpbiB0aGlzIG5vZGUgaWYgdGhlcmUgYWxyZWFkeSBpcyB0aGUgb25lIHdpdGggc2FtZSBsb3csIGhpZ2gsIGRhdGFcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbaV0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByZWNvcmQgaXMgc2FtZSBhcyB0aGUgb25lIHdlJ3JlIHRyeWluZyB0byBpbnNlcnQ7IHJldHVybiBmYWxzZSB0byBpbmRpY2F0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIGhhcyBiZWVuIGluc2VydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHJlY29yZCB0byB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgICAgbm9kZS5yZWNvcmRzLnB1c2gocmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgdGhlIG5vZGUgYW5kIGl0cyBwYXJlbnRzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5oaWdoID4gbm9kZS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBkb2Vzbid0IGFscmVhZHkgZXhpc3QuIENhbGwgaW5zZXJ0IGZ1bmN0aW9uIG9uIHJvb3QncyBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVHJlZSBpcyBlbXB0eTsgcmV0dXJuIGVtcHR5IGFycmF5XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBUcmVlIGlzIGVtcHR5OyBub3RoaW5nIHRvIHJlbW92ZVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdC5zZWFyY2hFeGlzdGluZyhyZWNvcmQubG93KTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUucmVjb3Jkcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZFJlY29yZCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBoYXMgMiBvciBtb3JlIHJlY29yZHMuIEZpbmQgdGhlIG9uZSB3ZSBuZWVkIGFuZCByZW1vdmUgaXRcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbaV0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFJlY29yZCA9IG5vZGUucmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWNvcmRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRSZWNvcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkUmVjb3JkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgdGhhdCBub2RlIGFuZCBpdHMgcGFyZW50cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmhpZ2ggPT09IG5vZGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSGlnaCA9IG5vZGUuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdCAhPT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChNYXRoLm1heChub2RlLmxlZnQubWF4LCBub2RlLnJpZ2h0Lm1heCksIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgobm9kZS5sZWZ0Lm1heCwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubGVmdCA9PT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChub2RlLnJpZ2h0Lm1heCwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBub2RlSGlnaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnJlY29yZHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgaGFzIG9ubHkgMSByZWNvcmQuIENoZWNrIGlmIHRoZSByZW1haW5pbmcgcmVjb3JkIGluIHRoaXMgbm9kZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbMF0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIHJlY29yZCBpcyB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlLiBSZW1vdmUgdGhlIHdob2xlIG5vZGUgZnJvbSB0aGUgdHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb3Qua2V5ID09PSBub2RlLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSByZW1vdmluZyB0aGUgcm9vdCBlbGVtZW50LiBDcmVhdGUgYSBkdW1teSBub2RlIHRoYXQgd2lsbCB0ZW1wb3JhcmlseSB0YWtlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvb3QncyBwYXJlbnQgcm9sZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdFBhcmVudCA9IG5ldyBOb2RlKHRoaXMsIHsgbG93OiByZWNvcmQubG93LCBoaWdoOiByZWNvcmQubG93IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290UGFyZW50LmxlZnQgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSByb290UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZE5vZGUgPSB0aGlzLnJvb3QucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByb290UGFyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWROb2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkTm9kZSA9IHRoaXMucm9vdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgcmVjb3JkIGlzIG5vdCB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gcmVjb3JkcyBhdCBhbGwgaW4gdGhpcyBub2RlPyEgU2hvdWxkbid0IGhhcHBlblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuaW5PcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluT3JkZXIodGhpcy5yb290KTtcclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnByZU9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlT3JkZXIodGhpcy5yb290KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW50ZXJ2YWxUcmVlO1xyXG59KCkpO1xyXG5leHBvcnRzLkludGVydmFsVHJlZSA9IEludGVydmFsVHJlZTtcclxudmFyIERhdGFJbnRlcnZhbFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhSW50ZXJ2YWxUcmVlKCkge1xyXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBJbnRlcnZhbFRyZWUoKTtcclxuICAgIH1cclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmluc2VydCh7IGxvdzogbG93LCBoaWdoOiBoaWdoLCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnJlbW92ZSh7IGxvdzogbG93LCBoaWdoOiBoaWdoLCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnNlYXJjaChsb3csIGhpZ2gpLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5kYXRhOyB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbk9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuaW5PcmRlcigpO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnByZU9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUucHJlT3JkZXIoKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUsIFwiY291bnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlLmNvdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIERhdGFJbnRlcnZhbFRyZWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFJbnRlcnZhbFRyZWU7XHJcbnZhciBJbk9yZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5PcmRlcihzdGFydE5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaChzdGFydE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEluT3JkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gV2lsbCBvbmx5IGhhcHBlbiBpZiBzdGFjayBpcyBlbXB0eSBhbmQgcG9wIGlzIGNhbGxlZFxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm9jZXNzIHRoaXMgbm9kZVxyXG4gICAgICAgIGlmICh0aGlzLmkgPCB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHNbdGhpcy5pKytdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE1pZ2h0IHBvcCB0aGUgbGFzdCBhbmQgc2V0IHRoaXMuY3VycmVudE5vZGUgPSB1bmRlZmluZWRcclxuICAgICAgICAgICAgdGhpcy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xyXG4gICAgfTtcclxuICAgIEluT3JkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VycmVudE5vZGUubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuY3VycmVudE5vZGUubGVmdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluT3JkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSW5PcmRlciA9IEluT3JkZXI7XHJcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxufVxyXG52YXIgUHJlT3JkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcmVPcmRlcihzdGFydE5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgfVxyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gV2lsbCBvbmx5IGhhcHBlbiBpZiBzdGFjayBpcyBlbXB0eSBhbmQgcG9wIGlzIGNhbGxlZCxcclxuICAgICAgICAvLyB3aGljaCBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gcmlnaHQgbm9kZSAoaS5lIHdlIGFyZSBkb25lKVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm9jZXNzIHRoaXMgbm9kZVxyXG4gICAgICAgIGlmICh0aGlzLmkgPCB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHNbdGhpcy5pKytdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLmxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcclxuICAgIH07XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgfTtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlT3JkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUHJlT3JkZXIgPSBQcmVPcmRlcjtcclxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvY3J1em1vbGluYS9Db2RlL3RydWZmbGUtcHJvamVjdHMvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvbm9kZS1pbnRlcnZhbC10cmVlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQiwgY29tcGFyZSwgY29tcGFyZUNvbnRleHQpIHtcbiAgdmFyIHJldCA9IGNvbXBhcmUgPyBjb21wYXJlLmNhbGwoY29tcGFyZUNvbnRleHQsIG9iakEsIG9iakIpIDogdm9pZCAwO1xuXG4gIGlmIChyZXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiAhIXJldDtcbiAgfVxuXG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgIW9iakEgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgIW9iakIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGJIYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuYmluZChvYmpCKTtcblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBrZXlzQS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNBW2lkeF07XG5cbiAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlQSA9IG9iakFba2V5XTtcbiAgICB2YXIgdmFsdWVCID0gb2JqQltrZXldO1xuXG4gICAgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgdmFsdWVBLCB2YWx1ZUIsIGtleSkgOiB2b2lkIDA7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSB8fCAocmV0ID09PSB2b2lkIDAgJiYgdmFsdWVBICE9PSB2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2NydXptb2xpbmEvQ29kZS90cnVmZmxlLXByb2plY3RzL3RydWZmbGUvbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNvbnN0IElOSVRfV0VCMyA9IFwiSU5JVF9XRUIzXCI7XG5leHBvcnQgZnVuY3Rpb24gaW5pdChwcm92aWRlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IElOSVRfV0VCMyxcbiAgICBwcm92aWRlclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgSU5TUEVDVCA9IFwiSU5TUEVDVF9UUkFOU0FDVElPTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3BlY3QodHhIYXNoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5TUEVDVCxcbiAgICB0eEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEZFVENIX0JJTkFSWSA9IFwiRkVUQ0hfQklOQVJZXCI7XG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hCaW5hcnkoYWRkcmVzcywgYmxvY2spIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBGRVRDSF9CSU5BUlksXG4gICAgYWRkcmVzcyxcbiAgICBibG9jayAvL29wdGlvbmFsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX0JJTkFSWSA9IFwiUkVDRUlWRV9CSU5BUllcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ0VJVkVfQklOQVJZLFxuICAgIGFkZHJlc3MsXG4gICAgYmluYXJ5XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX1RSQUNFID0gXCJSRUNFSVZFX1RSQUNFXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZVRyYWNlKHRyYWNlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9UUkFDRSxcbiAgICB0cmFjZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDRUlWRV9DQUxMID0gXCJSRUNFSVZFX0NBTExcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNlaXZlQ2FsbCh7XG4gIGFkZHJlc3MsXG4gIGJpbmFyeSxcbiAgZGF0YSxcbiAgc3RvcmFnZUFkZHJlc3MsXG4gIHN0YXR1cyxcbiAgc2VuZGVyLFxuICB2YWx1ZSxcbiAgZ2FzcHJpY2UsXG4gIGJsb2NrXG59KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9DQUxMLFxuICAgIGFkZHJlc3MsXG4gICAgYmluYXJ5LFxuICAgIGRhdGEsXG4gICAgc3RvcmFnZUFkZHJlc3MsXG4gICAgc3RhdHVzLCAvL29ubHkgdXNlZCBmb3IgY3JlYXRpb24gY2FsbHMgYXQgcHJlc2VudCFcbiAgICBzZW5kZXIsXG4gICAgdmFsdWUsXG4gICAgZ2FzcHJpY2UsXG4gICAgYmxvY2tcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVSUk9SX1dFQjMgPSBcIkVSUk9SX1dFQjNcIjtcbmV4cG9ydCBmdW5jdGlvbiBlcnJvcihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEVSUk9SX1dFQjMsXG4gICAgZXJyb3JcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvd2ViMy9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOndlYjM6YWRhcHRlclwiKTtcblxuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjtcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gXCJ1dGlsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYjNBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICB0aGlzLndlYjMgPSBuZXcgV2ViMyhwcm92aWRlcik7XG4gIH1cblxuICBhc3luYyBnZXRUcmFjZSh0eEhhc2gpIHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcHJvbWlzaWZ5KHRoaXMud2ViMy5jdXJyZW50UHJvdmlkZXIuc2VuZCkoXG4gICAgICAvL3NlbmQgKm9ubHkqIHVzZXMgY2FsbGJhY2tzLCBzbyB3ZSB1c2UgcHJvbXNpZml5IHRvIG1ha2UgdGhpbmdzIG1vcmVcbiAgICAgIC8vcmVhZGFibGVcbiAgICAgIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kOiBcImRlYnVnX3RyYWNlVHJhbnNhY3Rpb25cIixcbiAgICAgICAgcGFyYW1zOiBbdHhIYXNoLCB7fV0sXG4gICAgICAgIGlkOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQuc3RydWN0TG9ncztcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy53ZWIzLmV0aC5nZXRUcmFuc2FjdGlvbih0eEhhc2gpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UmVjZWlwdCh0eEhhc2gpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy53ZWIzLmV0aC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgfVxuXG4gIGFzeW5jIGdldEJsb2NrKGJsb2NrTnVtYmVyT3JIYXNoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMud2ViMy5ldGguZ2V0QmxvY2soYmxvY2tOdW1iZXJPckhhc2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldERlcGxveWVkQ29kZSAtIGdldCB0aGUgZGVwbG95ZWQgY29kZSBmb3IgYW4gYWRkcmVzcyBmcm9tIHRoZSBjbGllbnRcbiAgICogTk9URTogdGhlIGJsb2NrIGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYWRkcmVzc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgZGVwbG95ZWRCaW5hcnlcbiAgICovXG4gIGFzeW5jIGdldERlcGxveWVkQ29kZShhZGRyZXNzLCBibG9jaykge1xuICAgIGRlYnVnKFwiZ2V0dGluZyBkZXBsb3llZCBjb2RlIGZvciAlc1wiLCBhZGRyZXNzKTtcbiAgICBsZXQgY29kZSA9IGF3YWl0IHRoaXMud2ViMy5ldGguZ2V0Q29kZShhZGRyZXNzLCBibG9jayk7XG4gICAgcmV0dXJuIGNvZGUgPT09IFwiMHgwXCIgPyBcIjB4XCIgOiBjb2RlO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvYWRhcHRlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1dGlsXCJcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImxvZGFzaC5zdW1cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJsb2Rhc2guc3VtXCJcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzZXNzaW9uOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBjYWxsLCBhbGwsIGZvcmssIHRha2UsIHB1dCwgcmFjZSB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcblxuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhc3QgZnJvbSBcImxpYi9hc3Qvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGNvbnRyb2xsZXIgZnJvbSBcImxpYi9jb250cm9sbGVyL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBldm0gZnJvbSBcImxpYi9ldm0vc2FnYXNcIjtcbmltcG9ydCAqIGFzIHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyB3ZWIzIGZyb20gXCJsaWIvd2ViMy9zYWdhc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmNvbnN0IExPQURfU0FHQVMgPSB7XG4gIFthY3Rpb25zLkxPQURfVFJBTlNBQ1RJT05dOiBsb2FkXG4gIC8vd2lsbCBhbHNvIGFkZCByZWNvbnN0cnVjdCBhY3Rpb24vc2FnYSBvbmNlIGl0IGV4aXN0c1xufTtcblxuZnVuY3Rpb24qIGxpc3RlbmVyU2FnYSgpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgYWN0aW9uID0geWllbGQgdGFrZShPYmplY3Qua2V5cyhMT0FEX1NBR0FTKSk7XG4gICAgbGV0IHNhZ2EgPSBMT0FEX1NBR0FTW2FjdGlvbi50eXBlXTtcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLndhaXQoKSk7XG4gICAgeWllbGQgcmFjZSh7XG4gICAgICBleGVjOiBjYWxsKHNhZ2EsIGFjdGlvbiksIC8vbm90IGFsbCB3aWxsIHVzZSB0aGlzXG4gICAgICBpbnRlcnJ1cHQ6IHRha2UoYWN0aW9ucy5JTlRFUlJVUFQpXG4gICAgfSk7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMucmVhZHkoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICBkZWJ1ZyhcInN0YXJ0aW5nIGxpc3RlbmVyc1wiKTtcbiAgeWllbGQqIGZvcmtMaXN0ZW5lcnMoKTtcblxuICAvLyByZWNlaXZpbmcgJiBzYXZpbmcgY29udHJhY3RzIGludG8gc3RhdGVcbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cmFjdCBpbmZvcm1hdGlvblwiKTtcbiAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5SRUNPUkRfQ09OVFJBQ1RTKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBiaW5hcmllc1wiKTtcbiAgeWllbGQqIHJlY29yZENvbnRleHRzKC4uLmNvbnRleHRzKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBzb3VyY2VzXCIpO1xuICB5aWVsZCogcmVjb3JkU291cmNlcyguLi5zb3VyY2VzKTtcblxuICBkZWJ1ZyhcIm5vcm1hbGl6aW5nIGNvbnRleHRzXCIpO1xuICB5aWVsZCogZXZtLm5vcm1hbGl6ZUNvbnRleHRzKCk7XG5cbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBzdGFydFwiKTtcbiAgLy8gd2FpdCBmb3Igc3RhcnQgc2lnbmFsXG4gIGxldCB7IHR4SGFzaCwgcHJvdmlkZXIgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5TVEFSVCk7XG4gIGRlYnVnKFwic3RhcnRpbmdcIik7XG5cbiAgZGVidWcoXCJ2aXNpdGluZyBBU1RzXCIpO1xuICAvLyB2aXNpdCBhc3RzXG4gIHlpZWxkKiBhc3QudmlzaXRBbGwoKTtcblxuICAvL3NhdmUgYWxsb2NhdGlvbiB0YWJsZVxuICBkZWJ1ZyhcInNhdmluZyBhbGxvY2F0aW9uIHRhYmxlXCIpO1xuICB5aWVsZCogZGF0YS5yZWNvcmRBbGxvY2F0aW9ucygpO1xuXG4gIC8vaW5pdGlhbGl6ZSB3ZWIzIGFkYXB0ZXJcbiAgeWllbGQqIHdlYjMuaW5pdChwcm92aWRlcik7XG5cbiAgLy9wcm9jZXNzIHRyYW5zYWN0aW9uIChpZiB0aGVyZSBpcyBvbmUpXG4gIC8vKG5vdGU6IHRoaXMgcGFydCBtYXkgYWxzbyBzZXQgdGhlIGVycm9yIHN0YXRlKVxuICBpZiAodHhIYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICB5aWVsZCogcHJvY2Vzc1RyYW5zYWN0aW9uKHR4SGFzaCk7XG4gIH1cblxuICBkZWJ1ZyhcInJlYWR5aW5nXCIpO1xuICAvLyBzaWduYWwgdGhhdCBjb21tYW5kcyBjYW4gYmVnaW5cbiAgeWllbGQqIHJlYWR5KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcHJvY2Vzc1RyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAvLyBwcm9jZXNzIHRyYW5zYWN0aW9uXG4gIGRlYnVnKFwiZmV0Y2hpbmcgdHJhbnNhY3Rpb24gaW5mb1wiKTtcbiAgbGV0IGVyciA9IHlpZWxkKiBmZXRjaFR4KHR4SGFzaCk7XG4gIGlmIChlcnIpIHtcbiAgICBkZWJ1ZyhcImVycm9yICVvXCIsIGVycik7XG4gICAgeWllbGQqIGVycm9yKGVycik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInNlc3Npb25cIiwgc2FnYSk7XG5cbmZ1bmN0aW9uKiBmb3JrTGlzdGVuZXJzKCkge1xuICB5aWVsZCBmb3JrKGxpc3RlbmVyU2FnYSk7IC8vc2Vzc2lvbiBsaXN0ZW5lcjsgdGhpcyBvbmUgaXMgc2VwYXJhdGUsIHNvcnJ5XG4gIC8vKEkgZGlkbid0IHdhbnQgdG8gbWVzcyB3LyB0aGUgZXhpc3Rpbmcgc3RydWN0dXJlIG9mIGRlZmF1bHRzKVxuICByZXR1cm4geWllbGQgYWxsKFxuICAgIFtjb250cm9sbGVyLCBkYXRhLCBldm0sIHNvbGlkaXR5LCB0cmFjZSwgd2ViM10ubWFwKFxuICAgICAgYXBwID0+IGZvcmsoYXBwLnNhZ2EpXG4gICAgICAvL2FzdCBubyBsb25nZXIgaGFzIGEgbGlzdGVuZXJcbiAgICApXG4gICk7XG59XG5cbmZ1bmN0aW9uKiBmZXRjaFR4KHR4SGFzaCkge1xuICBsZXQgcmVzdWx0ID0geWllbGQqIHdlYjMuaW5zcGVjdFRyYW5zYWN0aW9uKHR4SGFzaCk7XG4gIGRlYnVnKFwicmVzdWx0ICVvXCIsIHJlc3VsdCk7XG5cbiAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgIHJldHVybiByZXN1bHQuZXJyb3I7XG4gIH1cblxuICAvL2dldCBhZGRyZXNzZXMgY3JlYXRlZC9jYWxsZWQgZHVyaW5nIHRyYW5zYWN0aW9uXG4gIGRlYnVnKFwicHJvY2Vzc2luZyB0cmFjZSBmb3IgYWRkcmVzc2VzXCIpO1xuICBsZXQgYWRkcmVzc2VzID0geWllbGQqIHRyYWNlLnByb2Nlc3NUcmFjZShyZXN1bHQudHJhY2UpO1xuICAvL2FkZCBpbiB0aGUgYWRkcmVzcyBvZiB0aGUgY2FsbCBpdHNlbGYgKGlmIGEgY2FsbClcbiAgaWYgKHJlc3VsdC5hZGRyZXNzICYmICFhZGRyZXNzZXMuaW5jbHVkZXMocmVzdWx0LmFkZHJlc3MpKSB7XG4gICAgYWRkcmVzc2VzLnB1c2gocmVzdWx0LmFkZHJlc3MpO1xuICB9XG4gIC8vaWYgYSBjcmVhdGUsIG9ubHkgYWRkIGluIGFkZHJlc3MgaWYgaXQgd2FzIHN1Y2Nlc3NmdWxcbiAgaWYgKFxuICAgIHJlc3VsdC5iaW5hcnkgJiZcbiAgICByZXN1bHQuc3RhdHVzICYmXG4gICAgIWFkZHJlc3Nlcy5pbmNsdWRlcyhyZXN1bHQuc3RvcmFnZUFkZHJlc3MpXG4gICkge1xuICAgIGFkZHJlc3Nlcy5wdXNoKHJlc3VsdC5zdG9yYWdlQWRkcmVzcyk7XG4gIH1cblxuICBsZXQgYmxvY2tOdW1iZXIgPSByZXN1bHQuYmxvY2subnVtYmVyLnRvU3RyaW5nKCk7IC8vYSBCTiBpcyBub3QgYWNjZXB0ZWRcbiAgZGVidWcoXCJvYnRhaW5pbmcgYmluYXJpZXNcIik7XG4gIGxldCBiaW5hcmllcyA9IHlpZWxkKiB3ZWIzLm9idGFpbkJpbmFyaWVzKGFkZHJlc3NlcywgYmxvY2tOdW1iZXIpO1xuXG4gIGRlYnVnKFwicmVjb3JkaW5nIGluc3RhbmNlc1wiKTtcbiAgeWllbGQgYWxsKFxuICAgIGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MsIGkpID0+IGNhbGwocmVjb3JkSW5zdGFuY2UsIGFkZHJlc3MsIGJpbmFyaWVzW2ldKSlcbiAgKTtcblxuICBkZWJ1ZyhcInNlbmRpbmcgaW5pdGlhbCBjYWxsXCIpO1xuICB5aWVsZCogZXZtLmJlZ2luKHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRDb250ZXh0cyguLi5jb250ZXh0cykge1xuICBmb3IgKGxldCBjb250ZXh0IG9mIGNvbnRleHRzKSB7XG4gICAgeWllbGQqIGV2bS5hZGRDb250ZXh0KGNvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRTb3VyY2VzKC4uLnNvdXJjZXMpIHtcbiAgZm9yIChsZXQgc291cmNlRGF0YSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKHNvdXJjZURhdGEgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2VEYXRhICE9PSBudWxsKSB7XG4gICAgICB5aWVsZCogc29saWRpdHkuYWRkU291cmNlKFxuICAgICAgICBzb3VyY2VEYXRhLnNvdXJjZSxcbiAgICAgICAgc291cmNlRGF0YS5zb3VyY2VQYXRoLFxuICAgICAgICBzb3VyY2VEYXRhLmFzdCxcbiAgICAgICAgc291cmNlRGF0YS5jb21waWxlclxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24qIHJlY29yZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSkge1xuICB5aWVsZCogZXZtLmFkZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSk7XG59XG5cbmZ1bmN0aW9uKiByZWFkeSgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVhZHkoKSk7XG59XG5cbmZ1bmN0aW9uKiBlcnJvcihlcnIpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuZXJyb3IoZXJyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogdW5sb2FkKCkge1xuICBkZWJ1ZyhcInVubG9hZGluZ1wiKTtcbiAgeWllbGQqIGRhdGEucmVzZXQoKTtcbiAgeWllbGQqIHNvbGlkaXR5LnJlc2V0KCk7XG4gIHlpZWxkKiBldm0udW5sb2FkKCk7XG4gIHlpZWxkKiB0cmFjZS51bmxvYWQoKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMudW5sb2FkVHJhbnNhY3Rpb24oKSk7XG59XG5cbi8vbm90ZSB0aGF0IGxvYWQgdGFrZXMgYW4gYWN0aW9uIGFzIGl0cyBhcmd1bWVudCwgd2hpY2ggaXMgd2h5IGl0J3Mgc2VwYXJhdGVcbi8vZnJvbSBwcm9jZXNzVHJhbnNhY3Rpb25cbmZ1bmN0aW9uKiBsb2FkKHsgdHhIYXNoIH0pIHtcbiAgeWllbGQqIHByb2Nlc3NUcmFuc2FjdGlvbih0eEhhc2gpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDpzYWdhc1wiKTtcblxuaW1wb3J0IHsgYWxsLCBjYWxsLCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5cbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5cbmltcG9ydCBhc3QgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5mdW5jdGlvbiogd2Fsayhzb3VyY2VJZCwgbm9kZSwgcG9pbnRlciA9IFwiXCIsIHBhcmVudElkID0gbnVsbCkge1xuICBkZWJ1ZyhcIndhbGtpbmcgJW8gJW9cIiwgcG9pbnRlciwgbm9kZSk7XG5cbiAgeWllbGQqIGhhbmRsZUVudGVyKHNvdXJjZUlkLCBub2RlLCBwb2ludGVyLCBwYXJlbnRJZCk7XG5cbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAobGV0IFtpLCBjaGlsZF0gb2Ygbm9kZS5lbnRyaWVzKCkpIHtcbiAgICAgIHlpZWxkIGNhbGwod2Fsaywgc291cmNlSWQsIGNoaWxkLCBgJHtwb2ludGVyfS8ke2l9YCwgcGFyZW50SWQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgZm9yIChsZXQgW2tleSwgY2hpbGRdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICB5aWVsZCBjYWxsKHdhbGssIHNvdXJjZUlkLCBjaGlsZCwgYCR7cG9pbnRlcn0vJHtrZXl9YCwgbm9kZS5pZCk7XG4gICAgfVxuICB9XG5cbiAgeWllbGQqIGhhbmRsZUV4aXQoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIpO1xufVxuXG5mdW5jdGlvbiogaGFuZGxlRW50ZXIoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIsIHBhcmVudElkKSB7XG4gIGlmICghKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVidWcoXCJlbnRlcmluZyAlc1wiLCBwb2ludGVyKTtcblxuICBpZiAobm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoXCIlcyByZWNvcmRpbmcgc2NvcGUgJXNcIiwgcG9pbnRlciwgbm9kZS5pZCk7XG4gICAgeWllbGQqIGRhdGEuc2NvcGUobm9kZS5pZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKTtcbiAgfVxuXG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICBkZWJ1ZyhcIiVzIHJlY29yZGluZyB2YXJpYWJsZSAlb1wiLCBwb2ludGVyLCBub2RlKTtcbiAgICAgIHlpZWxkKiBkYXRhLmRlY2xhcmUobm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiQ29udHJhY3REZWZpbml0aW9uXCI6XG4gICAgY2FzZSBcIlN0cnVjdERlZmluaXRpb25cIjpcbiAgICBjYXNlIFwiRW51bURlZmluaXRpb25cIjpcbiAgICAgIHlpZWxkKiBkYXRhLmRlZmluZVR5cGUobm9kZSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiogaGFuZGxlRXhpdChzb3VyY2VJZCwgbm9kZSwgcG9pbnRlcikge1xuICBkZWJ1ZyhcImV4aXRpbmcgJXNcIiwgcG9pbnRlcik7XG5cbiAgLy8gbm8tb3AgcmlnaHQgbm93XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogdmlzaXRBbGwoKSB7XG4gIGxldCBzb3VyY2VzID0geWllbGQgc2VsZWN0KGFzdC52aWV3cy5zb3VyY2VzKTtcblxuICB5aWVsZCBhbGwoXG4gICAgT2JqZWN0LmVudHJpZXMoc291cmNlcylcbiAgICAgIC5maWx0ZXIoKFtfLCBzb3VyY2VdKSA9PiBzb3VyY2UuYXN0KVxuICAgICAgLm1hcCgoW2lkLCB7IGFzdCB9XSkgPT4gY2FsbCh3YWxrLCBpZCwgYXN0KSlcbiAgKTtcblxuICBkZWJ1ZyhcImRvbmUgdmlzaXRpbmdcIik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzZXNzaW9uOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0IGRhdGEgZnJvbSBcImxpYi9kYXRhL3JlZHVjZXJzXCI7XG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3JlZHVjZXJzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9yZWR1Y2Vyc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2UvcmVkdWNlcnNcIjtcbmltcG9ydCBjb250cm9sbGVyIGZyb20gXCJsaWIvY29udHJvbGxlci9yZWR1Y2Vyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZnVuY3Rpb24gcmVhZHkoc3RhdGUgPSBmYWxzZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuUkVBRFk6XG4gICAgICBkZWJ1ZyhcInJlYWR5aW5nXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGFjdGlvbnMuV0FJVDpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvamVjdEluZm9Db21wdXRlZChzdGF0ZSA9IGZhbHNlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5QUk9KRUNUX0lORk9fQ09NUFVURUQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhc3RMb2FkaW5nRXJyb3Ioc3RhdGUgPSBudWxsLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5FUlJPUjpcbiAgICAgIGRlYnVnKFwiZXJyb3I6ICVvXCIsIGFjdGlvbi5lcnJvcik7XG4gICAgICByZXR1cm4gYWN0aW9uLmVycm9yO1xuXG4gICAgY2FzZSBhY3Rpb25zLldBSVQ6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNhY3Rpb24oc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuU0FWRV9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBhY3Rpb24udHJhbnNhY3Rpb247XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiB7fTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY2VpcHQoc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuU0FWRV9SRUNFSVBUOlxuICAgICAgcmV0dXJuIGFjdGlvbi5yZWNlaXB0O1xuICAgIGNhc2UgYWN0aW9ucy5VTkxPQURfVFJBTlNBQ1RJT046XG4gICAgICByZXR1cm4ge307XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBibG9jayhzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TQVZFX0JMT0NLOlxuICAgICAgcmV0dXJuIGFjdGlvbi5ibG9jaztcbiAgICBjYXNlIGFjdGlvbnMuVU5MT0FEX1RSQU5TQUNUSU9OOlxuICAgICAgcmV0dXJuIHt9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3Qgc2Vzc2lvbiA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHJlYWR5LFxuICBsYXN0TG9hZGluZ0Vycm9yLFxuICBwcm9qZWN0SW5mb0NvbXB1dGVkLFxuICB0cmFuc2FjdGlvbixcbiAgcmVjZWlwdCxcbiAgYmxvY2tcbn0pO1xuXG5jb25zdCByZWR1Y2VTdGF0ZSA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHNlc3Npb24sXG4gIGRhdGEsXG4gIGV2bSxcbiAgc29saWRpdHksXG4gIHRyYWNlLFxuICBjb250cm9sbGVyXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpyZWR1Y2Vyc1wiKTtcblxuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgeyBzbG90QWRkcmVzcyB9IGZyb20gXCJ0cnVmZmxlLWRlY29kZXJcIjtcbmltcG9ydCB7IG1ha2VBc3NpZ25tZW50IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5pbXBvcnQgeyBDb252ZXJzaW9uLCBEZWZpbml0aW9uLCBFVk0gfSBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcblxuY29uc3QgREVGQVVMVF9TQ09QRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzY29wZXMoc3RhdGUgPSBERUZBVUxUX1NDT1BFUywgYWN0aW9uKSB7XG4gIHZhciBzY29wZTtcbiAgdmFyIHZhcmlhYmxlcztcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNDT1BFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5pZF0gfHwge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUlkLFxuXG4gICAgICAgICAgW2FjdGlvbi5pZF06IHtcbiAgICAgICAgICAgIC4uLnNjb3BlLFxuXG4gICAgICAgICAgICBpZDogYWN0aW9uLmlkLFxuICAgICAgICAgICAgc291cmNlSWQ6IGFjdGlvbi5zb3VyY2VJZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBhY3Rpb24ucGFyZW50SWQsXG4gICAgICAgICAgICBwb2ludGVyOiBhY3Rpb24ucG9pbnRlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9ucy5ERUNMQVJFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5ub2RlLnNjb3BlXSB8fCB7fTtcbiAgICAgIHZhcmlhYmxlcyA9IHNjb3BlLnZhcmlhYmxlcyB8fCBbXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbYWN0aW9uLm5vZGUuc2NvcGVdOiB7XG4gICAgICAgICAgICAuLi5zY29wZSxcblxuICAgICAgICAgICAgdmFyaWFibGVzOiBbXG4gICAgICAgICAgICAgIC4uLnZhcmlhYmxlcyxcblxuICAgICAgICAgICAgICB7IG5hbWU6IGFjdGlvbi5ub2RlLm5hbWUsIGlkOiBhY3Rpb24ubm9kZS5pZCB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG4vL2Egbm90ZSBvbiB0aGUgZm9sbG93aW5nIHJlZHVjZXI6IHNvbGlkaXR5IGFzc2lnbnMgYSB1bmlxdWUgQVNUIElEIHRvIGV2ZXJ5XG4vL0FTVCBub2RlIGFtb25nIGFsbCB0aGUgZmlsZXMgYmVpbmcgY29tcGlsZWQgdG9nZXRoZXIuICB0aHVzLCBpdCBpcywgZm9yIG5vdyxcbi8vc2FmZSB0byBpZGVudGlmeSB1c2VyLWRlZmluZWQgdHlwZXMgc29sZWx5IGJ5IHRoZWlyIEFTVCBJRC4gIEluIHRoZSBmdXR1cmUsXG4vL29uY2Ugd2UgZXZlbnR1YWxseSBzdXBwb3J0IGhhdmluZyBzb21lIGZpbGVzIGNvbXBpbGVkIHNlcGFyYXRlbHkgZnJvbSBvdGhlcnMsXG4vL3RoaXMgd2lsbCBiZWNvbWUgYSBidWcgeW91J2xsIGhhdmUgdG8gZml4LCBhbmQgeW91J2xsIGhhdmUgdG8gZml4IGl0IGluIHRoZVxuLy9kZWNvZGVyLCB0b28uICBTb3JyeSwgZnV0dXJlIG1lISAob3Igd2hvZXZlcidzIHN0dWNrIGRvaW5nIHRoaXMpXG5cbmZ1bmN0aW9uIHVzZXJEZWZpbmVkVHlwZXMoc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuREVGSU5FX1RZUEU6XG4gICAgICByZXR1cm4gWy4uLnN0YXRlLCBhY3Rpb24ubm9kZS5pZF07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX0FMTE9DQVRJT05TID0ge1xuICBzdG9yYWdlOiB7fSxcbiAgbWVtb3J5OiB7fSxcbiAgY2FsbGRhdGE6IHt9XG59O1xuXG5mdW5jdGlvbiBhbGxvY2F0aW9ucyhzdGF0ZSA9IERFRkFVTFRfQUxMT0NBVElPTlMsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuQUxMT0NBVEUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmFnZTogYWN0aW9uLnN0b3JhZ2UsXG4gICAgICBtZW1vcnk6IGFjdGlvbi5tZW1vcnksXG4gICAgICBjYWxsZGF0YTogYWN0aW9uLmNhbGxkYXRhXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgaW5mbyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHNjb3BlcyxcbiAgdXNlckRlZmluZWRUeXBlcyxcbiAgYWxsb2NhdGlvbnNcbn0pO1xuXG5jb25zdCBHTE9CQUxfQVNTSUdOTUVOVFMgPSBbXG4gIFt7IGJ1aWx0aW46IFwibXNnXCIgfSwgeyBzcGVjaWFsOiBcIm1zZ1wiIH1dLFxuICBbeyBidWlsdGluOiBcInR4XCIgfSwgeyBzcGVjaWFsOiBcInR4XCIgfV0sXG4gIFt7IGJ1aWx0aW46IFwiYmxvY2tcIiB9LCB7IHNwZWNpYWw6IFwiYmxvY2tcIiB9XSxcbiAgW3sgYnVpbHRpbjogXCJ0aGlzXCIgfSwgeyBzcGVjaWFsOiBcInRoaXNcIiB9XSxcbiAgW3sgYnVpbHRpbjogXCJub3dcIiB9LCB7IHNwZWNpYWw6IFwidGltZXN0YW1wXCIgfV0gLy93ZSBkb24ndCBoYXZlIGFuIGFsaWFzIFwibm93XCJcbl0ubWFwKChbaWRPYmosIHJlZl0pID0+IG1ha2VBc3NpZ25tZW50KGlkT2JqLCByZWYpKTtcblxuY29uc3QgREVGQVVMVF9BU1NJR05NRU5UUyA9IHtcbiAgYnlJZDogT2JqZWN0LmFzc2lnbihcbiAgICB7fSwgLy93ZSBzdGFydCBvdXQgd2l0aCBhbGwgZ2xvYmFscyBhc3NpZ25lZFxuICAgIC4uLkdMT0JBTF9BU1NJR05NRU5UUy5tYXAoYXNzaWdubWVudCA9PiAoeyBbYXNzaWdubWVudC5pZF06IGFzc2lnbm1lbnQgfSkpXG4gICksXG4gIGJ5QXN0SWQ6IHt9LCAvL25vIHJlZ3VsYXIgdmFyaWFibGVzIGFzc2lnbmVkIGF0IHN0YXJ0XG4gIGJ5QnVpbHRpbjogT2JqZWN0LmFzc2lnbihcbiAgICB7fSwgLy9hZ2FpbiwgYWxsIGdsb2JhbHMgc3RhcnQgYXNzaWduZWRcbiAgICAuLi5HTE9CQUxfQVNTSUdOTUVOVFMubWFwKGFzc2lnbm1lbnQgPT4gKHtcbiAgICAgIFthc3NpZ25tZW50LmJ1aWx0aW5dOiBbYXNzaWdubWVudC5pZF0gLy95ZXMsIHRoYXQncyBhIDEtZWxlbWVudCBhcnJheVxuICAgIH0pKVxuICApXG59O1xuXG5mdW5jdGlvbiBhc3NpZ25tZW50cyhzdGF0ZSA9IERFRkFVTFRfQVNTSUdOTUVOVFMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkFTU0lHTjpcbiAgICBjYXNlIGFjdGlvbnMuTUFQX1BBVEhfQU5EX0FTU0lHTjpcbiAgICAgIGRlYnVnKFwiYWN0aW9uLnR5cGUgJU9cIiwgYWN0aW9uLnR5cGUpO1xuICAgICAgZGVidWcoXCJhY3Rpb24uYXNzaWdubWVudHMgJU9cIiwgYWN0aW9uLmFzc2lnbm1lbnRzKTtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFjdGlvbi5hc3NpZ25tZW50cykucmVkdWNlKChhY2MsIGFzc2lnbm1lbnQpID0+IHtcbiAgICAgICAgbGV0IHsgaWQsIGFzdElkIH0gPSBhc3NpZ25tZW50O1xuICAgICAgICAvL3dlIGFzc3VtZSBmb3Igbm93IHRoYXQgb25seSBvcmRpbmFyeSB2YXJpYWJsZXMgd2lsbCBiZSBhc3NpZ25lZCB0aGlzXG4gICAgICAgIC8vd2F5LCBhbmQgbm90IGdsb2JhbHM7IGdsb2JhbHMgYXJlIGhhbmRsZWQgaW4gREVGQVVMVF9BU1NJR05NRU5UU1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBieUlkOiB7XG4gICAgICAgICAgICAuLi5hY2MuYnlJZCxcbiAgICAgICAgICAgIFtpZF06IGFzc2lnbm1lbnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJ5QXN0SWQ6IHtcbiAgICAgICAgICAgIC4uLmFjYy5ieUFzdElkLFxuICAgICAgICAgICAgW2FzdElkXTogWy4uLm5ldyBTZXQoWy4uLihhY2MuYnlBc3RJZFthc3RJZF0gfHwgW10pLCBpZF0pXVxuICAgICAgICAgICAgLy93ZSB1c2UgYSBzZXQgZm9yIHVuaXF1ZW5lc3NcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LCBzdGF0ZSk7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVTRVQ6XG4gICAgICByZXR1cm4gREVGQVVMVF9BU1NJR05NRU5UUztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9QQVRIUyA9IHtcbiAgYnlBZGRyZXNzOiB7fVxufTtcblxuLy9XQVJOSU5HOiBkbyAqbm90KiByZWx5IG9uIG1hcHBlZFBhdGhzIHRvIGtlZXAgdHJhY2sgb2YgcGF0aHMgdGhhdCBkbyBub3Rcbi8vaW52b2x2ZSBtYXBwaW5nIGtleXMhICBZZXMsIG1hbnkgd2lsbCBnZXQgbWFwcGVkLCBidXQgdGhlcmUgaXMgbm8gZ3VhcmFudGVlLlxuLy9Pbmx5IHdoZW4gbWFwcGluZyBrZXlzIGFyZSBpbnZvbHZlZCBkb2VzIGl0IG5lY2Vzc2FyaWx5IHdvcmsgcmVsaWFibHkgLS1cbi8vd2hpY2ggaXMgZmluZSwgYXMgdGhhdCdzIGFsbCB3ZSBuZWVkIGl0IGZvci5cbmZ1bmN0aW9uIG1hcHBlZFBhdGhzKHN0YXRlID0gREVGQVVMVF9QQVRIUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuTUFQX1BBVEhfQU5EX0FTU0lHTjpcbiAgICAgIGxldCB7IGFkZHJlc3MsIHNsb3QsIHR5cGVJZGVudGlmaWVyLCBwYXJlbnRUeXBlIH0gPSBhY3Rpb247XG4gICAgICAvL2hvdyB0aGlzIGNhc2Ugd29ya3M6IGZpcnN0LCB3ZSBmaW5kIHRoZSBzcG90IGluIG91ciB0YWJsZSAoYmFzZWQgb25cbiAgICAgIC8vYWRkcmVzcywgdHlwZSBpZGVudGlmaWVyLCBhbmQgc2xvdCBhZGRyZXNzKSB3aGVyZSB0aGUgbmV3IGVudHJ5IHNob3VsZFxuICAgICAgLy9iZSBhZGRlZDsgaWYgbmVlZGVkIHdlIHNldCB1cCBhbGwgdGhlIG9iamVjdHMgbmVlZGVkIGFsb25nIHRoZSB3YXkuICBJZlxuICAgICAgLy90aGVyZSdzIGFscmVhZHkgc29tZXRoaW5nIHRoZXJlLCB3ZSBkbyBub3RoaW5nLiAgSWYgdGhlcmUncyBub3RoaW5nXG4gICAgICAvL3RoZXJlLCB3ZSByZWNvcmQgb3VyIGdpdmVuIHNsb3QgaW4gdGhhdCBzcG90IGluIHRoYXQgdGFibGUgLS0gaG93ZXZlcixcbiAgICAgIC8vd2UgYWx0ZXIgaXQgaW4gb25lIGtleSB3YXkuICBCZWZvcmUgZW50cnksIHdlIGNoZWNrIGlmIHRoZSBzbG90J3NcbiAgICAgIC8vKnBhcmVudCogaGFzIGEgc3BvdCBpbiB0aGUgdGFibGUsIGJhc2VkIG9uIGFkZHJlc3MgKHNhbWUgZm9yIGJvdGggY2hpbGRcbiAgICAgIC8vYW5kIHBhcmVudCksIHBhcmVudFR5cGUsIGFuZCB0aGUgcGFyZW50J3Mgc2xvdCBhZGRyZXNzICh3aGljaCBjYW4gYmVcbiAgICAgIC8vZm91bmQgYXMgdGhlIHNsb3RBZGRyZXNzIG9mIHRoZSBzbG90J3MgcGF0aCBvYmplY3QsIGlmIGl0IGV4aXN0cyAtLSBpZlxuICAgICAgLy9pdCBkb2Vzbid0IHRoZW4gd2UgY29uY2x1ZGUgdGhhdCBubyB0aGUgcGFyZW50IGRvZXMgbm90IGhhdmUgYSBzcG90IGluXG4gICAgICAvL3RoZSB0YWJsZSkuICBJZiB0aGUgcGFyZW50IGhhcyBhIHNsb3QgaW4gdGhlIHRhYmxlIGFscmVhZHksIHRoZW4gd2VcbiAgICAgIC8vYWx0ZXIgdGhlIGNoaWxkIHNsb3QgYnkgcmVwbGFjaW5nIGl0cyBwYXRoIHdpdGggdGhlIHBhcmVudCBzbG90LiAgVGhpc1xuICAgICAgLy93aWxsIGtlZXAgdGhlIHNsb3RBZGRyZXNzIHRoZSBzYW1lLCBidXQgc2luY2UgdGhlIHZlcnNpb25zIGtlcHQgaW4gdGhlXG4gICAgICAvL3RhYmxlIGhlcmUgYXJlIHN1cHBvc2VkIHRvIHByZXNlcnZlIHBhdGggaW5mb3JtYXRpb24sIHdlJ2xsIGJlXG4gICAgICAvL3JlcGxhY2luZyBhIGZhaXJseSBiYXJlLWJvbmVzIFNsb3Qgb2JqZWN0IHdpdGggb25lIHdpdGggYSBmdWxsIHBhdGguXG5cbiAgICAgIC8vd2UgZG8gTk9UIHdhbnQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0eXBlcyB3aXRoIGFuZCB3aXRob3V0IFwiX3B0clwiIG9uXG4gICAgICAvL3RoZSBlbmQgaGVyZSFcbiAgICAgIGRlYnVnKFwidHlwZUlkZW50aWZpZXIgJXNcIiwgdHlwZUlkZW50aWZpZXIpO1xuICAgICAgdHlwZUlkZW50aWZpZXIgPSBEZWZpbml0aW9uLnJlc3RvcmVQdHIodHlwZUlkZW50aWZpZXIpO1xuICAgICAgcGFyZW50VHlwZSA9IERlZmluaXRpb24ucmVzdG9yZVB0cihwYXJlbnRUeXBlKTtcblxuICAgICAgZGVidWcoXCJzbG90ICVvXCIsIHNsb3QpO1xuICAgICAgbGV0IGhleFNsb3RBZGRyZXNzID0gQ29udmVyc2lvbi50b0hleFN0cmluZyhcbiAgICAgICAgc2xvdEFkZHJlc3Moc2xvdCksXG4gICAgICAgIEVWTS5XT1JEX1NJWkVcbiAgICAgICk7XG4gICAgICBsZXQgcGFyZW50QWRkcmVzcyA9IHNsb3QucGF0aFxuICAgICAgICA/IENvbnZlcnNpb24udG9IZXhTdHJpbmcoc2xvdEFkZHJlc3Moc2xvdC5wYXRoKSwgRVZNLldPUkRfU0laRSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIC8vdGhpcyBpcyBnb2luZyB0byBiZSBtZXNzeSBhbmQgcHJvY2VkdXJhbCwgc29ycnkuICBidXQgbGV0J3Mgc3RhcnQgd2l0aFxuICAgICAgLy90aGUgZWFzeSBzdHVmZjogY3JlYXRlIHRoZSBuZXcgYWRkcmVzcyBpZiBuZWVkZWQsIGNsb25lIGlmIG5vdFxuICAgICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYnlBZGRyZXNzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlBZGRyZXNzLFxuICAgICAgICAgIFthZGRyZXNzXToge1xuICAgICAgICAgICAgYnlUeXBlOiB7XG4gICAgICAgICAgICAgIC4uLihzdGF0ZS5ieUFkZHJlc3NbYWRkcmVzc10gfHwgeyBieVR5cGU6IHt9IH0pLmJ5VHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy9ub3csIGxldCdzIGFkZCBpbiB0aGUgbmV3IHR5cGUsIGlmIG5lZWRlZFxuICAgICAgbmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZSA9IHtcbiAgICAgICAgLi4ubmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZSxcbiAgICAgICAgW3R5cGVJZGVudGlmaWVyXToge1xuICAgICAgICAgIGJ5U2xvdEFkZHJlc3M6IHtcbiAgICAgICAgICAgIC4uLihcbiAgICAgICAgICAgICAgbmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZVt0eXBlSWRlbnRpZmllcl0gfHwge1xuICAgICAgICAgICAgICAgIGJ5U2xvdEFkZHJlc3M6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkuYnlTbG90QWRkcmVzc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbGV0IG9sZFNsb3QgPVxuICAgICAgICBuZXdTdGF0ZS5ieUFkZHJlc3NbYWRkcmVzc10uYnlUeXBlW3R5cGVJZGVudGlmaWVyXS5ieVNsb3RBZGRyZXNzW1xuICAgICAgICAgIGhleFNsb3RBZGRyZXNzXG4gICAgICAgIF07XG4gICAgICAvL3llcywgdGhpcyBsb29rcyBzdHJhbmdlLCBidXQgd2UgaGF2ZW4ndCBjaGFuZ2VkIGl0IHlldCBleGNlcHQgdG9cbiAgICAgIC8vY2xvbmUgb3IgY3JlYXRlIGVtcHR5IChhbmQgd2UgZG9uJ3Qgd2FudCB1bmRlZmluZWQhKVxuICAgICAgLy9ub3c6IGlzIHRoZXJlIHNvbWV0aGluZyBhbHJlYWR5IHRoZXJlIG9yIG5vPyAgaWYgbm8sIHdlIG11c3QgYWRkXG4gICAgICBpZiAob2xkU2xvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBuZXdTbG90O1xuICAgICAgICBkZWJ1ZyhcInBhcmVudEFkZHJlc3MgJW9cIiwgcGFyZW50QWRkcmVzcyk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnRBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBuZXdTdGF0ZS5ieUFkZHJlc3NbYWRkcmVzc10uYnlUeXBlW3BhcmVudFR5cGVdICYmXG4gICAgICAgICAgbmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZVtwYXJlbnRUeXBlXS5ieVNsb3RBZGRyZXNzW1xuICAgICAgICAgICAgcGFyZW50QWRkcmVzc1xuICAgICAgICAgIF1cbiAgICAgICAgKSB7XG4gICAgICAgICAgLy9pZiB0aGUgcGFyZW50IGlzIGFscmVhZHkgcHJlc2VudCwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZ2l2ZW5cbiAgICAgICAgICAvL3BhcmVudCFcbiAgICAgICAgICBuZXdTbG90ID0ge1xuICAgICAgICAgICAgLi4uc2xvdCxcbiAgICAgICAgICAgIHBhdGg6XG4gICAgICAgICAgICAgIG5ld1N0YXRlLmJ5QWRkcmVzc1thZGRyZXNzXS5ieVR5cGVbcGFyZW50VHlwZV0uYnlTbG90QWRkcmVzc1tcbiAgICAgICAgICAgICAgICBwYXJlbnRBZGRyZXNzXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Nsb3QgPSBzbG90O1xuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXRlLmJ5QWRkcmVzc1thZGRyZXNzXS5ieVR5cGVbdHlwZUlkZW50aWZpZXJdLmJ5U2xvdEFkZHJlc3NbXG4gICAgICAgICAgaGV4U2xvdEFkZHJlc3NcbiAgICAgICAgXSA9IG5ld1Nsb3Q7XG4gICAgICB9XG4gICAgICAvL2lmIHRoZXJlJ3MgYWxyZWFkeSBzb21ldGhpbmcgdGhlcmUsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcblxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIERFRkFVTFRfUEFUSFM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBhc3NpZ25tZW50cyxcbiAgbWFwcGVkUGF0aHNcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZXZtOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIGV4dHJhY3RQcmltYXJ5U291cmNlIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5pbXBvcnQgKiBhcyBEZWNvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcblxuaW1wb3J0IEJOIGZyb20gXCJibi5qc1wiO1xuXG5jb25zdCBERUZBVUxUX0NPTlRFWFRTID0ge1xuICBieUNvbnRleHQ6IHt9XG59O1xuXG5mdW5jdGlvbiBjb250ZXh0cyhzdGF0ZSA9IERFRkFVTFRfQ09OVEVYVFMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgLypcbiAgICAgKiBBZGRpbmcgYSBuZXcgY29udGV4dFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfQ09OVEVYVDpcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICBiaW5hcnksXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgY29tcGlsZXIsXG4gICAgICAgIGFiaSxcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgY29udHJhY3RLaW5kLFxuICAgICAgICBpc0NvbnN0cnVjdG9yXG4gICAgICB9ID0gYWN0aW9uO1xuICAgICAgZGVidWcoXCJhY3Rpb24gJU9cIiwgYWN0aW9uKTtcbiAgICAgIC8vTk9URTogd2UgdGFrZSBoYXNoIGFzICpzdHJpbmcqLCBub3QgYXMgYnl0ZXMsIGJlY2F1c2UgdGhlIGJpbmFyeSBtYXlcbiAgICAgIC8vY29udGFpbiBsaW5rIHJlZmVyZW5jZXMhXG4gICAgICBjb25zdCBjb250ZXh0ID0ga2VjY2FrMjU2KHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsdWU6IGJpbmFyeSB9KTtcbiAgICAgIGxldCBwcmltYXJ5U291cmNlO1xuICAgICAgaWYgKHNvdXJjZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByaW1hcnlTb3VyY2UgPSBleHRyYWN0UHJpbWFyeVNvdXJjZShzb3VyY2VNYXApO1xuICAgICAgfVxuICAgICAgLy9vdGhlcndpc2UgbGVhdmUgaXQgdW5kZWZpbmVkXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBieUNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUNvbnRleHQsXG4gICAgICAgICAgW2NvbnRleHRdOiB7XG4gICAgICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgYmluYXJ5LFxuICAgICAgICAgICAgc291cmNlTWFwLFxuICAgICAgICAgICAgcHJpbWFyeVNvdXJjZSxcbiAgICAgICAgICAgIGNvbXBpbGVyLFxuICAgICAgICAgICAgYWJpLFxuICAgICAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgICAgIGNvbnRyYWN0S2luZCxcbiAgICAgICAgICAgIGlzQ29uc3RydWN0b3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbnMuTk9STUFMSVpFX0NPTlRFWFRTOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlDb250ZXh0OiBEZWNvZGVVdGlscy5Db250ZXh0cy5ub3JtYWxpemVDb250ZXh0cyhzdGF0ZS5ieUNvbnRleHQpXG4gICAgICB9O1xuXG4gICAgLypcbiAgICAgKiBEZWZhdWx0IGNhc2VcbiAgICAgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IGluZm8gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBjb250ZXh0c1xufSk7XG5cbmNvbnN0IERFRkFVTFRfVFggPSB7XG4gIGdhc3ByaWNlOiBuZXcgQk4oMCksXG4gIG9yaWdpbjogRGVjb2RlVXRpbHMuRVZNLlpFUk9fQUREUkVTU1xufTtcblxuZnVuY3Rpb24gdHgoc3RhdGUgPSBERUZBVUxUX1RYLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TQVZFX0dMT0JBTFM6XG4gICAgICBsZXQgeyBnYXNwcmljZSwgb3JpZ2luIH0gPSBhY3Rpb247XG4gICAgICByZXR1cm4geyBnYXNwcmljZSwgb3JpZ2luIH07XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBERUZBVUxUX1RYO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9CTE9DSyA9IHtcbiAgY29pbmJhc2U6IERlY29kZVV0aWxzLkVWTS5aRVJPX0FERFJFU1MsXG4gIGRpZmZpY3VsdHk6IG5ldyBCTigwKSxcbiAgZ2FzbGltaXQ6IG5ldyBCTigwKSxcbiAgbnVtYmVyOiBuZXcgQk4oMCksXG4gIHRpbWVzdGFtcDogbmV3IEJOKDApXG59O1xuXG5mdW5jdGlvbiBibG9jayhzdGF0ZSA9IERFRkFVTFRfQkxPQ0ssIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNBVkVfR0xPQkFMUzpcbiAgICAgIHJldHVybiBhY3Rpb24uYmxvY2s7XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBERUZBVUxUX0JMT0NLO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgZ2xvYmFscyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHR4LFxuICBibG9ja1xufSk7XG5cbmZ1bmN0aW9uIHN0YXR1cyhzdGF0ZSA9IG51bGwsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNBVkVfU1RBVFVTOlxuICAgICAgcmV0dXJuIGFjdGlvbi5zdGF0dXM7XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbENhbGwoc3RhdGUgPSBudWxsLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5DQUxMOlxuICAgIGNhc2UgYWN0aW9ucy5DUkVBVEU6XG4gICAgICAvL3dlIG9ubHkgd2FudCB0byBzYXZlIHRoZSBpbml0aWFsIGNhbGwsIHNvIHJldHVyblxuICAgICAgLy90aGUgY3VycmVudCBzdGF0ZSBpZiBpdCdzIG5vdCBudWxsXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy93ZSdsbCBqdXN0IHN0b3JlIHRoZSBhY3Rpb24gaXRzZWxmIGluIHRoZSBzdGF0ZVxuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgfVxuICAgIGNhc2UgYWN0aW9ucy5VTkxPQURfVFJBTlNBQ1RJT046XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHRyYW5zYWN0aW9uID0gY29tYmluZVJlZHVjZXJzKHtcbiAgZ2xvYmFscyxcbiAgc3RhdHVzLFxuICBpbml0aWFsQ2FsbFxufSk7XG5cbmZ1bmN0aW9uIGNhbGxzdGFjayhzdGF0ZSA9IFtdLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5DQUxMOiB7XG4gICAgICBjb25zdCB7IGFkZHJlc3MsIGRhdGEsIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlIH0gPSBhY3Rpb247XG4gICAgICByZXR1cm4gc3RhdGUuY29uY2F0KFt7IGFkZHJlc3MsIGRhdGEsIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlIH1dKTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbnMuQ1JFQVRFOiB7XG4gICAgICBjb25zdCB7IGJpbmFyeSwgc3RvcmFnZUFkZHJlc3MsIHNlbmRlciwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBzdGF0ZS5jb25jYXQoXG4gICAgICAgIFt7IGJpbmFyeSwgZGF0YTogXCIweFwiLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSB9XVxuICAgICAgICAvL3RoZSBlbXB0eSBkYXRhIGZpZWxkIGlzIHRvIG1ha2UgbXNnLmRhdGEgYW5kIG1zZy5zaWcgY29tZSBvdXQgcmlnaHRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLlJFVFVSTl9DQUxMOlxuICAgIGNhc2UgYWN0aW9ucy5SRVRVUk5fQ1JFQVRFOlxuICAgIGNhc2UgYWN0aW9ucy5GQUlMOlxuICAgICAgLy9wb3AgdGhlIHN0YWNrLi4uIHVubGVzcyAoSEFDSykgdGhhdCB3b3VsZCBsZWF2ZSBpdCBlbXB0eSAodGhpcyB3aWxsXG4gICAgICAvL29ubHkgaGFwcGVuIGF0IHRoZSBlbmQgd2hlbiB3ZSB3YW50IHRvIGtlZXAgdGhlIGxhc3Qgb25lIGFyb3VuZClcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGggPiAxID8gc3RhdGUuc2xpY2UoMCwgLTEpIDogc3RhdGU7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVTRVQ6XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBbXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9DT0RFWCA9IFtcbiAge1xuICAgIGFjY291bnRzOiB7fVxuICAgIC8vd2lsbCBiZSBtb3JlIGhlcmUgaW4gdGhlIGZ1dHVyZSFcbiAgfVxuXTtcblxuZnVuY3Rpb24gY29kZXgoc3RhdGUgPSBERUZBVUxUX0NPREVYLCBhY3Rpb24pIHtcbiAgbGV0IG5ld1N0YXRlLCB0b3BDb2RleDtcblxuICBjb25zdCB1cGRhdGVGcmFtZVN0b3JhZ2UgPSAoZnJhbWUsIGFkZHJlc3MsIHNsb3QsIHZhbHVlKSA9PiAoe1xuICAgIC4uLmZyYW1lLFxuICAgIGFjY291bnRzOiB7XG4gICAgICAuLi5mcmFtZS5hY2NvdW50cyxcbiAgICAgIFthZGRyZXNzXToge1xuICAgICAgICAuLi5mcmFtZS5hY2NvdW50c1thZGRyZXNzXSxcbiAgICAgICAgc3RvcmFnZToge1xuICAgICAgICAgIC4uLmZyYW1lLmFjY291bnRzW2FkZHJlc3NdLnN0b3JhZ2UsXG4gICAgICAgICAgW3Nsb3RdOiB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjb25zdCB1cGRhdGVGcmFtZUNvZGUgPSAoZnJhbWUsIGFkZHJlc3MsIGNvZGUsIGNvbnRleHQpID0+IHtcbiAgICBsZXQgZXhpc3RpbmdQYWdlID0gZnJhbWUuYWNjb3VudHNbYWRkcmVzc10gfHwgeyBzdG9yYWdlOiB7fSB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5mcmFtZSxcbiAgICAgIGFjY291bnRzOiB7XG4gICAgICAgIC4uLmZyYW1lLmFjY291bnRzLFxuICAgICAgICBbYWRkcmVzc106IHtcbiAgICAgICAgICAuLi5leGlzdGluZ1BhZ2UsXG4gICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vbGF0ZXI6IHdpbGwgYWRkIFwiZm9yY2VcIiBwYXJhbWV0ZXJcbiAgY29uc3Qgc2FmZVBvcCA9IGFycmF5ID0+IChhcnJheS5sZW5ndGggPiAyID8gYXJyYXkuc2xpY2UoMCwgLTEpIDogYXJyYXkpO1xuXG4gIC8vbGF0ZXI6IHdpbGwgYWRkIFwiZm9yY2VcIiBwYXJhbWV0ZXJcbiAgY29uc3Qgc2FmZVNhdmUgPSBhcnJheSA9PlxuICAgIGFycmF5Lmxlbmd0aCA+IDJcbiAgICAgID8gYXJyYXkuc2xpY2UoMCwgLTIpLmNvbmNhdChbYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV1dKVxuICAgICAgOiBhcnJheTtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkNBTEw6XG4gICAgICBkZWJ1ZyhcImNhbGwgYWN0aW9uXCIpO1xuICAgICAgZGVidWcoXCJjb2RleDogJU9cIiwgc3RhdGUpO1xuICAgICAgLy9vbiBhIGNhbGwsIHdlIGNhbiBqdXN0IG1ha2UgYSBuZXcgc3RhY2tmcmFtZSBieSBjbG9uaW5nIHRoZSB0b3BcbiAgICAgIC8vc3RhY2tmcmFtZTsgdGhlcmUgc2hvdWxkIGFscmVhZHkgYmUgYW4gYWNjb3VudCBmb3IgdGhlIGFkZHJlc3Mgd2UncmVcbiAgICAgIC8vY2FsbGluZyBpbnRvLCBzbyB3ZSBkb24ndCBuZWVkIHRvIG1ha2Ugb25lXG4gICAgICByZXR1cm4gWy4uLnN0YXRlLCBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXV07XG5cbiAgICBjYXNlIGFjdGlvbnMuQ1JFQVRFOlxuICAgICAgLy9vbiBhIGNyZWF0ZSwgbWFrZSBhIG5ldyBzdGFja2ZyYW1lLCB0aGVuIGFkZCBhIG5ldyBwYWdlcyB0byB0aGVcbiAgICAgIC8vY29kZXggaWYgbmVjZXNzYXJ5OyBkb24ndCBhZGQgYSB6ZXJvIHBhZ2UgdGhvdWdoIChvciBwYWdlcyB0aGF0IGFscmVhZHlcbiAgICAgIC8vZXhpc3QpXG5cbiAgICAgIC8vZmlyc3QsIGFkZCBhIG5ldyBzdGFja2ZyYW1lIGJ5IGNsb25pbmcgdGhlIHRvcCBvbmVcbiAgICAgIG5ld1N0YXRlID0gWy4uLnN0YXRlLCBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXV07XG4gICAgICB0b3BDb2RleCA9IG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdO1xuICAgICAgLy9ub3csIGRvIHdlIG5lZWQgdG8gYWRkIGEgbmV3IGFkZHJlc3MgdG8gdGhpcyBzdGFja2ZyYW1lP1xuICAgICAgaWYgKFxuICAgICAgICB0b3BDb2RleC5hY2NvdW50c1thY3Rpb24uc3RvcmFnZUFkZHJlc3NdICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgYWN0aW9uLnN0b3JhZ2VBZGRyZXNzID09PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTXG4gICAgICApIHtcbiAgICAgICAgLy9pZiB3ZSBkb24ndFxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICAvL2lmIHdlIGRvXG4gICAgICBuZXdTdGF0ZVtuZXdTdGF0ZS5sZW5ndGggLSAxXSA9IHtcbiAgICAgICAgLi4udG9wQ29kZXgsXG4gICAgICAgIGFjY291bnRzOiB7XG4gICAgICAgICAgLi4udG9wQ29kZXguYWNjb3VudHMsXG4gICAgICAgICAgW2FjdGlvbi5zdG9yYWdlQWRkcmVzc106IHtcbiAgICAgICAgICAgIHN0b3JhZ2U6IHt9LFxuICAgICAgICAgICAgY29kZTogXCIweFwiLFxuICAgICAgICAgICAgY29udGV4dDogbnVsbFxuICAgICAgICAgICAgLy90aGVyZSB3aWxsIGJlIG1vcmUgaGVyZSBpbiB0aGUgZnV0dXJlIVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5TVE9SRToge1xuICAgICAgLy9vbiBhIHN0b3JlLCB0aGUgcmVsZXZhbnQgcGFnZSBzaG91bGQgYWxyZWFkeSBleGlzdCwgc28gd2UgY2FuIGp1c3RcbiAgICAgIC8vYWRkIG9yIHVwZGF0ZSB0aGUgbmVlZGVkIHNsb3RcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgc2xvdCwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChhZGRyZXNzID09PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTKSB7XG4gICAgICAgIC8vYXMgYWx3YXlzLCB3ZSBkbyBub3QgbWFpbnRhaW4gYSB6ZXJvIHBhZ2VcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgbmV3U3RhdGUgPSBzdGF0ZS5zbGljZSgpOyAvL2Nsb25lIHRoZSBzdGF0ZVxuICAgICAgdG9wQ29kZXggPSBuZXdTdGF0ZVtuZXdTdGF0ZS5sZW5ndGggLSAxXTtcbiAgICAgIG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdID0gdXBkYXRlRnJhbWVTdG9yYWdlKFxuICAgICAgICB0b3BDb2RleCxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgc2xvdCxcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLkxPQUQ6IHtcbiAgICAgIC8vbG9hZHMgYXJlIGEgbGl0dGxlIG1vcmUgY29tcGxpY2F0ZWQgLS0gdXN1YWxseSB3ZSBkbyBub3RoaW5nLCBidXQgaWZcbiAgICAgIC8vaXQncyBhbiBleHRlcm5hbCBsb2FkICh0aGVyZSB3YXMgbm90aGluZyBhbHJlYWR5IHRoZXJlKSwgdGhlbiB3ZSB3YW50XG4gICAgICAvL3RvIHVwZGF0ZSAqZXZlcnkqIHN0YWNrZnJhbWVcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgc2xvdCwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChhZGRyZXNzID09PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTKSB7XG4gICAgICAgIC8vYXMgYWx3YXlzLCB3ZSBkbyBub3QgbWFpbnRhaW4gYSB6ZXJvIHBhZ2VcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgdG9wQ29kZXggPSBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXTtcbiAgICAgIGlmICh0b3BDb2RleC5hY2NvdW50c1thZGRyZXNzXS5zdG9yYWdlW3Nsb3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy9pZiB3ZSBhbHJlYWR5IGhhdmUgYSB2YWx1ZSBpbiB0aGUgKnRvcCogc3RhY2tmcmFtZSwgdXBkYXRlICpubypcbiAgICAgICAgLy9zdGFja2ZyYW1lczsgZG9uJ3QgdXBkYXRlIHRoZSB0b3AgKG5vIG5lZWQsIGl0J3MganVzdCBhIGxvYWQsIG5vdCBhXG4gICAgICAgIC8vc3RvcmUpLCBkb24ndCB1cGRhdGUgdGhlIHJlc3QgKHRoYXQgd291bGQgYmUgd3JvbmcsIHlvdSBtaWdodCBiZVxuICAgICAgICAvL2xvYWRpbmcgYSB2YWx1ZSB0aGF0IHdpbGwgZ2V0IHJldmVydGVkIGxhdGVyKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2lmIHdlICpkb24ndCogYWxyZWFkeSBoYXZlIGEgdmFsdWUgaW4gdGhlIHRvcCBzdGFja2ZyYW1lLCB0aGF0IG1lYW5zXG4gICAgICAgIC8vd2UncmUgbG9hZGluZyBhIHZhbHVlIGZyb20gYSBwcmV2aW91cyB0cmFuc2FjdGlvbiEgIFRoYXQncyBub3QgYVxuICAgICAgICAvL3ZhbHVlIHRoYXQgd2lsbCBnZXQgcmV2ZXJ0ZWQgaWYgdGhpcyBjYWxsIGZhaWxzLCBzbyB1cGRhdGUgKmV2ZXJ5KlxuICAgICAgICAvL3N0YWNrZnJhbWVcbiAgICAgICAgcmV0dXJuIHN0YXRlLm1hcChmcmFtZSA9PlxuICAgICAgICAgIHVwZGF0ZUZyYW1lU3RvcmFnZShmcmFtZSwgYWRkcmVzcywgc2xvdCwgdmFsdWUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLlJFVFVSTl9DQUxMOlxuICAgICAgLy93ZSB3YW50IHRvIHBvcCB0aGUgdG9wIHdoaWxlIG1ha2luZyB0aGUgbmV3IHRvcCBhIGNvcHkgb2YgdGhlIG9sZCB0b3A7XG4gICAgICAvL3RoYXQgaXMgdG8gc2F5LCB3ZSB3YW50IHRvIGRyb3AganVzdCB0aGUgZWxlbWVudCAqc2Vjb25kKiBmcm9tIHRoZSB0b3BcbiAgICAgIC8vTk9URTogd2UgZG9uJ3QgZXZlciBnbyBkb3duIHRvIDEgZWxlbWVudCFcbiAgICAgIHJldHVybiBzYWZlU2F2ZShzdGF0ZSk7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVUVVJOX0NSRUFURToge1xuICAgICAgLy93ZSdyZSBnb2luZyB0byBkbyB0aGUgc2FtZSB0aGluZ3MgaW4gdGhpcyBjYXNlIGFzIGluIHRoZSB1c3VhbCByZXR1cm5cbiAgICAgIC8vY2FzZSwgYnV0IGZpcnN0IHdlIG5lZWQgdG8gcmVjb3JkIHRoZSBjb2RlIHRoYXQgd2FzIHJldHVybmVkXG4gICAgICBjb25zdCB7IGFkZHJlc3MsIGNvZGUsIGNvbnRleHQgfSA9IGFjdGlvbjtcbiAgICAgIG5ld1N0YXRlID0gc3RhdGUuc2xpY2UoKTsgLy9jbG9uZSB0aGUgc3RhdGVcbiAgICAgIC8vTk9URTogc2luY2UgdGhpcyBpcyBvbmx5IGZvciBSRVRVUk5fQ1JFQVRFLCBhbmQgbm90IEZBSUwsIHdlIHNob3VsZG4ndFxuICAgICAgLy9oYXZlIHRvIHdvcnJ5IGFib3V0IGFjY2lkZW50YWxseSBnZXR0aW5nIGEgemVybyBhZGRyZXNzIGhlcmVcbiAgICAgIG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdID0gdXBkYXRlRnJhbWVDb2RlKFxuICAgICAgICBuZXdTdGF0ZVtuZXdTdGF0ZS5sZW5ndGggLSAxXSxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY29kZSxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICAgIGRlYnVnKFwibmV3U3RhdGU6ICVPXCIsIG5ld1N0YXRlKTtcbiAgICAgIHJldHVybiBzYWZlU2F2ZShuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLkZBSUw6XG4gICAgICAvL3BvcCB0aGUgc3RhY2tcbiAgICAgIC8vTk9URTogd2UgZG9uJ3QgZXZlciBnbyBkb3duIHRvIDEgZWxlbWVudCFcbiAgICAgIHJldHVybiBzYWZlUG9wKHN0YXRlKTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBbc3RhdGVbMF1dOyAvL2xlYXZlIHRoZSAtMSBmcmFtZSBvbiB0aGUgc3RhY2tcblxuICAgIGNhc2UgYWN0aW9ucy5VTkxPQURfVFJBTlNBQ1RJT046XG4gICAgICByZXR1cm4gREVGQVVMVF9DT0RFWDtcblxuICAgIGNhc2UgYWN0aW9ucy5BRERfSU5TVEFOQ0U6IHtcbiAgICAgIC8vYWRkIHRoZSBpbnN0YW5jZSB0byBldmVyeSBmcmFtZVxuICAgICAgLy8odGhpcyBpcyBhIGxpdHRsZSBIQUNLeSwgYnV0IGl0ICpzaG91bGQqIGJlIGZpbmUpXG4gICAgICBkZWJ1ZyhcImFkZGluZyBpbnN0YW5jZVwiKTtcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgYmluYXJ5LCBjb250ZXh0IH0gPSBhY3Rpb247XG4gICAgICByZXR1cm4gc3RhdGUubWFwKGZyYW1lID0+XG4gICAgICAgIHVwZGF0ZUZyYW1lQ29kZShmcmFtZSwgYWRkcmVzcywgYmluYXJ5LCBjb250ZXh0KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBjYWxsc3RhY2ssXG4gIGNvZGV4XG59KTtcblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZm8sXG4gIHRyYW5zYWN0aW9uLFxuICBwcm9jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL3JlZHVjZXJzLmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5jb25zdCBERUZBVUxUX1NPVVJDRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VzKHN0YXRlID0gREVGQVVMVF9TT1VSQ0VTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IHNvdXJjZVxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfU09VUkNFOlxuICAgICAgbGV0IHsgYXN0LCBzb3VyY2UsIHNvdXJjZVBhdGgsIGNvbXBpbGVyIH0gPSBhY3Rpb247XG5cbiAgICAgIGxldCBpZCA9IE9iamVjdC5rZXlzKHN0YXRlLmJ5SWQpLmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbaWRdOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGFzdCxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHNvdXJjZVBhdGgsXG4gICAgICAgICAgICBjb21waWxlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc291cmNlc1xufSk7XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVwdGhTdGFjayhzdGF0ZSA9IFswXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuSlVNUDpcbiAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLnNsaWNlKCk7IC8vY2xvbmUgdGhlIHN0YXRlXG4gICAgICBjb25zdCBkZWx0YSA9IHNwZWx1bmsoYWN0aW9uLmp1bXBEaXJlY3Rpb24pO1xuICAgICAgbGV0IHRvcCA9IG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdO1xuICAgICAgbmV3U3RhdGVbbmV3U3RhdGUubGVuZ3RoIC0gMV0gPSB0b3AgKyBkZWx0YTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBbMF07XG5cbiAgICBjYXNlIGFjdGlvbnMuRVhURVJOQUxfQ0FMTDpcbiAgICAgIHJldHVybiBbLi4uc3RhdGUsIHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdICsgMV07XG5cbiAgICBjYXNlIGFjdGlvbnMuRVhURVJOQUxfUkVUVVJOOlxuICAgICAgLy9qdXN0IHBvcCB0aGUgc3RhY2shIHVubGVzcywgSEFDSywgdGhhdCB3b3VsZCBsZWF2ZSBpdCBlbXB0eVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aCA+IDEgPyBzdGF0ZS5zbGljZSgwLCAtMSkgOiBzdGF0ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BlbHVuayhqdW1wKSB7XG4gIGlmIChqdW1wID09PSBcImlcIikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGp1bXAgPT09IFwib1wiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBmdW5jdGlvbkRlcHRoU3RhY2tcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L3JlZHVjZXJzLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnRyYWNlOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmZ1bmN0aW9uIGluZGV4KHN0YXRlID0gMCwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuVE9DSzpcbiAgICAgIHJldHVybiBzdGF0ZSArIDE7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVTRVQ6XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiAwO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hlZChzdGF0ZSA9IGZhbHNlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5FTkRfT0ZfVFJBQ0U6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICBjYXNlIGFjdGlvbnMuVU5MT0FEX1RSQU5TQUNUSU9OOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGVwcyhzdGF0ZSA9IG51bGwsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNBVkVfU1RFUFM6XG4gICAgICByZXR1cm4gYWN0aW9uLnN0ZXBzO1xuICAgIGNhc2UgYWN0aW9ucy5VTkxPQURfVFJBTlNBQ1RJT046XG4gICAgICBkZWJ1ZyhcInVubG9hZGluZ1wiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgdHJhbnNhY3Rpb24gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBzdGVwc1xufSk7XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmRleCxcbiAgZmluaXNoZWRcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgdHJhbnNhY3Rpb24sXG4gIHByb2Ncbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9yZWR1Y2Vycy5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpjb250cm9sbGVyOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmZ1bmN0aW9uIGJyZWFrcG9pbnRzKHN0YXRlID0gW10sIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkFERF9CUkVBS1BPSU5UOlxuICAgICAgLy9jaGVjayBmb3IgYW55IGV4aXN0aW5nIGlkZW50aWNhbCBicmVha3BvaW50cyB0byBhdm9pZCByZWR1bmRhbmN5XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmZpbHRlcihcbiAgICAgICAgICBicmVha3BvaW50ID0+XG4gICAgICAgICAgICBicmVha3BvaW50LnNvdXJjZUlkID09PSBhY3Rpb24uYnJlYWtwb2ludC5zb3VyY2VJZCAmJlxuICAgICAgICAgICAgYnJlYWtwb2ludC5saW5lID09PSBhY3Rpb24uYnJlYWtwb2ludC5saW5lICYmXG4gICAgICAgICAgICBicmVha3BvaW50Lm5vZGUgPT09IGFjdGlvbi5icmVha3BvaW50Lm5vZGUgLy9tYXkgYmUgdW5kZWZpbmVkXG4gICAgICAgICkubGVuZ3RoID4gMFxuICAgICAgKSB7XG4gICAgICAgIC8vaWYgaXQncyBhbHJlYWR5IHRoZXJlLCBkbyBub3RoaW5nXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vb3RoZXJ3aXNlIGFkZCBpdFxuICAgICAgICByZXR1cm4gc3RhdGUuY29uY2F0KFthY3Rpb24uYnJlYWtwb2ludF0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVNT1ZFX0JSRUFLUE9JTlQ6XG4gICAgICByZXR1cm4gc3RhdGUuZmlsdGVyKFxuICAgICAgICBicmVha3BvaW50ID0+XG4gICAgICAgICAgYnJlYWtwb2ludC5zb3VyY2VJZCAhPT0gYWN0aW9uLmJyZWFrcG9pbnQuc291cmNlSWQgfHxcbiAgICAgICAgICBicmVha3BvaW50LmxpbmUgIT09IGFjdGlvbi5icmVha3BvaW50LmxpbmUgfHxcbiAgICAgICAgICBicmVha3BvaW50Lm5vZGUgIT09IGFjdGlvbi5icmVha3BvaW50Lm5vZGUgLy9tYXkgYmUgdW5kZWZpbmVkXG4gICAgICApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVNT1ZFX0FMTF9CUkVBS1BPSU5UUzpcbiAgICAgIHJldHVybiBbXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGVwcGluZyhzdGF0ZSA9IGZhbHNlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TVEFSVF9TVEVQUElORzpcbiAgICAgIGRlYnVnKFwiZ290IHN0ZXAgc3RhcnQgYWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBhY3Rpb25zLkRPTkVfU1RFUFBJTkc6XG4gICAgICBkZWJ1ZyhcImdvdCBzdGVwIHN0b3AgYWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGJyZWFrcG9pbnRzLFxuICBpc1N0ZXBwaW5nXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9yZWR1Y2Vycy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3REE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDS0E7QUFRQTtBQVlBO0FBZUE7QUFPQTtBQVFBO0FBUUE7QUFTQTtBQVFBO0FBUUE7QUFRQTtBQVFBO0FBU0E7QUFTQTtBQUNBO0FBM0hBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM5SEE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQVRBO0FBQ0E7QUFpQkE7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFsR0E7QUFDQTtBQXVHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQVFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5KQTtBQXNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7OztBQU1BO0FBUEE7QUFUQTtBQUNBO0FBcUJBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQVJBO0FBQ0E7QUFVQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQXZCQTtBQUNBO0FBeUJBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFHQTtBQURBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUlBOzs7O0FBSUE7QUFDQTtBQUlBOzs7QUFHQTtBQVFBO0FBR0E7QUFYQTtBQUNBO0FBYUE7Ozs7OztBQU1BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5GQTtBQUNBO0FBc0ZBOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBS0E7QUFEQTtBQTdCQTtBQXJLQTtBQUNBO0FBME1BOzs7QUFHQTtBQUNBOzs7OztBQUtBO0FBR0E7QUFEQTtBQUNBO0FBSUE7OztBQUdBO0FBaEJBO0FBQ0E7QUFrQkE7OztBQUdBO0FBQ0E7Ozs7O0FBS0E7QUFHQTtBQURBO0FBUkE7QUFuU0E7QUFDQTtBQWlUQTs7Ozs7Ozs7Ozs7OztBQ3RsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBSUE7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBSUE7Ozs7Ozs7QUFPQTtBQUNBO0FBS0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBL0VBO0FBQ0E7QUFpRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqR0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQVhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBSEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUF4Q0E7QUE4Q0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFKQTtBQUNBO0FBTUE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBT0E7QUFEQTtBQUNBO0FBNUlBO0FBQ0E7QUFrSkE7OztBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTs7O0FBR0E7QUFRQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBREE7QUFlQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUF2U0E7QUFDQTtBQTZTQTs7Ozs7QUFLQTtBQXRVQTtBQUNBO0FBd1VBOzs7Ozs7Ozs7Ozs7QUN4WkE7QUFRQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQXZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JBO0FBOENBO0FBSUE7QUEwQkE7QUFJQTtBQUlBO0FBQ0E7QUFqR0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVZBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFFQTtBQVZBO0FBQ0E7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25HQTtBQVNBO0FBUUE7QUFLQTtBQU9BO0FBT0E7QUFPQTtBQVFBO0FBT0E7QUFTQTtBQVFBO0FBUUE7QUFwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7QUN6RkE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzRCQTtBQUlBO0FBSUE7QUFZQTtBQXlpQkE7QUFJQTtBQXFGQTtBQUNBO0FBbnJCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7Ozs7Ozs7QUExQkE7QUFDQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQXpTQTtBQTJTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN0ckJBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7O0FDQ0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQVNBO0FBUUE7QUFRQTtBQU9BO0FBT0E7QUEzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFYQTtBQUNBO0FBV0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBWEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBR0E7QUFPQTtBQUNBO0FBRUE7QUFIQTtBQURBO0FBekJBO0FBSkE7QUFDQTtBQTJDQTs7O0FBR0E7QUFDQTs7OztBQUlBO0FBTEE7QUFDQTtBQWFBOzs7QUFHQTtBQUNBO0FBUUE7OztBQUdBO0FBQ0E7QUFXQTs7OztBQUlBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQUlBO0FBREE7QUFDQTtBQUtBOzs7Ozs7Ozs7OztBQVdBO0FBTUE7QUFEQTtBQTFJQTtBQUNBO0FBZ0pBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7O0FBT0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBSEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQXZEQTtBQUNBO0FBeURBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFkQTtBQUNBO0FBZ0JBOzs7QUFHQTtBQXJGQTtBQUNBO0FBMEZBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUdBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQXJCQTtBQUNBO0FBMEJBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQU9BO0FBREE7QUFDQTtBQUtBOzs7Ozs7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBV0E7QUFEQTtBQVFBO0FBREE7QUFwRUE7QUFDQTtBQTJFQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7Ozs7OztBQU1BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUF2Q0E7QUFDQTtBQWtEQTs7Ozs7QUFLQTtBQUtBO0FBSkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQTlKQTtBQWhSQTtBQUNBO0FBb2JBOzs7QUFHQTtBQUNBOzs7OztBQUtBO0FBQ0E7OztBQUdBO0FBSkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQW5FQTtBQUNBO0FBcUVBOzs7QUFHQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7O0FBR0E7QUFKQTtBQVJBO0FBdnhCQTtBQUNBO0FBOHlCQTs7Ozs7O0FDLzNCQTs7Ozs7Ozs7Ozs7O0FDa0JBO0FBV0E7QUFVQTtBQVVBO0FBNEJBO0FBK0VBO0FBTUE7QUFJQTtBQUNBO0FBdktBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBWEE7QUFDQTtBQVdBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUtBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFUQTtBQUNBO0FBU0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7QUFJQTs7O0FBR0E7QUE1QkE7QUFDQTtBQWlDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQVRBO0FBeERBO0FBQ0E7QUFvRUE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaERBO0FBQ0E7QUFrREE7Ozs7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBNUlBO0FBQ0E7QUE4SUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEpBO0FBY0E7QUE4QkE7QUFrQkE7QUFhQTtBQUNBO0FBdEZBO0FBQ0E7OztBQUVBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUxBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFOQTtBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBUEE7QUFDQTtBQU9BO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUFoQ0E7QUFDQTtBQXFDQTs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBakJBO0FBQ0E7QUFtQkE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQWxEQTtBQXpFQTtBQUNBO0FBaUlBOzs7Ozs7Ozs7Ozs7QUMxSUE7QUFXQTtBQVFBO0FBUUE7QUFrQkE7QUFLQTtBQVFBO0FBM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOzs7Ozs7QUNsRUE7Ozs7Ozs7Ozs7OztBQ0NBO0FBd0JBO0FBS0E7QUFVQTtBQVVBO0FBUUE7QUFZQTtBQVdBO0FBT0E7QUFVQTtBQU9BO0FBVUE7QUFVQTtBQVFBO0FBcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7Ozs7Ozs7Ozs7O0FDekNBO0FBMENBO0FBdUJBO0FBSUE7QUFDQTtBQXRLQTtBQUNBOzs7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFyQkE7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVdBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOUtBOzs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN5QkE7QUFnUEE7QUFDQTtBQTFRQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBZEE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbFFBO0FBa0NBO0FBSUE7QUFDQTtBQW5EQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVZBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckRBO0FBV0E7QUFRQTtBQUtBO0FBS0E7QUE5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUxBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFKQTtBQUpBO0FBQ0E7QUFXQTs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFkQTtBQUNBO0FBQ0E7QUFhQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQW1CQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFYQTtBQVlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUE3RkE7QUFDQTtBQURBOzs7Ozs7Ozs7Ozs7Ozs7O0FDekJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7QUFFQTtBQUNBOzs7Ozs7O0FBZkE7QUFDQTtBQWVBOzs7QUFHQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpCQTtBQTBCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUZBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQWhCQTtBQWlCQTtBQXBUQTtBQUFBOzs7Ozs7QUNwQkE7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDT0E7QUFxQ0E7QUFDQTtBQTlDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFOQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUlBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN0VBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkZBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6SkE7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUNBO0FBUUE7QUFRQTtBQVNBO0FBU0E7QUFRQTtBQTBCQTtBQXJFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUVBO0FBQ0E7OztBQUVBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUpBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFnQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSUE7QUE3Q0E7QUFBQTs7Ozs7O0FDTkE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ29DQTtBQTRDQTtBQTJGQTtBQUNBO0FBNUtBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFmQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5SEE7QUFDQTtBQTNEQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBUEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQVhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JHQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBVEE7QUFDQTtBQVNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBSEE7QUFEQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFIQTtBQUhBO0FBREE7QUFDQTtBQWVBO0FBQ0E7QUF4Q0E7QUEwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQVJBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBSEE7QUFOQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBREE7QUFGQTtBQUZBO0FBQ0E7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBREE7QUFIQTtBQUZBO0FBQ0E7QUFZQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2R0E7QUF5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM1JBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFUQTtBQUNBO0FBU0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFGQTtBQUZBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBckRBO0FBdURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQTRCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFGQTtBQUZBO0FBRkE7QUFGQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFIQTtBQUZBO0FBRkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFGQTtBQUZBO0FBWUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBbklBO0FBcUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNYQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUhBO0FBREE7QUFDQTtBQWFBOzs7QUFHQTtBQUNBO0FBM0JBO0FBNkJBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7OztBQ3ZGQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBTEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFMQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaENBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7OztBIiwic291cmNlUm9vdCI6IiJ9