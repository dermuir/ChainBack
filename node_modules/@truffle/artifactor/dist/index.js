"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const contract_schema_1 = __importDefault(require("@truffle/contract-schema"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("./utils");
const debug = require("debug")("artifactor");
class Artifactor {
    constructor(destination) {
        this.destination = destination;
    }
    save(artifactObject) {
        return __awaiter(this, void 0, void 0, function* () {
            const normalizedNewArtifact = contract_schema_1.default.normalize(artifactObject);
            const contractName = normalizedNewArtifact.contractName;
            if (!contractName)
                throw new Error("You must specify a contract name.");
            const outputPath = path_1.default.join(this.destination, `${contractName}.json`);
            try {
                const existingArtifact = fs_extra_1.default.readFileSync(outputPath, "utf8"); // check if artifact already exists
                const existingArtifactObject = JSON.parse(existingArtifact); // parse existing artifact
                const normalizedExistingArtifact = contract_schema_1.default.normalize(existingArtifactObject);
                const completeArtifact = utils_1.finalizeArtifact(normalizedExistingArtifact, normalizedNewArtifact);
                utils_1.writeArtifact(completeArtifact, outputPath);
            }
            catch (e) {
                // if artifact doesn't already exist, write new file
                if (e.code === "ENOENT")
                    return utils_1.writeArtifact(normalizedNewArtifact, outputPath);
                else if (e instanceof SyntaxError)
                    throw e; // catches improperly formatted artifact json
                throw e; // catch all other errors
            }
        });
    }
    saveAll(artifactObjects) {
        return __awaiter(this, void 0, void 0, function* () {
            let newArtifactObjects = {};
            if (Array.isArray(artifactObjects)) {
                const tmpArtifactArray = artifactObjects;
                tmpArtifactArray.forEach(artifactObj => {
                    newArtifactObjects[artifactObj.contract_name] = artifactObj;
                });
            }
            else {
                newArtifactObjects = artifactObjects;
            }
            try {
                fs_extra_1.default.statSync(this.destination); // check if destination exists
            }
            catch (e) {
                if (e.code === "ENOENT")
                    // if destination doesn't exist, throw error
                    throw new Error(`Destination "${this.destination}" doesn't exist!`);
                throw e; // throw on all other errors
            }
            Object.keys(newArtifactObjects).forEach(contractName => {
                let artifactObject = newArtifactObjects[contractName];
                this.save(artifactObject);
            });
        });
    }
}
module.exports = Artifactor;
//# sourceMappingURL=index.js.map