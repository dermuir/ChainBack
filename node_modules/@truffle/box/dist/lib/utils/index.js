"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const unbox_1 = __importDefault(require("./unbox"));
const fs_1 = __importDefault(require("fs"));
const config_1 = __importDefault(require("../config"));
const tmp_1 = __importDefault(require("tmp"));
const process_1 = __importDefault(require("process"));
const cwd = require("process").cwd();
const path_1 = __importDefault(require("path"));
module.exports = {
    downloadBox: (url, destination, events) => __awaiter(void 0, void 0, void 0, function* () {
        events.emit("unbox:downloadingBox:start");
        try {
            yield unbox_1.default.verifyURL(url);
            yield unbox_1.default.fetchRepository(url, destination);
            events.emit("unbox:downloadingBox:succeed");
        }
        catch (error) {
            events.emit("unbox:fail");
            throw error;
        }
    }),
    readBoxConfig: (destination) => __awaiter(void 0, void 0, void 0, function* () {
        const possibleConfigs = [
            path_1.default.join(destination, "truffle-box.json"),
            path_1.default.join(destination, "truffle-init.json")
        ];
        const configPath = possibleConfigs.reduce((path, alt) => path || (fs_1.default.existsSync(alt) && alt), undefined);
        return yield config_1.default.read(configPath);
    }),
    setUpTempDirectory: (events) => {
        events.emit("unbox:preparingToDownload:start");
        const options = {
            dir: process_1.default.cwd(),
            unsafeCleanup: true
        };
        try {
            const tmpDir = tmp_1.default.dirSync(options);
            events.emit("unbox:preparingToDownload:succeed");
            return {
                path: path_1.default.join(tmpDir.name, "box"),
                cleanupCallback: tmpDir.removeCallback
            };
        }
        catch (error) {
            events.emit("unbox:fail");
            throw error;
        }
    },
    unpackBox: (tempDir, destination, boxConfig, unpackBoxOptions) => __awaiter(void 0, void 0, void 0, function* () {
        unbox_1.default.prepareToCopyFiles(tempDir, boxConfig);
        yield unbox_1.default.copyTempIntoDestination(tempDir, destination, unpackBoxOptions);
    }),
    setUpBox: (boxConfig, destination, events) => {
        events.emit("unbox:settingUpBox:start");
        try {
            unbox_1.default.installBoxDependencies(boxConfig, destination);
            events.emit("unbox:settingUpBox:succeed");
        }
        catch (error) {
            events.emit("unbox:fail");
            throw error;
        }
    }
};
//# sourceMappingURL=index.js.map